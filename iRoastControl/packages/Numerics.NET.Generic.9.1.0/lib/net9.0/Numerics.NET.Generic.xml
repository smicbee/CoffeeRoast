<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Numerics.NET.Generic</name>
  </assembly>
  <members>
    <member name="T:Numerics.NET.GenericCoreProvider`1">
      <summary>
            Represents a managed provider for the core linear algebra and FFT functionality 
            for an element type.
            </summary>
      <remarks>
        <para>
            The classes in the <see cref="N:Numerics.NET.LinearAlgebra" />
            namespace use the standard Basic Linear Algebra Subroutines
            (BLAS) whenever possible. The Extreme Optimization Mathematics Library
            for .NET provides two implementations. One is in 100% managed code.
            The other calls a native, highly optimized, processor-specific kernel.</para>
        <para>This class exposes properties that allow
            you to specify the BLAS objects that are to be used by
            the classes in this namespace.</para>
        <para>You can select the managed implementation by calling the <see cref="M:Numerics.NET.CoreImplementations`1.UseManaged" />
            method. To select the native implementation, call the <see cref="M:Numerics.NET.CoreImplementations`1.UseNative" /> method.
            The native kernel is used by default. This is the fastest option,
            especially for larger matrices, but also has a larger memory footprint.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.GenericCoreProvider`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Providers.ManagedCoreProvider" />.
            </summary>
    </member>
    <member name="P:Numerics.NET.GenericCoreProvider`1.ArrayFunctions">
      <summary>
            Gets or sets the current implementation of array functions
            for double-precision arguments.
            </summary>
      <value>A class that inherits from <see cref="T:Numerics.NET.Implementation.DecompositionOperations`2" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctions`1" />.
            </para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.GenericCoreProvider`1.ComplexArrayFunctions">
      <summary>
            Gets or sets the current implementation of array functions
            for double-precision arguments.
            </summary>
      <value>A class that inherits from <see cref="T:Numerics.NET.Implementation.DecompositionOperations`2" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctions`1" />.
            </para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.GenericCoreProvider`1.DecompositionOperations">
      <summary>
            Gets the LAPACK implementation
            for T-precision arguments.
            </summary>
      <value>A class that inherits from <see cref="T:Numerics.NET.LinearAlgebra.Implementation.DecompositionOperations`2" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1" />.
            </para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.GenericCoreProvider`1.Fft">
      <summary>
            Gets or sets the current FFT provider implementation
            for T-precision arguments.
            </summary>
      <value>A class that inherits from 
            <see cref="T:Numerics.NET.SignalProcessing.FftOperations`1" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.SignalProcessing.FftOperations`1" />.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.GenericCoreProvider`1.GetAllImplementations``1">
      <summary>
            Returns a sequence of all implementations of the specified type
            supported by the provider.
            </summary>
      <typeparam name="U">The type of the implementation.</typeparam>
      <returns>A sequence of all implementations of type <typeparamref name="U" />
            supported by the provider.</returns>
    </member>
    <member name="P:Numerics.NET.GenericCoreProvider`1.HasSharedDegreeOfParallelism">
      <summary>
            Indicates whether the degree of parallelism is a property that is shared
            across instances.
            </summary>
    </member>
    <member name="P:Numerics.NET.GenericCoreProvider`1.LinearAlgebraOperations">
      <summary>
            Gets the implementation of the 
            BLAS for T-precision arguments.
            </summary>
      <value>A class that inherits from <see cref="T:Numerics.NET.LinearAlgebra.Implementation.LinearAlgebraOperations`1" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.LinearAlgebra.Implementation.LinearAlgebraOperations`1" />.
            </para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.GenericCoreProvider`1.SparseLinearAlgebra">
      <summary>
            Gets the implementation of the sparse
            BLAS for T-precision arguments.
            </summary>
      <value>A class that inherits from <see cref="T:Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperations`1" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperations`1" />.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.GenericCoreProvider`1.WithMaxDegreeOfParallelism(System.Int32)">
      <summary>
            Returns a provider with the specified maximum degree of parallelism.
            </summary>
      <param name="maxDegreeOfParallelism">The maximum degree of parallelism.</param>
      <returns>A <see cref="T:Numerics.NET.Providers.ManagedCoreProvider" /> with the specified
            maximum degree of parallelism.</returns>
    </member>
    <member name="T:Numerics.NET.GenericImplementations">
      <summary>
            Provides access to the generic provider.
            </summary>
    </member>
    <member name="M:Numerics.NET.GenericImplementations.RegisterGenericProvider(Numerics.NET.Providers.ProviderManager)">
      <summary>
            Registers the provider of generic implementations of linear
            algebra functions.
            </summary>
      <param name="providerManager"></param>
    </member>
    <member name="T:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1">
      <summary>
            Represents a numerical integrator that uses an adaptive
            algorithm based on a Gauss-Kronrod integration rule.
            </summary>
      <remarks>
        <para>The <see cref="T:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1" /> class
            provides the most robust, reliable, and in most cases the
            fastest numerical integration algorithm. It uses a simple
            integration rule to approximate the integral over
            subintervals. In each step, the interval with the largest
            estimated error is divided in two, and new approximations
            for these two subintervals are calculated. This process
            continues until the total estimated error over all
            intervals is within the desired tolerance.</para>
        <para>
          <see cref="T:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1" />
            inherits from <see cref="T:Numerics.NET.Calculus.Generic.NumericalIntegrator`1" />, the
            <see langword="abstract" /> base class for all numerical integration classes.
            It, in turn, inherits from the <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" />
            class. All properties of this class are also available.
            The <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.AbsoluteTolerance" /> and
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.RelativeTolerance" /> properties set the desired
            precision as specified by the
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.ConvergenceCriterion" /> property. The default
            value for both tolerances is
            <see cref="F:Numerics.NET.MachineConstants.SqrtEpsilon" /> (roughly
            10<sup>-8</sup>). <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.MaxIterations" /> sets the
            maximum number of iterations, which in this case is the
            maximum number of subintervals. The default value for
            this property is 5000. <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.IterationsNeeded" />
            returns the actual number of iterations performed after
            the algorithm has completed.</para>
        <para>The <see cref="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.Integrate(System.Func{`0,`0},`0,`0,`0[])" /> method does the actual
            work of numerically integrating an integrand. It
            takes three parameters. The first parameter is a
            function of one variable that specifies the
            function to integrate. The second and third parameters are
            <typeparamref name="T" /> values that specify the lower and
            upper bounds of the integration interval.</para>
        <para>The <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" /> property lets you
            specify which integration rule to use to approximate integrals 
            on a subinterval. Integration rules can be obtained by calling
            static methods of the <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" /> class.
            The default is
            the <see cref="!:IntegrationRule&lt;T&gt;.CreateGaussKronrod31PointRule&lt;T&gt;">31-point rule</see>
            for normal integrands, and the
            <see cref="!:IntegrationRule&lt;T&gt;.CreateGaussKronrod15PointRule&lt;T&gt;">15-point rule</see>
            when singularities are expected, and when integrating
            over infinite intervals. For oscillating integrands, 
            the higher order rules will tend to give better results.</para>
        <para>Several enhancements make this the integration
            algorithm of choice, especially for 'difficult' target
            functions.</para>
        <para>An extra property, <see cref="P:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.UseExtrapolation" />,
            lets you specify whether special precautions should be
            taken to deal with singularities. If <see cref="P:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.UseExtrapolation" />
            is <b>true</b>, an extrapolation algorithm is used to
            approximate the integral near a singularity or
            singularities. Because this option requires extra
            resources, it is recommended only for integrands
            that actually have singularities inside or at the
            boundaries of the integration interval.</para>
        <para>The <see cref="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.SetSingularities(`0[])" /> and <see cref="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.GetSingularities" />
            methods let you specify and retrieve
            the points inside the integration interval where
            the integrand has a singularity or a discontinuity.
            They are returned as a <typeparamref name="T" /> array
            containing the problem points. Extrapolation is used once
            again to approximate the integral near the singularity or
            singularities. Specifying the problem points in the target
            function can lead to speed-ups of several orders of
            magnitude.</para>
        <para>Unlike other classes, this integrator can deal
            successfully with infinite integration intervals. Specify
            <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" /> or
            <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" /> for one or both
            bounds of the integration interval. Internally, the class
            transforms the infinite interval to a finite interval,
            and performs the integration of the transformed 
            integrand over the transformed interval.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1" /> object.
            </summary>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.#ctor(Numerics.NET.Calculus.Generic.IntegrationRule{`0},System.Boolean)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1" /> object.
            </summary>
      <param name="integrationRule{T}{T}">
            A <see cref="T:Numerics.NET.Calculus.Generic.NumericalIntegrator`1" /> value that specifies the integration
            rule to use on subintervals.
            </param>
      <param name="useExtrapolation">If <b>true</b>, special
            operations are performed to speed convergence in
            case of singularities inside the integration interval
            or at the end points. If <see langword="false" />, no special
            operations are performed.
            </param>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.#ctor(System.Boolean)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1" /> object.
            </summary>
      <param name="useExtrapolation">If <b>true</b>, special
            operations are performed to speed convergence in
            case of singularities inside the integration interval
            or at the end points. If <see langword="false" />, no special
            operations are performed.
            </param>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.#ctor(System.Func{`0,`0},`0,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1" /> object.
            </summary>
      <param name="integrand">A delegate that represents a function of one variable
            that specifies the function to integrate.</param>
      <param name="lowerBound">The lower limit of the integration
            interval.</param>
      <param name="upperBound">The upper limit of the integration
            interval.</param>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.#ctor(System.Func{`0,`0},`0[])">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1" /> object.
            </summary>
      <param name="integrand">A delegate that represents a function of one variable
            that specifies the function to integrate.</param>
      <param name="singularities">A <typeparamref name="T" /> array containing the
            singularities and discontinuities of <paramref name="integrand" />.
            </param>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.Clone">
      <summary>
            Returns a copy of this numerical integrator object.
            </summary>
      <returns>A copy of this instance.</returns>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.GetSingularities">
      <summary>
            Returns an array of <typeparamref name="T" /> values
            containing the locations of singularities of the
            integrand inside the integration interval.
            </summary>
      <returns>A <typeparamref name="T" /> array.</returns>
      <remarks>
        <para>
            This property should contain all points inside the
            integration interval where the numerical integration
            might encounter difficulties. These can be of two
            kinds:
            <list type="bullet"><item>The integrand has a singularity at
            the specified point. Even though the function value
            goes to infinity near the point, the value of the
            integral is finite.</item><item>The integrand has a discontinuity
            at the specified point. The sudden jump in function
            values would cause convergence to be very slow.</item></list></para>
        <para>Only interior problem points should be
            listed. The bounds of the integration interval
            are treated separately.</para>
        <para>When there is at least one interior
            singularity or discontinuity, the
            <see cref="P:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.UseExtrapolation" /> property is automatically
            set to <b>true</b>, and extrapolation is used to
            improve convergence for the integration around
            the problem point(s).</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.Integrate(System.Func{`0,`0},`0,`0,`0[])">
      <summary>
            Numerically integrates a function of one variable.
            </summary>
      <param name="integrand">A delegate that represents a function of one variable
            that specifies the function to integrate.</param>
      <param name="lowerBound">The lower limit of the integration
            interval.</param>
      <param name="upperBound">The upper limit of the integration
            interval.</param>
      <param name="singularities">A <typeparamref name="T" /> array containing the points where the
            integration might encounter difficulties.</param>
      <returns>An approximation of the definite integral of
            <paramref name="integrand" /> from <paramref name="lowerBound" /> to
            <paramref name="upperBound" />.</returns>
      <remarks>
        <para>This method performs the actual numerical
            integration. After this method returns, inspect the
            <see cref="T:Numerics.NET.AlgorithmStatus" /> property to verify
            that the algorithm terminated normally.
            </para>
        <para>Depending on the nature of the integrand and
            the desired accuracy, this operation may take a
            long time to complete.</para>
        <para>If the <see cref="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.SetSingularities(`0[])" /> method has been called with at least one parameter, then
            Extrapolation is always used.</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.IntegrationRule">
      <summary>
            Gets or sets the integration rule to be used to
            estimate integrals over subintervals.
            </summary>
      <value>One of the <see cref="T:Numerics.NET.Calculus.Generic.NumericalIntegrator`1" />
            derived integration rules.</value>
      <remarks>
        <para>If the interval contains singularities,
            a low-order rule is recommended.
            </para>
        <para>Integration rules can be obtained by calling
            static methods of the <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" /> class.
            The default is
            the <see cref="!:IntegrationRule&lt;T&gt;.CreateGaussKronrod31PointRule&lt;T&gt;">31-point rule</see>
            for normal integrands, and the
            <see cref="!:IntegrationRule&lt;T&gt;.CreateGaussKronrod15PointRule&lt;T&gt;">15-point rule</see>
            when singularities are expected, and when integrating
            over infinite intervals.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.Iterate">
      <summary>
            Performs one iteration of the algorithm.
            </summary>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.Iterated">
      <summary>
            Performs tasks after the iteration is completed, but before
            the status of the algorithm is finalized.
            </summary>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.OnInit">
      <summary>
            Initializes the algorithm.
            </summary>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.Order">
      <summary>
            Gets the order of the Gauss-Kronrod formula used to
            calculate the integral on subintervals.
            </summary>
      <value>The order of the <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" />
            used to approximate the integral on subintervals.</value>
      <remarks>
        <para>For an <see cref="T:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1" />,
            this property is equal to the order of the
            numerical integrator specified by the
            <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" /> property.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.SetSingularities(`0[])">
      <summary>
            Sets the locations of singularities of the
            integrand inside the integration interval.
            </summary>
      <param name="singularities">A <typeparamref name="T" /> array containing the singularities
            of the integrand.</param>
      <remarks>
        <para>
            Use this method to declare all points inside the
            integration interval where the numerical integration
            might encounter difficulties. These can be of two
            kinds:
            <list type="bullet"><item>The integrand has a singularity at
            the specified point. Even though the function value
            goes to infinity near the point, the value of the
            integral is finite.</item><item>The integrand has a discontinuity
            at the specified point. The sudden jump in function
            values would cause convergence to be very slow.</item></list></para>
        <para>Only interior problem points should be
            listed. The bounds of the integration interval
            are treated separately.</para>
        <para>When there is at least one interior
            singularity or discontinuity, the
            <see cref="P:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.UseExtrapolation" /> property is automatically
            set to <b>true</b>, and extrapolation is used to
            improve convergence for the integration around
            the problem point(s).</para>
        <para>An array containing the current singularities can be retrieved using the
            <see cref="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.GetSingularities" /> method.</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.UseExtrapolation">
      <summary>
            Gets or sets whether precautions
            should be taken to deal with singularities on the
            integration interval.
            </summary>
      <value>
        <b>true</b> if extrapolation is to be used;
            <see langword="false" /> if not.</value>
      <remarks>
        <para>If <b>UseExtrapolation</b> is <b>true</b>, the
            results of the integration are extrapolated using the
            terms-algorithm, which accelerates the convergence of the
            integral in the presence of discontinuities and integrable
            singularities.
            </para>
        <para>Using this option requires some extra
            resources. It is only recommended for integrands
            with singularities or discontinuities on the
            integration interval. It is automatically turned
            on when singularities are specified using the
            <see cref="M:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1.SetSingularities(`0[])" /> method, and when
            integrating over infinite intervals.</para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.Calculus.Generic.GaussKronrodRule`1">
      <summary>
            Abstract base class for Gauss-Kronrod type numerical
            integrators.
            </summary>
      <remarks>
        <para>
          <see cref="T:Numerics.NET.Calculus.GaussKronrodRule" /> is the <see langword="abstract" />
            base class for classes that represent Gauss-Kronrod integration rules.
            Gauss-Kronrod methods use two integration formulas of
            different orders where the integration points of the lower
            order formula are also integration points for the higher
            order formula. This gives a way to estimate the integration
            error without doing any extra function evaluations.</para>
        <para>Classes derived from <see cref="T:Numerics.NET.Calculus.GaussKronrodRule" />
            apply the integration formula to the entire integration
            interval. They are used most often as integration rules
            for subintervals in adaptive integration algorithms as
            implemented by the <see cref="T:Numerics.NET.Calculus.AdaptiveIntegrator" /> class.</para>
        <para>A number of ready-to-use integration rules have
            been supplied, as listed in the table below.
            <list type="table"><listheader><term>Class</term><description>Description</description></listheader><item><term><see cref="!:GaussKronrod15PointRule()" /></term><description>7-point Gauss with 15-point Kronrod rule.</description></item><item><term><see cref="!:GaussKronrod21PointRule()" /></term><description>10-point Gauss with 21-point Kronrod rule.</description></item><item><term><see cref="!:GaussKronrod31PointRule()" /></term><description>15-point Gauss with 31-point Kronrod rule.</description></item><item><term><see cref="!:GaussKronrod41PointRule()" /></term><description>20-point Gauss with 41-point Kronrod rule.</description></item><item><term><see cref="!:GaussKronrod51PointRule()" /></term><description>25-point Gauss with 51-point Kronrod rule.</description></item><item><term><see cref="!:GaussKronrod61PointRule()" /></term><description>30-point Gauss with 61-point Kronrod rule.</description></item></list></para>
        <para>To create a Gauss-Kronrod integrator of a different
            order, derive your class from
            <see cref="T:Numerics.NET.Calculus.GaussKronrodRule" />, and implement the
            <see cref="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.GetGaussWeights" />, <see cref="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.GetKronrodWeights" />,
            and <see cref="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.GetKronrodPoints" /> properties. You should also
            override the <see cref="P:Numerics.NET.Calculus.NumericalIntegrator.Order" /> property
            to return the order of the integration rule.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.#ctor(System.Int32)">
      <summary>
            Constructs a new Gauss-Kronrod rule of the specified order.
            </summary>
      <param name="order">The order of the rule. Must be an odd, positive integer.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="order" /> is even or negative.</para>
      </exception>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.Evaluate(System.Func{`0,`0},Numerics.NET.Interval{`0},System.Threading.Tasks.ParallelOptions)">
      <summary>
            Numerically integrates a function of one variable.
            </summary>
      <param name="integrand">A delegate that represents a function of one variable that represents the function to integrate.</param>
      <param name="interval">An <see cref="T:Numerics.NET.Interval" /> that represents the integration interval.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions" /> object that specifies how the calculation
            should be parallelized.</param>
      <returns>An approximation of the definite integral of
            <paramref name="integrand" /> over <paramref name="interval" />.</returns>
      <remarks>
        <para>This method scales the integration interval
            to a standard size and applies the fixed point formula.
            The difference between the low order Gauss and higher
            order Kronrod formula is returned as an estimate for the
            integration error.</para>
        <para>No actual iteration is performed. This is a
            one-step procedure.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.gauss(System.Int32,Numerics.NET.Vector{`0},Numerics.NET.Vector{`0})"></member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.GetGaussWeights">
      <summary>
            Gets an array specifying
            the weights associated with the Gaussian quadrature
            points for this <see cref="T:Numerics.NET.Calculus.GaussKronrodRule" />.
            </summary>
      <returns>A <typeparamref name="T" /> array containing
            the Gauss weights.</returns>
      <remarks>
        <para>This array contains the weights for
            the Gauss integration formula. The weights correspond
            to the points with odd indexes in the
            <see cref="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.GetKronrodPoints" /> array. If the
            order of the Gauss formula is odd, the last element
            of this array should specify the weight for the midpoint
            of the integration interval.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.GetKronrodPoints">
      <summary>
            Gets an array specifying
            the Kronrod quadrature points for this
            <see cref="T:Numerics.NET.Calculus.GaussKronrodRule" />.
            </summary>
      <returns>A <typeparamref name="T" /> array containing
            the abscissae for the Gauss-Kronrod points.</returns>
      <remarks>
        <para>This array contains the integration points
            for the integration formula over an interval (-1,+1).
            The points must be listed in decreasing order. Only the
            points on the positive half of the interval should be
            listed, including the middle point of the interval,
            if it is there.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.GetKronrodWeights">
      <summary>
            Gets an array specifying
            the weights associated with the Kronrod quadrature
            points for this <see cref="T:Numerics.NET.Calculus.GaussKronrodRule" />.
            </summary>
      <returns>A <typeparamref name="T" /> array containing
            the weights for the Kronrod points.</returns>
      <remarks>
        <para>This array contains the weights for
            the Kronrod integration formula, corresponding to the
            points int the <see cref="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.GetKronrodPoints" /> array.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.kronrod(System.Int32,Numerics.NET.Vector{`0},Numerics.NET.Vector{`0})"></member>
    <member name="P:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.Order">
      <summary>
            Gets the order of the numerical integrator.
            </summary>
      <value>An integer greater than 0.</value>
      <remarks>
        <para>The integration rule returns a mathematically exact value for the
            integral of a polynomial of degree <see cref="P:Numerics.NET.Calculus.Generic.IntegrationRule`1.Order" /> or below.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.r_jacobi(System.Int32,`0,`0)"></member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.r_jacobi01(System.Int32)"></member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.r_jacobi01(System.Int32,`0)"></member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.r_jacobi01(System.Int32,`0,`0)"></member>
    <member name="M:Numerics.NET.Calculus.Generic.GaussKronrodRule`1.r_kronrod(System.Int32,Numerics.NET.Vector{`0},Numerics.NET.Vector{`0})"></member>
    <member name="T:Numerics.NET.Calculus.Generic.IntegrationRule`1">
      <summary>
            Represents a method to compute an approximation to an integral together with
            an estimate of the error.
            </summary>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.IntegrationRule`1.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Numerics.NET.Calculus.Generic.IntegrationRule`1</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.IntegrationRule`1.CreateGaussKronrod15PointRule">
      <summary>
            Returns a new instance of a 15 point Gauss-Kronrod integration rule.
            </summary>
      <returns>An <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" />.</returns>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.IntegrationRule`1.CreateGaussKronrod21PointRule">
      <summary>
            Returns a new instance of a 21 point Gauss-Kronrod integration rule.
            </summary>
      <returns>An <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" />.</returns>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.IntegrationRule`1.CreateGaussKronrod31PointRule">
      <summary>
            Returns a new instance of a 31 point Gauss-Kronrod integration rule.
            </summary>
      <returns>An <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" />.</returns>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.IntegrationRule`1.CreateGaussKronrod41PointRule">
      <summary>
            Returns a new instance of a 41 point Gauss-Kronrod integration rule.
            </summary>
      <returns>An <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" />.</returns>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.IntegrationRule`1.CreateGaussKronrod51PointRule">
      <summary>
            Returns a new instance of a 51 point Gauss-Kronrod integration rule.
            </summary>
      <returns>An <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" />.</returns>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.IntegrationRule`1.CreateGaussKronrod61PointRule">
      <summary>
            Returns a new instance of a 61 point Gauss-Kronrod integration rule.
            </summary>
      <returns>An <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" />.</returns>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.IntegrationRule`1.Evaluate(System.Func{`0,`0},Numerics.NET.Interval{`0})">
      <summary>
            Evaluates the rule for the specified function and interval.
            </summary>
      <param name="f">The function to integrate.</param>
      <param name="interval">The interval over which to perform the integration.</param>
      <returns>A <see cref="T:Numerics.NET.Calculus.IntegrationRuleResult" /> structure that contains
            the result of the evaluation.</returns>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.IntegrationRule`1.Evaluate(System.Func{`0,`0},Numerics.NET.Interval{`0},System.Threading.Tasks.ParallelOptions)">
      <summary>
            Evaluates the rule for the specified function and interval.
            </summary>
      <param name="f">The function to integrate.</param>
      <param name="interval">The interval over which to perform the integration.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions" /> object that specifies how the calculation should be parallelized.</param>
      <returns>A <see cref="T:Numerics.NET.Calculus.IntegrationRuleResult" /> structure that contains
            the result of the evaluation.</returns>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.IntegrationRule`1.Order">
      <summary>
            Gets the order of the numerical integrator.
            </summary>
      <value>An integer greater than 0.</value>
      <remarks>
        <para>The integration rule returns a mathematically exact value for the
            integral of a polynomial of degree <see cref="P:Numerics.NET.Calculus.Generic.IntegrationRule`1.Order" /> or below.</para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.Calculus.Generic.IntegrationRuleResult`1">
      <summary>
            Represents the result of evaulating an <see cref="T:Numerics.NET.Calculus.Generic.IntegrationRule`1" />.
            </summary>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.IntegrationRuleResult`1.#ctor(`0,`0,System.Int32)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.IntegrationRuleResult" /></summary>
      <param name="value">The computed value of the integral.</param>
      <param name="error">An estimate for the error over the interval.</param>
      <param name="evaluations">The number of function evaluations.</param>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.IntegrationRuleResult`1.EstimatedError">
      <summary>
            Gets an estimate for the error over the interval.
            </summary>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.IntegrationRuleResult`1.Evaluations">
      <summary>
            Gets the number of function evaluations.
            </summary>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.IntegrationRuleResult`1.Value">
      <summary>
            Gets the computed value of the integral.
            </summary>
    </member>
    <member name="T:Numerics.NET.Calculus.Generic.LeftPointIntegrator`1">
      <summary>
            Represents a numerical integrator that uses the left point rule.
            </summary>
      <remarks>
        <para>The left point rule is one of the simplest numerical
            integration algorithms around. The interval is divided into smaller
            intervals, and the function value on the left side of the subinterval is
            taken as an approximation for the function over the entire subinterval.</para>
        <para>This algorithm is of order 1. In each
            iteration, the number of points is doubled. The difference between
            successive approximations is taken as the estimate for the integration
            error.</para>
        <para>Because the order of the algorithm is so low, use of this
            algorithm is not generally recommended for general use. It does provide a unique
            feature in that can produce absolute bounds on the value of the integral
            of some functions. It produces a lower bound for monotonically increasing
            integrands, and an upper bound for monotonically decreasing integrands.
            Complementary bounds are produced by the <see cref="T:Numerics.NET.Calculus.Generic.RightPointIntegrator`1" />.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.LeftPointIntegrator`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.LeftPointIntegrator`1" /> object.
            </summary>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.LeftPointIntegrator`1.Order">
      <summary>
            Gets the order of the numerical integrator.
            </summary>
      <value>Always returns 1.</value>
      <remarks>
        <para>The left-point rule is of order one. This means
            that a linear function is integrated exactly.
            </para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.Calculus.Generic.MidpointIntegrator`1">
      <summary>
            Represents a numerical integrator that uses the mid-point rule.
            </summary>
      <remarks>
        <para>The right point rule is one of the simplest numerical
            integration algorithms around. The interval is divided into smaller
            intervals, and the function value in the middle of the subinterval is
            taken as an approximation for the function over the entire subinterval.</para>
        <para>This algorithm is of order 1. In each
            iteration, the number of points is doubled. The difference between
            successive approximations is taken as the estimate for the integration
            error.</para>
        <para>Because the order of the algorithm is so low, use of this
            algorithm is not generally recommended for general use. The fact that
            previous integration points are not re-used makes this algorithm
            extra inefficient. However, it does provide a unique
            feature in that can produce absolute bounds on the value of the integral
            of some functions. It produces an upper bound for concave integrands, and a
            lower bound for convex integrands. Complementary bounds are produced by
            the <see cref="T:Numerics.NET.Calculus.Generic.TrapezoidIntegrator`1" />.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.MidpointIntegrator`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.MidpointIntegrator`1" /> object.
            </summary>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.MidpointIntegrator`1.Order">
      <summary>
            Gets the order of the numerical integrator.
            </summary>
      <value>Always returns 1.</value>
      <remarks>
        <para>The mid-point rule is of order one. This means
            that a linear function is integrated exactly.
            </para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.Calculus.Generic.NumericalIntegrator`1">
      <summary>
            Serves as an abstract base class for classes that represent
            an implementation of a numerical integration algorithm.
            </summary>
      <remarks>
        <para>
          <see cref="T:Numerics.NET.Calculus.Generic.NumericalIntegrator`1" /> is the <see langword="abstract" />
            base class for classes that implement numerical integration algorithms.
            It cannot be instantiated directly. Instead, use one of the derived
            classes:
            <list type="table"><listheader><term>Class</term><description>Description</description></listheader><item><term><see cref="T:Numerics.NET.Calculus.Generic.SimpsonIntegrator`1" /></term><description>Represents a numerical integrator that uses Simpson's rule.</description></item><item><term><see cref="T:Numerics.NET.Calculus.Generic.RombergIntegrator`1" /></term><description>Represents a numerical integrator that uses Romberg's method.</description></item><item><term><see cref="!:NonAdaptiveGaussKronrodIntegrator&lt;T&gt;" /></term><description>Represents a numerical integrator that uses a
            non-adaptive 87-point Gauss-Kronrod algorithm. </description></item><item><term><see cref="T:Numerics.NET.Calculus.Generic.AdaptiveIntegrator`1" /></term><description>Represents a numerical integrator that uses an adaptive algorithm
            based on a Gauss-Kronrod integration rule.</description></item></list></para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.NumericalIntegrator`1" /> object.
            </summary>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.#ctor(System.Func{`0,`0},`0,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.NumericalIntegrator`1" /> object.
            </summary>
      <param name="integrand">A delegate that represents a function of one variable
            that specifies the function to integrate.</param>
      <param name="lowerBound">The lower limit of the integration
            interval.</param>
      <param name="upperBound">The upper limit of the integration
            interval.</param>
      <returns>An approximation of the definite integral of
            <paramref name="integrand" /> from <paramref name="lowerBound" /> to
            <paramref name="upperBound" />.</returns>
      <remarks>
        <para>This method performs the actual numerical integration. After
            this method returns, inspect the <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" />
            property to verify that the algorithm terminated normally.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Clone">
      <summary>
            Returns a copy of this numerical integrator object.
            </summary>
      <returns>A copy of this instance.</returns>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Evaluate(`0)">
      <summary>
            Evaluates the integrand and increments the number of function evaluations.
            </summary>
      <param name="x">The value at which to evaluate the integrand.</param>
      <returns>The value of the integrand at <paramref name="x" />.</returns>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrand">
      <summary>
            Gets or sets the function to integrate.
            </summary>
      <value>A delegate that represents a function of one variable delegate.</value>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrate">
      <summary>
            Numerically integrates a function of one variable.
            </summary>
      <returns>An approximation of the definite integral for the integrator's current
            <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrand" /> between <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.LowerBound" /> and <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.UpperBound" />.
            .</returns>
      <remarks>
        <para>This method performs the actual numerical integration using the <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrand" />
            and integration interval specified by the <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.LowerBound" /> and <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.UpperBound" />
            properties. After this method returns, inspect the <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" />
            property to verify that the algorithm terminated normally.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrate(System.Func{`0,`0},`0,`0)">
      <summary>
            Numerically integrates a function of one variable.
            </summary>
      <param name="integrand">A delegate that represents a function of one variable
            that specifies the function to integrate.</param>
      <param name="lowerBound">The lower limit of the integration
            interval.</param>
      <param name="upperBound">The upper limit of the integration
            interval.</param>
      <returns>An approximation of the definite integral of
            <paramref name="integrand" /> from <paramref name="lowerBound" /> to
            <paramref name="upperBound" />.</returns>
      <remarks>
        <para>This method performs the actual numerical integration. After
            this method returns, inspect the <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" />
            property to verify that the algorithm terminated normally.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrate(System.Func{`0,`0},`0,`0,System.Threading.Tasks.ParallelOptions)">
      <summary>
            Numerically integrates a function of one variable.
            </summary>
      <param name="integrand">A delegate that represents a function of one variable
            that specifies the function to integrate.</param>
      <param name="lowerBound">The lower limit of the integration
            interval.</param>
      <param name="upperBound">The upper limit of the integration
            interval.</param>
      <param name="parallelOptions">The configuration for the parallel behavior of the integration.</param>
      <returns>An approximation of the definite integral of
            <paramref name="integrand" /> from <paramref name="lowerBound" /> to
            <paramref name="upperBound" />.</returns>
      <remarks>
        <para>This method performs the actual numerical integration. After
            this method returns, inspect the <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" />
            property to verify that the algorithm terminated normally.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrate(System.Threading.Tasks.ParallelOptions)">
      <summary>
            Numerically integrates a function of one variable.
            </summary>
      <returns>An approximation of the definite integral for the integrator's current
            <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrand" /> between <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.LowerBound" /> and <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.UpperBound" />.
            .</returns>
      <remarks>
        <param name="parallelOptions">The configuration for the parallel behavior of the integration.</param>
        <para>This method performs the actual numerical integration using the <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrand" />
            and integration interval specified by the <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.LowerBound" /> and <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.UpperBound" />
            properties. After this method returns, inspect the <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" />
            property to verify that the algorithm terminated normally.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrate(`0,`0)">
      <summary>
            Numerically integrates a function of one variable.
            </summary>
      <param name="lowerBound">The lower limit of the integration
            interval.</param>
      <param name="upperBound">The upper limit of the integration
            interval.</param>
      <returns>An approximation of the definite integral of the
            <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrand" /> from <paramref name="lowerBound" /> to
            <paramref name="upperBound" />.</returns>
      <remarks>
        <para>This method performs the actual numerical integration. After
            this method returns, inspect the <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" />
            property to verify that the algorithm terminated normally.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrate(`0,`0,System.Threading.Tasks.ParallelOptions)">
      <summary>
            Numerically integrates a function of one variable.
            </summary>
      <param name="lowerBound">The lower limit of the integration
            interval.</param>
      <param name="upperBound">The upper limit of the integration
            interval.</param>
      <param name="parallelOptions">The configuration for the parallel behavior of the integration.</param>
      <returns>An approximation of the definite integral of the
            <see cref="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Integrand" /> from <paramref name="lowerBound" /> to
            <paramref name="upperBound" />.</returns>
      <remarks>
        <para>This method performs the actual numerical integration. After
            this method returns, inspect the <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" />
            property to verify that the algorithm terminated normally.</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.LowerBound">
      <summary>
            Gets or sets the lower bound of the integration interval.
            </summary>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.OnInit">
      <summary>
            Initializes the algorithm.
            </summary>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.Order">
      <summary>
            Gets the order of the numerical integrator.
            </summary>
      <value>An integer greater than 0.</value>
      <remarks>
        <para>The value of this property depends on
            the algorithm and integration rule.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.TestConvergence">
      <summary>
            Checks whether the algorithm has converged.
            </summary>
      <returns>A <see cref="T:Numerics.NET.AlgorithmStatus" /> value that indicates the current status of the iteration.</returns>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.TransformedIntegrand">
      <summary>
            Gets or sets the 
            </summary>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.NumericalIntegrator`1.UpperBound">
      <summary>
            Gets or sets the upper bound of the integration interval.
            </summary>
    </member>
    <member name="T:Numerics.NET.Calculus.Generic.RightPointIntegrator`1">
      <summary>
            Represents a numerical integrator that uses the right-point rule.
            </summary>
      <remarks>
        <para>The right point rule is one of the simplest numerical
            integration algorithms around. The interval is divided into smaller
            intervals, and the function value in the middle of each subinterval is
            taken as an approximation for the function over the entire subinterval.</para>
        <para>This algorithm is of order 1. In each
            iteration, the number of points is doubled. The difference between
            successive approximations is taken as the estimate for the integration
            error.</para>
        <para>Because the order of the algorithm is so low, use of this
            algorithm is not generally recommended for general use. It does provide a unique
            feature in that can produce absolute bounds on the value of the integral
            of some functions. It produces an upper bound for monotonically increasing
            integrands, and a lower bound for monotonically decreasing integrands.
            Complementary bounds are produced by the <see cref="T:Numerics.NET.Calculus.Generic.LeftPointIntegrator`1" />.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.RightPointIntegrator`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.RightPointIntegrator`1" /> object.
            </summary>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.RightPointIntegrator`1.Order">
      <summary>
            Gets the order of the numerical integrator.
            </summary>
      <value>Always returns 1.</value>
      <remarks>
        <para>The right-point rule is of order one. This means
            that a linear function is integrated exactly.
            </para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.Calculus.Generic.RombergIntegrator`1">
      <summary>
            Represents a numerical integrator that uses Romberg's method.
            </summary>
      <remarks>
        <para>Romberg integration is an enhancement of the basic
            trapezoid rule. The number of points is doubled in each iteration.
            The successive approximations are then used to extrapolate
            the exact value of the integral as the width of each
            subinterval approaches zero. Romberg integration has an
            effective order of 2<i>k</i> after <i>k</i> steps of the
            algorithm. Even though the number of function evaluations
            is still fairly high, it is a major improvement over
            Simpson's rule, and a reasonable choice for integrands
            that are sufficiently smooth.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.RombergIntegrator`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.RombergIntegrator`1" /> object.
            </summary>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.RombergIntegrator`1.Clone">
      <summary>
            Returns a copy of this numerical integrator object.
            </summary>
      <returns>A copy of this instance.</returns>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.RombergIntegrator`1.Order">
      <summary>
            Gets the order of the numerical integrator.
            </summary>
      <value>An integer greater than 0.</value>
      <remarks>
        <para>The extrapolation scheme used in
            Romberg integration results in an effective order
            of twice the number of iterations.</para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.Calculus.Generic.SimpsonIntegrator`1">
      <summary>
            Represents a numerical integrator that uses Simpson's rule.
            </summary>
      <remarks>
        <para>The classic Simpson's rule is one of the simplest numerical
            integration algorithms around. This algorithm is of order 3. In each
            iteration, the number of points is doubled. The difference between
            successive approximations is taken as the estimate for the integration
            error.</para>
        <para>Because the order of the algorithm is so low, use of this
            algorithm is not recommended. It is here more for historical reasons
            than for its practical applications.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.SimpsonIntegrator`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.SimpsonIntegrator`1" /> object.
            </summary>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.SimpsonIntegrator`1.Order">
      <summary>
            Gets the order of the numerical integrator.
            </summary>
      <value>Always returns 3.</value>
      <remarks>
        <para>Simpson's rule is of order three. This means
            that a cubic polynomial is integrated exactly.
            </para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.Calculus.Generic.TrapezoidIntegrator`1">
      <summary>
            Represents a numerical integrator that uses the trapezoid rule.
            </summary>
      <remarks>
        <para>The classic trapezoid rule is one of the simplest numerical
            integration algorithms around. The interval is divided into smaller
            subintervals. On each subinterval, the function is approximated by
            a straight line.</para>
        <para>This algorithm is of order 1. In each
            iteration, the number of points is doubled. The difference between
            successive approximations is taken as the estimate for the integration
            error.</para>
        <para>Because the order of the algorithm is so low, use of this
            algorithm is not generally recommended for general use. It does provide a unique
            feature in that can produce absolute bounds on the value of the integral
            of some functions. It produces a lower bound for concave integrands, and an
            upper bound for convex integrands. Complementary bounds are produced by
            the <see cref="T:Numerics.NET.Calculus.Generic.MidpointIntegrator`1" />.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Calculus.Generic.TrapezoidIntegrator`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Calculus.Generic.TrapezoidIntegrator`1" /> object.
            </summary>
    </member>
    <member name="P:Numerics.NET.Calculus.Generic.TrapezoidIntegrator`1.Order">
      <summary>
            Gets the order of the numerical integrator.
            </summary>
      <value>Always returns 1.</value>
      <remarks>
        <para>Trapezoid's rule is of order one. This means
            that a linear function is integrated exactly.
            </para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.ChebyshevBasis`1">
      <summary>
            Represents a <see cref="T:Numerics.NET.Curves.FunctionBasis" /> made up of
            Chebyshev polynomials over a specified interval
            up to a specified degree.
            </summary>
      <remarks>
        <para>Use a <see cref="T:Numerics.NET.Curves.ChebyshevBasis" /> object to represent
            a basis for the polynomials in terms of Chebyshev polynomials
            over a specified interval.
            A number of mathematical properties of Chebyshev polynomials -
            in particular their mutual orthogonality over the interval [-T.One, T.One] - make
            this basis particularly useful for numerical applications.</para>
        <para>Chebyshev polynomials have these special properties only over
            the interval [-T.One,T.One]. However, rescaling is applied transparently
            to allow a <see cref="T:Numerics.NET.Curves.ChebyshevBasis" /> to be defined over any
            finite interval.</para>
        <para>Only in rare cases will it be necessary
            to construct a <see cref="T:Numerics.NET.Curves.ChebyshevBasis" />, as most functionality
            is available through the <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> class.
            The most useful members are the <see cref="M:Numerics.NET.Curves.Generic.ChebyshevBasis`1.FillValues(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})" /> and
            <see cref="M:Numerics.NET.Curves.Generic.ChebyshevBasis`1.FillDerivatives(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})" /> methods, which allow for efficient
            calculation of multiple values or derivatives of the polynomials.</para>
        <para>
          <b>Note:</b> The first function (the constant term) is equal to 0.5 instead of the
            value of T.One of the Chebyshev polynomial of degree 0. The reason is that Chebyshev series
            are commonly expressed with the constant term multiplied by 0.5. The <see cref="T:Numerics.NET.Curves.ChebyshevSeries" />
            class follows this convention.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevBasis`1.#ctor(System.Int32)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.ChebyshevBasis" /> of Chebyshev
            polynomials up to a specified degree over the interval [-T.One, T.One].
            </summary>
      <param name="degree">The degree of the highest order
            Chebyshev polynomial in the function basis.</param>
      <remarks>
        <para>The interval [-T.One, T.One] is the interval over which the
            standard Chebyshev polynomials have their orthogonality
            properties.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevBasis`1.#ctor(`0,`0,System.Int32)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.ChebyshevBasis" />
            over a specified interval from an array of function of one variable
            delegates.
            </summary>
      <param name="degree">The degree of the highest order
            power in the function basis.</param>
      <param name="lowerBound">The lower bound of the interval.</param>
      <param name="upperBound">The upper bound of the interval.</param>
      <remarks>
        <para>Standard Chebyshev polynomials are defined
            over the interval [-T.One, T.One]. Scaled Chebyshev polynomials
            can be defined over an arbitrary interval.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevBasis`1.FillDerivatives(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})">
      <summary>
            Fills a vector with the derivatives of the
            member functions at a specified value.
            </summary>
      <param name="x">The value at which to evaluate the
            derivatives.</param>
      <param name="derivatives">A vector with
            length equal to the number of functions in this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</param>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            length of <paramref name="derivatives" /> is not equal to
            the number of member functions in this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="derivatives" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevBasis`1.FillValues(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})">
      <summary>
            Fills a dense vector with the values of the
            member functions at a specified value.
            </summary>
      <param name="x">The value at which to evaluate the
            member functions.</param>
      <param name="values">A dense vector with
            length equal to the number of functions in this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</param>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            length of <paramref name="values" /> is not equal to
            the number of member functions in this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="values" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevBasis`1.GetFunction(Numerics.NET.Vector{`0})">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> with the
            specified coefficients.
            </summary>
      <param name="coefficients">A vector
            containing the coefficients of the Chebyshev polynomials
            in the series. The first element in the array
            corresponds to the constant term.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> cast as a
            <see cref="T:Numerics.NET.Curves.LinearCombination" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="coefficients" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.ChebyshevBasis`1.Item(System.Int32)">
      <summary>
            Gets an element of the collection as a
            function of one variable.
            </summary>
      <param name="index">The index of the function.</param>
      <value>A delegate that represents a function of one variable.</value>
      <remarks>
        <para>The function of one variable that is returned
            represents the Chebyshev polynomial of degree <paramref name="index" />
            over the interval specified in the <see cref="!:ChebyshevBasis(T, T, int)" />.
            </para>
        <para>
          <b>Note:</b> The first function (the constant term) is equal to 0.5 instead of the
            value of T.One of the Chebyshev polynomial of degree 0. The reason is that Chebyshev series
            are commonly expressed with the constant term multiplied by 0.5. The <see cref="T:Numerics.NET.Curves.ChebyshevSeries" />
            class follows this convention.</para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero or greater
            than or equal to the number of functions in this
            <see cref="T:Numerics.NET.Curves.ChebyshevBasis" />.</exception>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.ChebyshevBasis`1.LowerBound">
      <summary>
            Gets or sets the lower bound of the interval over which this <see cref="T:Numerics.NET.Curves.ChebyshevBasis" /> is defined.
            </summary>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.ChebyshevBasis`1.UpperBound">
      <summary>
            Gets or sets the upper bound of the interval over which this <see cref="T:Numerics.NET.Curves.ChebyshevBasis" /> is defined.
            </summary>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.ChebyshevSeries`1">
      <summary>
            Represents a Chebyshev polynomial series.
            </summary>
      <remarks>
        <para>
            Chebyshev series is a linear combination of Chebyshev polynomials.
            The Chebyshev polynomials are never formed explicitly. All
            calculations can be performed using only the coefficients.</para>
        <para>The Chebyshev polynomials provide an alternate basis for
            representating general polynomials. Two characteristics make Chebyshev
            polynomials especially attractive. They are mutually orthogonal,
            and there exists a simple recurrence relation between consecutive
            polynomials.</para>
        <para>Chebyshev polynomials are defined over the interval [-1, 1].
            Using Chebyshev expansions outside of this interval is usually not
            meaningful and is to be avoided. To allow expansions over any finite
            interval, transformations are applied wherever necessary.</para>
        <para>The <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> class inherits from
            <see cref="T:Numerics.NET.Curves.PolynomialBase" /> This class defines a number of properties
            shared by all polynomial classes. PolynomialBase is itself derived from
            <see cref="T:Numerics.NET.Curves.LinearCombination" />.</para>
        <para>The <see cref="P:Numerics.NET.Curves.Curve.Parameters">parameters</see> of a Chebyshev
            series are the coefficients of the polynomial.</para>
        <para>The <see cref="P:Numerics.NET.Curves.PolynomialBase.Degree" /> of a Chebyshev series is the highest
            degree of a Chebyshev polynomial that appears in the sum. The number
            of parameters of the series equals the degree plus one.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.#ctor(Numerics.NET.Vector{`0})">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> with the
            specified coefficients over the interval [-1, 1].
            </summary>
      <param name="coefficients">An array of coefficients. The
            index into the array corresponds to the degree of the
            coefficient.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.#ctor(Numerics.NET.Vector{`0},`0,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> with the
            specified coefficients over the specified interval.
            </summary>
      <param name="lowerBound">The lower bound of the interval.</param>
      <param name="upperBound">The upper bound of the interval.</param>
      <param name="coefficients">An array of coefficients. The
            index into the array corresponds to the degree of the
            coefficient.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.#ctor(System.Int32)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> of the specified
            degree over the interval [-1, 1].
            </summary>
      <param name="degree">The degree of the highest order Chebyshev polynomial
            in the series.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.#ctor(System.Int32,`0,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> of the specified
            degree over the specified interval.
            </summary>
      <param name="lowerBound">The lower bound of the interval.</param>
      <param name="upperBound">The upper bound of the interval.</param>
      <param name="degree">The degree of the highest order Chebyshev polynomial
            in the series.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.Add(`0,Numerics.NET.Curves.Generic.LinearCombination{`0})">
      <summary>
            Adds two Chebyshev series.
            </summary>
      <param name="factor">Multiplier for <paramref name="combination" />.</param>
      <param name="combination">The first <see cref="T:Numerics.NET.Curves.ChebyshevSeries" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> that is the sum of the
            two operands.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="combination" /> is <see langword="null" />.
            </exception>
      <exception cref="T:System.InvalidCastException">
        <paramref name="combination" /> is not a Chebyshev series.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="combination" /> is not an instance of <see cref="T:Numerics.NET.Curves.ChebyshevSeries" />.
            <para>-or-</para><para>The Chebyshev series represented by this instance and <paramref name="combination" />
            are defined over different intervals.</para><para>-or-</para><para>The <see cref="P:Numerics.NET.Curves.PolynomialBase.Degree" /> of <paramref name="combination" /> is greater than
            the maximum degree of this instance.</para></exception>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.ChebyshevSeries`1.Basis">
      <summary>
            Gets the function basis for the polynomial.
            </summary>
      <value>A <see cref="T:Numerics.NET.Curves.ChebyshevBasis" /> object as a <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</value>
      <remarks>
        <para>For polynomials, the basis is a <see cref="T:Numerics.NET.Curves.ChebyshevBasis" />.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.GetDerivative">
      <summary>
            Returns a <see cref="T:Numerics.NET.Curves.Curve" /> that represents the derivative
            of this <see cref="T:Numerics.NET.Curves.ChebyshevSeries" />.
            </summary>
      <returns>A <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> that represents the
            derivative of this curve.</returns>
      <remarks>
        <para>The derivative of a Chebyshev series is evaluated
            directly in terms of the coefficients of the series and
            is returned
            as a new Chebyshev series of degree one less than the original.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.GetInterpolatingPolynomial(System.Func{`0,`0},`0,`0,System.Int32)">
      <summary>
            Calculates the Chebyshev interpolating polynomial of the specified degree
            over the given interval for the specified function.
            </summary>
      <param name="function">A delegate that represents a function of one variable that specifies the
            function to interpolate.</param>
      <param name="lowerBound">The lower bound of the interval.</param>
      <param name="upperBound">The upper bound of the interval.</param>
      <param name="degree">The desired degree of the interpolating polynomial.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> object.</returns>
      <remarks>
        <para>The interpolating polynomial through the Chebyshev</para>
      </remarks>
      <exception cref="T:System.ArgumentException">The
            interval has zero length.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="function" /> is <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="degree" /> is less than zero.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.Integral(`0,`0)">
      <summary>
            Gets the definite integral of the <see cref="T:Numerics.NET.Curves.ChebyshevSeries" />
             between the specified X-coordinates.
            </summary>
      <param name="lowerBound">The lower bound of the integration interval.</param>
      <param name="upperBound">The upper bound of the integration interval.</param>
      <returns>The definite integral of the curve between
            <paramref name="lowerBound" /> and <paramref name="upperBound" />.
            </returns>
      <remarks>
        <para>The integral of a Chebyshev series is evaluated
            directly in terms of the coefficients. No approximation is used.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.LeastSquaresFit(Numerics.NET.Vector{`0},Numerics.NET.Vector{`0},System.Int32)">
      <summary>
            Returns the <see cref="T:Numerics.NET.Curves.Polynomial" /> that is the best
            least squares fit through the given set of points.
            </summary>
      <param name="xValues">A vector containing the
            X-coordinates of the points.</param>
      <param name="yValues">A vector containing the
            Y-coordinates of the points.</param>
      <param name="degree">The degree of the least squares
            polynomial. Must be smaller than the number of
            data points.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.ChebyshevSeries" />  that is the least
            squares fit through the given set of points.</returns>
      <remarks>
        <para>The least squares fit of a polynomial through
            a set of points is the polynomial that minimizes the
            sum of the squares of the residuals. The residuals are
            the differences between the predicted and the actual
            values.
            </para>
        <para>The coordinates of the points are provided in
            two <typeparamref name="T" /> arrays. These must have the
            same number of elements, or an exception is thrown.</para>
        <para>In rare cases, the least squares polynomial is
            a vertical line. In this case, a
            <see cref="T:System.DivideByZeroException" /> exception is thrown.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><paramref name="yValues" /> is <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="degree" /> is less than zero or greater than or equal to the number of data points.
            </exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">
            The arrays <paramref name="xValues" /> and <paramref name="yValues" />
            have different lengths.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.LeastSquaresFit(Numerics.NET.Vector{`0},Numerics.NET.Vector{`0},`0,`0,System.Int32)">
      <summary>
            Returns the <see cref="T:Numerics.NET.Curves.Polynomial" /> that is the best
            least squares fit through the given set of points.
            </summary>
      <param name="xValues">A vector containing the
            X-coordinates of the points.</param>
      <param name="yValues">A vector containing the
            Y-coordinates of the points.</param>
      <param name="degree">The degree of the least squares
            polynomial. Must be smaller than the number of
            data points.</param>
      <param name="lowerBound">The lower bound of the interval.</param>
      <param name="upperBound">The upper bound of the interval.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.ChebyshevSeries" />  that is the least
            squares fit through the given set of points.</returns>
      <remarks>
        <para>The least squares fit of a polynomial through
            a set of points is the polynomial that minimizes the
            sum of the squares of the residuals. The residuals are
            the differences between the predicted and the actual
            values.
            </para>
        <para>The coordinates of the points are provided in
            two <typeparamref name="T" /> arrays. These must have the
            same number of elements, or an exception is thrown.</para>
        <para>In rare cases, the least squares polynomial is
            a vertical line. In this case, a
            <see cref="T:System.DivideByZeroException" /> exception is thrown.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><paramref name="yValues" /> is <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="degree" /> is less than zero or greater than or equal to the number of data points.
            </exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">
            The arrays <paramref name="xValues" /> and <paramref name="yValues" />
            have different lengths.
            </exception>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.ChebyshevSeries`1.LowerBound">
      <summary>
            Gets or sets the lower bound of the interval over which this <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> is defined.
            </summary>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.SlopeAt(`0)">
      <summary>
            Evaluates the slope or first derivative of a Chebyshev
            series for a complex number argument.
            </summary>
      <param name="x">A complex number number.</param>
      <returns>The slope of the Chebyshev series for the
            specified argument.</returns>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.ChebyshevSeries`1.UpperBound">
      <summary>
            Gets or sets the upper bound of the interval over which this <see cref="T:Numerics.NET.Curves.ChebyshevSeries" /> is defined.
            </summary>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.ChebyshevSeries`1.ValueAt(`0)">
      <summary>
            Evaluates the Chebyshev series for a real argument.
            </summary>
      <param name="x">A real number.</param>
      <returns>The value of the Chebyshev series for the
            specified argument.</returns>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.Curve`1">
      <summary>
            Represents a curve in two-dimensional space.
            </summary>
      <remarks>
        <para>The <see cref="T:Numerics.NET.Curves.Curve" /> class is the <see langword="abstract" />
            base class for classes that represent curves in two-dimensional space.
            It defines common properties and methods for all such classes. Derived classes provide
            implementations for specific types of curves.</para>
        <para>The name 'Curve' was chosen as an alternative to 'Function', which is a reserved
            word in many languages.</para>
        <para>The <see cref="M:Numerics.NET.Curves.Generic.Curve`1.ValueAt(`0)" /> method evaluates the
            curve at a specific point. <see cref="M:Numerics.NET.Curves.Generic.Curve`1.SlopeAt(`0)" />
            evaluates the derivative, and <see cref="M:Numerics.NET.Curves.Generic.Curve`1.Integral(`0,`0)" />
            evaluates the definite integral over a specified
            interval. If overridden by a descendant class, the
            <see cref="M:Numerics.NET.Curves.Generic.Curve`1.GetDerivative" /> method returns the
            <see cref="T:Numerics.NET.Curves.Curve" /> that is the derivative of
            the instance. The <see cref="M:Numerics.NET.Curves.Generic.Curve`1.FindRoots" /> method
            attempts to find all the roots or zeros of the
            curve.</para>
        <para>A particular type of curve is defined by a
            set of parameters. These parameters can be set and
            retrieved through the <see cref="P:Numerics.NET.Curves.Generic.Curve`1.Parameters" /> property
            which is a vector. The
            number of such parameters is given by the
            <see cref="P:Numerics.NET.Vector`1.Length" /> property
            of  the <see cref="P:Numerics.NET.Curves.Generic.Curve`1.Parameters" /> property.</para>
        <para>
          <see cref="T:Numerics.NET.Curves.Curve" /> is an abstract base class
            and cannot be instantiated directly. The following
            derived classes have been defined:
            <list type="table"><listheader><term>Class</term><description>Description</description></listheader><item><term><see cref="T:Numerics.NET.Curves.GeneralCurve" /></term><description>A curve whose value and optionally
            its derivative is calculated using a
            function of one variable delegate.</description></item><item><term><see cref="T:Numerics.NET.Curves.LinearCombination" /></term><description>A linear combination of an arbitrary set
            of curves.</description></item><item><term><see cref="T:Numerics.NET.Curves.PolynomialBase" /></term><description>Abstract base class for classes that implement
            different types of polynomials. Derives from
            <see cref="T:Numerics.NET.Curves.LinearCombination" />.</description></item><item><term><see cref="T:Numerics.NET.Curves.Polynomial" /></term><description>A polynomial. Derives from <see cref="T:Numerics.NET.Curves.PolynomialBase" />.</description></item><item><term><see cref="T:Numerics.NET.Curves.ChebyshevSeries" /></term><description>A linear combination of Chebyshev
            polynomials. Derives from <see cref="T:Numerics.NET.Curves.PolynomialBase" />.</description></item><item><term><see cref="T:Numerics.NET.Curves.CubicSpline" /></term><description>A natural or clamped cubic spline. Derives from <see cref="T:Numerics.NET.Curves.PiecewiseCurve" />.</description></item><item><term><see cref="T:Numerics.NET.Curves.NonlinearCurve" /></term><description>A curve that is non-linear in its parameters and is suitable for non-linear curve fitting.</description></item><item>Exponential</item></list></para>
        <para>
          <strong>Notes to inheritors:</strong> When you derive
            from <see cref="T:Numerics.NET.Curves.Curve" />, you must override the following
            member: <see cref="M:Numerics.NET.Curves.Generic.Curve`1.ValueAt(`0)" />. You should also override
            the following members: <see cref="M:Numerics.NET.Curves.Generic.Curve`1.SlopeAt(`0)" />,
            <see cref="M:Numerics.NET.Curves.Generic.Curve`1.Integral(`0,`0)" />, <see cref="M:Numerics.NET.Curves.Generic.Curve`1.FindRoots" />, and <see cref="M:Numerics.NET.Curves.Generic.Curve`1.GetDerivative" />.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.#ctor(System.Int32)">
      <summary>
            Constructs a new curve with the specified number of
            parameters.
            </summary>
      <param name="parameterCount">The number of parameters.</param>
      <remarks>
        <para>The meaning of the parameters is determined
            by the inheriting class.</para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterCount" /> is less than zero.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.Clone">
      <summary>
            Constructs an exact copy of this instance.
            </summary>
      <returns>An <see cref="T:System.Object" /> that is an exact copy of this instance.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.FindRoots">
      <summary>
            Gets the set of X-coordinates where the curve crosses
            the X-axis.
            </summary>
      <returns>An array of X-coordinates where the curve
            crosses the X-axis.</returns>
      <remarks>
        <para>When implemented by a derived class, this method returns
            at least one of the zeros of the curve, if it has one. By default,
            this method returns an empty array, indicating that no zeros were
            found.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.GetCurveFitter">
      <summary>
            Returns a <see cref="T:Numerics.NET.Curves.CurveFitter" /> object that can be used to fit the curve to data.
            </summary>
      <returns>A <see cref="T:Numerics.NET.Curves.CurveFitter" /> object suitable for fitting the curve to data.</returns>
      <remarks>
        <para>
            The <see cref="T:Numerics.NET.Curves.CurveFitter" /> object returned by this method can be used to adjust the parameters
            of the instance to best fit the data supplied to the curve fitter object.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.GetDerivative">
      <summary>
            Returns a <see cref="T:Numerics.NET.Curves.Curve" /> that represents the derivative
            of this <see cref="T:Numerics.NET.Curves.Curve" />.
            </summary>
      <returns>A <see cref="T:Numerics.NET.Curves.Curve" /> that represents the
            derivative of this curve.</returns>
      <remarks>
        <para>The value of the derivative of a curve at a
            point is the slope of the curve at that point.
            </para>
        <para>By default, this method returns a <see cref="T:Numerics.NET.Curves.GeneralCurve" />
            created from an automatic numerical differentiator delegate
            producted by the <see cref="M:Numerics.NET.FunctionMath.GetNumericalDifferentiator(System.Func{System.Double,System.Double})" /> method of the
            <see cref="T:Numerics.NET.FunctionMath" /> class.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.Integral(`0,`0)">
      <summary>
            Gets the definite integral of the curve between the
            specified X-coordinates.
            </summary>
      <param name="lowerBound">The lower bound of the integration interval.</param>
      <param name="upperBound">The upper bound of the integration interval.</param>
      <returns>The definite integral of the curve between
            <paramref name="lowerBound" /> and <paramref name="upperBound" />.
            </returns>
      <remarks>
        <para>By default, the integral is approximated numerically
            by using an instance of the
            <see cref="T:Numerics.NET.Calculus.AdaptiveIntegrator" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.OnParameterChanged(System.Int32,`0)">
      <summary>
            Called after a <see cref="T:Numerics.NET.Curves.Curve" /> parameter has been changed.
            </summary>
      <param name="index">The index of the parameter.</param>
      <param name="value">The new value of the parameter.</param>
      <remarks>
        <para>Inheritors can override this method to perform certain calculations
            using the new value of the parameter.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.OnParameterChanging(System.Int32,`0)">
      <summary>
            Called before the value of a curve parameter is changed.
            </summary>
      <param name="index">The index of the parameter.</param>
      <param name="value">The new value of the parameter.</param>
      <remarks>
        <para>Inheritors can override this method to validate the value of the new
            parameter.</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.Curve`1.Parameters">
      <summary>
            Gets the collection of parameters that determine the shape of this
            <see cref="T:Numerics.NET.Curves.Curve" />.
            </summary>
      <remarks>
        <para>This property allows direct access to the values of the parameters.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.SetParameter(System.Int32,`0)">
      <summary>
            Sets a curve parameter to the specified value.
            </summary>
      <param name="index">The index of the parameter.</param>
      <param name="value">The new value of the parameter.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.SlopeAt(`0)">
      <summary>
            Gets the slope of the curve at the specified
            X-coordinate.
            </summary>
      <param name="x">A real number.</param>
      <returns>The slope of the curve at the specified
            X-coordinate.</returns>
      <remarks>
        <para>This method evaluates the derivative of the curve
            at the point <paramref name="x" />. By default, the derivative
            is approximated numerically using central differences.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.Solve(`0,`0)">
      <summary>
            Finds the x value where the curve reaches the specified y value.
            </summary>
      <param name="y">The y-value.</param>
      <param name="x0">An initial estimate of the x value.</param>
      <returns>
            The value of x where the curve has the value <paramref name="y" />.
            </returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.TangentAt(`0)">
      <summary>
            Gets the tangent line to the curve at the
            specified X-coordinate.
            </summary>
      <param name="x">A real number.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Polynomial" /> that is the tangent
            of the curve at the specified X-coordinate.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Curve`1.ValueAt(`0)">
      <summary>
            Gets the Y-value of the curve at the specified
            X-coordinate.
            </summary>
      <param name="x">A real number.</param>
      <returns>The Y-value of the curve at the specified
            X-coordinate.</returns>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.CurveFitter`1">
      <summary>
            Serves as the base class for classes that implement curve fitting algorithms.
            </summary>
      <remarks>
        <para>
            Use the <see cref="T:Numerics.NET.Curves.CurveFitter" /> class to refer to classes
            that implement curve fitting algorithms. This is an abstract class
            and cannot be instantiated. Instead, use one of the derived classes:
            <see cref="T:Numerics.NET.Curves.LinearCurveFitter" /> and <see cref="T:Numerics.NET.Curves.NonlinearCurveFitter" />.
            </para>
        <para>
            
            The curve is specified by the <see cref="P:Numerics.NET.Curves.CurveFitter.Curve" /> property.
            The data is supplied as <see cref="T:Numerics.NET.Vector" /> objects
            through the <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.XValues" /> and <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.YValues" /> properties.</para>
        <para>The <see cref="M:Numerics.NET.Curves.Generic.CurveFitter`1.Fit" /> method performs the actual curve fit.
            This method returns the <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.Curve" /> that best fits the supplied data.</para>
        <para>By default, the observations are unweighted. You can supply a
            weighting method in two ways. You can set the <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.WeightFunction" />
            property to a function of two variables delegate that computes the weight
            for each observation. The <see cref="T:Numerics.NET.Curves.WeightFunctions" /> class provides predefined
            delegates for the most common weight functions.
            Alternatively, you can set the individual weights by setting the <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.WeightVector" />
            property to a <see cref="T:Numerics.NET.Vector" /> that contains the weight for each individual observation.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.CurveFitter" /> object.
            </summary>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.CurveFitter`1.BestFitParameters">
      <summary>
            Gets the curve parameters corresponding to the best fit.
            </summary>
      <value>A dense vector containing the parameters of the curve.</value>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.ComputeFit(Numerics.NET.LinearAlgebra.DenseVector{`0}@,Numerics.NET.LinearAlgebra.SymmetricMatrix{`0}@,`0@)">
      <summary>
            Computes the solution.
            </summary>
      <param name="solution">On return, a <see cref="T:Numerics.NET.Vector" /> that contains the computed solution.</param>
      <param name="varianceCovarianceMatrix">On return, <see cref="T:Numerics.NET.LinearAlgebra.SymmetricMatrix`1" /> that contains
            the variance-covariance matrix of the curve parameters.</param>
      <param name="standardError">On return, contains the standard error of the curve fit.</param>
      <returns>The <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.Curve" /> object that was fit.</returns>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.CurveFitter`1.Curve">
      <summary>
            Gets or sets the curve that is being fitted.
            </summary>
      <value>A <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.Curve" /> object.</value>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.Fit">
      <summary>
            Calculates the least-squares fit.
            </summary>
      <returns>A reference to the <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.Curve" /> that best fits the data.</returns>
      <exception cref="T:System.InvalidOperationException">
            The <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.XValues" /> have not been set.
            <para>-or-</para><para>The <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.YValues" /> have not been set.</para><para>-or-</para><para>The <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.Curve" /> has not been set.</para></exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">
            The length of <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.XValues" /> does not equal the lenght of <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.YValues" />.
            </exception>
      <exception cref="T:Numerics.NET.InsufficientDataException">
            The number of data points is less than the number of curve parameters.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.GetConfidenceBandwidth(`0)">
      <summary>
            Gets the width of the confidence band around the best-fit curve at the specified point at the 95% confidence level.
            </summary>
      <param name="x">The point at which to evaluate the bandwidth.</param>
      <returns>The distance from the predicted value to the upper or lower confidence band.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.GetConfidenceBandwidth(`0,System.Double)">
      <summary>
            Gets the width of the confidence band around the best-fit curve at the specified point.
            </summary>
      <param name="x">The point at which to evaluate the bandwidth.</param>
      <param name="confidenceLevel">The confidence level of the confidence band.</param>
      <returns>The distance from the predicted value to the upper or lower confidence band.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.GetPredictionBandwidth(`0)">
      <summary>
            Gets the width of the prediction band around the best-fit curve at the specified point at the 95% confidence level.
            </summary>
      <param name="x">The point at which to evaluate the bandwidth.</param>
      <returns>The distance from the predicted value to the upper or lower prediction band.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.GetPredictionBandwidth(`0,System.Double)">
      <summary>
            Gets the width of the prediction band around the best-fit curve at the specified point.
            </summary>
      <param name="x">The point at which to evaluate the bandwidth.</param>
      <param name="confidenceLevel">The confidence level of the prediction band.</param>
      <returns>The distance from the predicted value to the upper or lower prediction band.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.GetStandardDeviations">
      <summary>
            Gets the standard deviations.
            </summary>
      <returns>A vector containing the standard deviations associated with the fit parameters.</returns>
      <exception cref="T:System.NotSupportedException">Always thrown.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.GetVarianceCovarianceMatrix">
      <summary>
            Returns the variance-covariance matrix of the fit.
            </summary>
      <returns>A symmetric matrix containing the variance-covariance matrix of the computed curve parameters.</returns>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.CurveFitter`1.InitialGuess">
      <summary>
            Gets or sets the initial value for the iteration.
            </summary>
      <remarks>
        <para>The length of the vector must be the same as the number of unknowns in the system
            of equations.</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.CurveFitter`1.Residuals">
      <summary>
            Gets the residuals for the observations.
            </summary>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.Scale(Numerics.NET.LinearAlgebra.DenseVector{`0})">
      <summary>
            Scales the components of a vector using the values from <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.ScaleVector" />.
            </summary>
      <param name="vector">A dense vector.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="vector" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.Scale(Numerics.NET.Vector{`0})">
      <summary>
            Scales the components of a vector using the values from <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.ScaleVector" />.
            </summary>
      <param name="vector">A vector.</param>
      <returns>A reference to the scaled vector.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="vector" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.CurveFitter`1.ScaleVector">
      <summary>
            Gets or sets the vector used to scale the curve parameters.
            </summary>
      <remarks>
        <para>
            The components of this vector should indicate the expected order of magnitude of each of the corresponding
            parameters. Dividing each parameter by the corresponding component of the scale vector should give a result close to one.
            </para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.CurveFitter`1.StandardError">
      <summary>
            Gets the standard error of the curve fit.
            </summary>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.Unscale(Numerics.NET.LinearAlgebra.DenseVector{`0})">
      <summary>
            Undoes the scaling of the components of a vector using the values from <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.ScaleVector" />.
            </summary>
      <param name="vector">A dense vector.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="vector" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.CurveFitter`1.Unscale(Numerics.NET.Vector{`0})">
      <summary>
            Undoes the scaling of the components of a vector using the values from <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.ScaleVector" />.
            </summary>
      <param name="vector">A dense vector.</param>
      <returns>A reference to the scaled vector.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="vector" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.CurveFitter`1.WeightFunction">
      <summary>
            Gets or sets the weight function.
            </summary>
      <remarks>
        <para>The weight function specifies a function that computes the weight that is to be applied
            to each observation in terms of  the x and/or y-value of that observation.
            The property is a function of two variables delegate. The first parameter corresponds to the
            x-value of the observation. The second parameter corresponds to the y-value of the observation.
            </para>
        <para>You can specify the individual weights to arbitrary values by setting the <see cref="P:Numerics.NET.Curves.Generic.CurveFitter`1.WeightVector" />
            property.</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.CurveFitter`1.WeightVector">
      <summary>
            Gets or sets the weight vector.
            </summary>
      <remarks>
        <para>If the weight vector is <see langword="null" />, all weights are assumed to be equal to 1.</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.CurveFitter`1.XValues">
      <summary>
            Gets or sets the vector of x-values.
            </summary>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.CurveFitter`1.YValues">
      <summary>
            Gets or sets the vector of y-values.
            </summary>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.FunctionBasis`1">
      <summary>
            Serves as an abstract base class for collections of
            functions.
            </summary>
      <remarks>
        <para>
            A <see cref="T:Numerics.NET.Curves.FunctionBasis" /> represents
            a collection of real functions of one real variable.
            The <see cref="T:Numerics.NET.Curves.LinearCombination" /> class implements
            a <see cref="T:Numerics.NET.Curves.Curve" /> that is a linear combination of basis
            functions in a <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</para>
        <para>A function basis is particularly useful for
            representing a class of functions where the cost of
            evaluating a series of functions is much less than that
            of evaluating the functions individually. For example,
            to evaluate all powers up to degree 10 requires up to 55
            multiplications, where only 10 multiplications are required
            if they are evaluated as a group.</para>
        <para>The <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.ValuesAt(`0)" /> and <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.FillValues(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})" />
            methods evaluate all basis functions for a given value or set of
            values. The <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.DerivativesAt(`0)" /> and <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.FillDerivatives(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})" />
            methods evaluate the derivative of all basis functions for a given
            value or set of values. Derived classes provide optimized
            implementations of these methods for specific classes of curves.</para>
        <para>The curves in a function basis can be combined into a
            <see cref="T:Numerics.NET.Curves.LinearCombination" /> curve using the <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.GetFunction(Numerics.NET.Vector{`0})" />
            method. The <see cref="o:LeastSquaresFit" /> methods calculate the
            <see cref="T:Numerics.NET.Curves.LinearCombination" /> that is the least squares fit to a
            set of data points using curves from the function basis.</para>
        <para>This is an abstract base class. The following
            classes derive from <see cref="T:Numerics.NET.Curves.FunctionBasis" />:
            <list type="table"><listheader><term>Class</term><description>Basis functions</description></listheader><item><term><see cref="T:Numerics.NET.Curves.GeneralFunctionBasis" /></term><description>Arbitrary user-defined functions.</description></item><item><term><see cref="T:Numerics.NET.Curves.PolynomialBasis" /></term><description><see cref="T:Numerics.NET.Curves.Polynomial">Polynomials</see>
            up to a specified degree.</description></item><item><term><see cref="T:Numerics.NET.Curves.ChebyshevBasis" /></term><description>Chebyshev polynomials over a specified interval
            up to a specified degree.</description></item></list></para>
        <para>
          <strong>Notes to inheritors:</strong> When you derive
            from <see cref="T:Numerics.NET.Curves.FunctionBasis" />, you must override the
            following members: <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.ValuesAt(`0)" />,
            <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.DerivativesAt(`0)" />, <see cref="P:Numerics.NET.Curves.Generic.FunctionBasis`1.Length" />, <see cref="P:Numerics.NET.Curves.Generic.FunctionBasis`1.Item(System.Int32)" />.</para>
        <para>
          <strong>Notes to inheritors:</strong>When you inherit from
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />, you must override the
            following methods and properties: <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.FillValues(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})" />.
            You should override <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.FillDerivatives(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})" /> 
            and <see cref="P:Numerics.NET.Curves.Generic.FunctionBasis`1.Item(System.Int32)" />.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.#ctor(System.Int32)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.FunctionBasis" /> with the specified number of basis
            functions.
            </summary>
      <param name="length">The number of basis functions.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.DerivativesAt(`0)">
      <summary>
            Evaluates the derivatives of the member functions of this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" /> at a specified value.
            </summary>
      <param name="x">A real number.</param>
      <returns>A vector containing the
            derivatives of the member functions.</returns>
      <remarks>
        <para>This method creates a new <see cref="T:Numerics.NET.Vector" />
            every time it is called. In some situations, it may be more
            efficient to call the <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.FillDerivatives(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})" /> method
            instead.
            </para>
        <para>If no derivative functions have been defined for the member functions,
            the derivatives are approximated numerically.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.FillDerivatives(Numerics.NET.Vector{`0},Numerics.NET.LinearAlgebra.DenseMatrix{`0})">
      <summary>
            Fills the rows of a <see cref="T:Numerics.NET.LinearAlgebra.DenseMatrix`1" /> with the values
            of the member functions of a <see cref="T:Numerics.NET.Curves.FunctionBasis" /> evaluated for each element
            in a <see cref="T:Numerics.NET.Vector" />.
            </summary>
      <param name="xValues">A vector containing the
            values at which to evaluate the member functions.</param>
      <param name="derivatives">A <see cref="T:Numerics.NET.LinearAlgebra.DenseMatrix`1" /> with
            number of columns greater than or equal to the number
            of functions in this <see cref="T:Numerics.NET.Curves.FunctionBasis" />, and
            number of rows greater than or
            equal to the number of elements in <paramref name="xValues" />.
            </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="derivatives" /> is <see langword="null" />.</para></exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            number of columns of <paramref name="derivatives" /> is not
            equal to the number of member functions in this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" /><br />-or-<br /> the
            number of rows of <paramref name="derivatives" /> does not
            equal the number of elements in <paramref name="xValues" />.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.FillDerivatives(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})">
      <summary>
            Fills a vector with the derivatives of the
            member functions at a specified value.
            </summary>
      <param name="x">The value at which to evaluate the
            derivatives.</param>
      <param name="derivatives">A vector with
            length greater than or equal to the number of functions
            in this <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</param>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            length of <paramref name="derivatives" /> is not equal to
            the number of member functions in this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</exception>
      <exception cref="T:System.InvalidOperationException">No derivatives
            are available for this <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.FillValues(Numerics.NET.Vector{`0},Numerics.NET.LinearAlgebra.DenseMatrix{`0})">
      <summary>
            Fills the rows of a <see cref="T:Numerics.NET.LinearAlgebra.DenseMatrix`1" /> with the values
            of the member functions of a <see cref="T:Numerics.NET.Curves.FunctionBasis" /> evaluated for each element
            in a <see cref="T:Numerics.NET.Vector" />.
            </summary>
      <param name="xValues">A vector containing the
            values at which to evaluate the member functions.</param>
      <param name="values">A <see cref="T:Numerics.NET.LinearAlgebra.DenseMatrix`1" /> with
            number of columns greater than or equal to the number
            of functions in this <see cref="T:Numerics.NET.Curves.FunctionBasis" />, and
            number of rows greater than or
            equal to the number of elements in <paramref name="xValues" />.
            </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="values" /> is <see langword="null" />.</para></exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            number of columns of <paramref name="values" /> is not
            equal to the number of member functions in this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" /><br />-or-<br /> the
            number of rows of <paramref name="values" /> does not
            equal the number of elements in <paramref name="values" />.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.FillValues(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})">
      <summary>
            Fills a dense vector with the values of the
            member functions of a <see cref="T:Numerics.NET.Curves.FunctionBasis" /> at a specified value.
            </summary>
      <param name="x">The value at which to evaluate the
            member functions.</param>
      <param name="values">A dense vector with
            length equal to the number of functions in this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="values" /> is <see langword="null" />.
            </exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            length of <paramref name="values" /> is less than
            the number of member functions in this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.GetFunction(Numerics.NET.Vector{`0})">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> from
            the functions in this instance.
            </summary>
      <param name="coefficients">A vector
            containing the coefficients in the
            linear combination of the functions in this instance.</param>
      <returns>The <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> of the basis functions with coefficnets
            <paramref name="coefficients" />.</returns>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.FunctionBasis`1.Item(System.Int32)">
      <summary>
            Gets an element of the collection as a
            function of one variable.
            </summary>
      <param name="index">The index of the function.</param>
      <value>A delegate that represents a function of one variable.</value>
      <remarks>
        <para>If at all possible, the <paramref name="index" />
            parameter should correspond to the natural indexer for a
            class of functions. For example, in the
            <see cref="T:Numerics.NET.Curves.PolynomialBasis" /> class, the <paramref name="index" />
            parameter corresponds to the degree of the polynomial.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero or greater
            than or equal to the number of functions in this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.LeastSquaresFit(Numerics.NET.Vector{`0},Numerics.NET.Vector{`0})">
      <summary>
            Gets the least squares fit of target data in terms of
            the components of the <see cref="T:Numerics.NET.Curves.FunctionBasis" />.
            </summary>
      <param name="xValues">A vector containing
            the data points for the fit.</param>
      <param name="yValues">A vector containing
            the data values corresponding to the data points
            in <paramref name="xValues" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.LinearCombination" /> that is the
            least squares fit of the data in terms of this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="yValues" /> is <see langword="null" />.</para></exception>
      <exception cref="!:Mathematics.TotalLossOfPrecisionException">
            The solution of the least squares problem could not be
            found because roundoff error caused a total loss of
            precision.</exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            <paramref name="xValues" /> and <paramref name="yValues" />
            do not have the same length.</exception>
      <exception cref="T:System.ArgumentException">
            The number of data points is less than the number of basis functions.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.LeastSquaresFit(Numerics.NET.Vector{`0},Numerics.NET.Vector{`0},Numerics.NET.Vector{`0})">
      <summary>
            Gets the least squares fit of target data in terms of
            the components of the <see cref="T:Numerics.NET.Curves.FunctionBasis" />.
            </summary>
      <param name="xValues">A vector containing
            the data points for the fit.</param>
      <param name="yValues">A vector containing
            the data values corresponding to the data points
            in <paramref name="xValues" />.</param>
      <param name="weights">A vector containing
            the weights to assign to the residual error corresponding
            to the data values in <paramref name="yValues" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.LinearCombination" /> that is the
            least squares fit of the data in terms of this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="yValues" /> is <see langword="null" />.</para></exception>
      <exception cref="!:Mathematics.TotalLossOfPrecisionException">
            The solution of the least squares problem could not be
            found because roundoff error caused a total loss of
            precision.</exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            <paramref name="xValues" /> and <paramref name="yValues" />
            do not have the same length.</exception>
      <exception cref="T:System.ArgumentException">
            The number of data points is less than the number of basis functions.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.LeastSquaresFit(`0[],`0[],System.Int32)">
      <summary>
            Gets the least squares fit of target data in terms of
            the components of the <see cref="T:Numerics.NET.Curves.FunctionBasis" />.
            </summary>
      <param name="xValues">An array containing the data points for the fit.</param>
      <param name="yValues">A array containing the data values corresponding to
            the data points in <paramref name="xValues" />.</param>
      <param name="numberOfDataPoints">The number of actual data points.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.LinearCombination" /> that is the
            least squares fit of the data in terms of this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</returns>
      <remarks>
        <para>Use this method to calculate a <see cref="T:Numerics.NET.Curves.LinearCombination" /> of the basis functions in this
            instance through a set of points using the least squares method.
            </para>
        <para>Only the first <paramref name="numberOfDataPoints" /> values in <paramref name="xValues" /> and
            <paramref name="yValues" /> are used.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="yValues" /> is <see langword="null" />.</para></exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="numberOfDataPoints" /> is less than the number of basis functions.
            <para>-or-</para><para><paramref name="numberOfDataPoints" /> is greater than the length of <paramref name="xValues" /></para><para>-or-</para><para><paramref name="numberOfDataPoints" /> is greater than the length of <paramref name="yValues" /></para></exception>
      <exception cref="T:Numerics.NET.TotalLossOfPrecisionException">
            The solution of the least squares problem could not be
            found because roundoff error caused a total loss of
            precision.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.LeastSquaresFit(`0[],`0[],`0[])">
      <summary>
            Gets the least squares fit of target data in terms of
            the components of the <see cref="T:Numerics.NET.Curves.FunctionBasis" />.
            </summary>
      <param name="xValues">A <typeparamref name="T" />
            array containing the data points for the fit.</param>
      <param name="yValues">A <typeparamref name="T" />
            array containing the data values corresponding
            to the data points.
            in <paramref name="xValues" />.</param>
      <param name="weights">A <typeparamref name="T" />
            array containing the weights to assign to the residual
            error corresponding to the data values in
            <paramref name="yValues" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.LinearCombination" /> that is the
            least squares fit of the data in terms of this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="yValues" /> is <see langword="null" />.</para></exception>
      <exception cref="T:Numerics.NET.TotalLossOfPrecisionException">
            The solution of the least squares problem could not be
            found because roundoff error caused a total loss of
            precision.</exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            <paramref name="xValues" /> and <paramref name="yValues" />
            do not have the same length.</exception>
      <exception cref="T:System.ArgumentException">
            The number of data points is less than the number of basis functions.
            </exception>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.FunctionBasis`1.Length">
      <summary>
            Gets the number of items in this <see cref="T:Numerics.NET.Curves.FunctionBasis" />.
            </summary>
      <value>The number of items in this <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</value>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.FunctionBasis`1.ValuesAt(`0)">
      <summary>
            Evaluates the member functions of this
            <see cref="T:Numerics.NET.Curves.FunctionBasis" /> at a specified value.
            </summary>
      <param name="x">A real number.</param>
      <returns>A vector containing the
            function values.</returns>
      <remarks>
        <para>This method creates a new <see cref="T:Numerics.NET.Vector" />
            every time it is called. In some situations, it may be more
            efficient to call the <see cref="M:Numerics.NET.Curves.Generic.FunctionBasis`1.FillValues(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})" /> method
            instead.</para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.GeneralCurve`1">
      <summary>
            Represents a curve in two-dimensional space whose value
            is defined by a function of one variable delegate.
            </summary>
      <remarks>
        <para>This class inherits from the <see cref="T:Numerics.NET.Curves.Curve" />
            class, which provides common
            properties and methods for all classes that represent
            two-dimensional curves.</para>
        <para>The <see cref="M:Numerics.NET.Curves.Generic.GeneralCurve`1.ValueAt(`0)" /> method evaluates the
            curve at a specific point. <see cref="M:Numerics.NET.Curves.Generic.GeneralCurve`1.SlopeAt(`0)" />
            evaluates the derivative, and <see cref="M:Numerics.NET.Curves.Generic.GeneralCurve`1.Integral(`0,`0)" />
            evaluates the definite integral over a specified
            interval. If overridden by a descendant class, the
            <see cref="M:Numerics.NET.Curves.Generic.GeneralCurve`1.GetDerivative" /> method returns the
            <see cref="T:Numerics.NET.Curves.Curve" /> that is the derivative of
            the instance. The <see cref="M:Numerics.NET.Curves.Generic.GeneralCurve`1.FindRoots" /> method
            attempts to find one zero of the function using
            <see cref="T:Numerics.NET.EquationSolvers.NewtonRaphsonSolver">Newton's
            method</see>.</para>
        <para>Curves of this type do not have any parameters.
            The <see cref="P:Numerics.NET.Curves.Curve.Parameters" /> collection is always
            empty.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.GeneralCurve`1.#ctor(System.Func{`0,`0})">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.GeneralCurve" /> from a
            function of one variable delegate.
            </summary>
      <param name="valueFunction">A delegate that represents a function of one variable
            delegate that calculates the value of the
            function.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.GeneralCurve`1.#ctor(System.Func{`0,`0},System.Func{`0,`0})">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.GeneralCurve" /> from a
            function of one variable delegate with the
            specified derivative.
            </summary>
      <param name="valueFunction">A delegate that represents a function of one variable
            delegate that calculates the value of the
            function.</param>
      <param name="derivativeFunction">A delegate that represents a function of one variable
            delegate that calculates the derivative of the
            function.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.GeneralCurve`1.#ctor(System.Func{`0,`0},System.Func{`0,`0},System.Func{`0,`0})">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.GeneralCurve" /> from a
            function of one variable delegate with the
            specified derivative.
            </summary>
      <param name="valueFunction">A delegate that represents a function of one variable
            delegate that calculates the value of the
            function.</param>
      <param name="derivativeFunction">A delegate that represents a function of one variable
            delegate that calculates the derivative of the
            function.</param>
      <param name="integralFunction">A delegate that represents a function of one variable
            delegate that calculates the integral of the
            function.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.GeneralCurve`1.FindRoots">
      <summary>
            Gets the set of X-coordinates where the curve crosses
            the X-axis.
            </summary>
      <returns>An array of X-coordinates where the curve
            crosses the X-axis.</returns>
      <remarks>
        <para>This method attempts to find a single
            zero of the function.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.GeneralCurve`1.GetDerivative">
      <summary>
            Returns a <see cref="T:Numerics.NET.Curves.Curve" /> that represents the derivative
            of this <see cref="T:Numerics.NET.Curves.Curve" />.
            </summary>
      <returns>A <see cref="T:Numerics.NET.Curves.Curve" /> that represents the
            derivative of this curve.</returns>
      <remarks>
        <para>The value of the derivative of a curve at a
            point is the slope of the curve at that point.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.GeneralCurve`1.Integral(`0,`0)">
      <summary>
            Gets the definite integral of the curve between the
            specified X-coordinates.
            </summary>
      <param name="lowerBound">The lower bound of the integration interval.</param>
      <param name="upperBound">The upper bound of the integration interval.</param>
      <returns>The definite integral of the curve between
            <paramref name="lowerBound" /> and <paramref name="upperBound" />.
            </returns>
      <remarks>
        <para>If an integrator function was not supplied,
            the integral is evaluated numerically.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.GeneralCurve`1.SlopeAt(`0)">
      <summary>
            Gets the slope of the curve at the specified
            X-coordinate.
            </summary>
      <param name="x">A real number.</param>
      <returns>The slope of the curve at the specified
            X-coordinate.</returns>
      <remarks>
        <para>If a derivative function was not supplied,
            the slope is evaluated numerically.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.GeneralCurve`1.ValueAt(`0)">
      <summary>
            Gets the Y-value of the curve at the specified
            X-coordinate.
            </summary>
      <param name="x">A real number.</param>
      <returns>The Y-value of the curve at the specified
            X-coordinate.</returns>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.LinearCombination`1">
      <summary>
            Represents a curve that is a linear combination of the
            functions in a <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />.
            </summary>
      <remarks>
        <para>
            Use the <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> class to represent
            functions that are a linear combination of a set of basis functions
            in a <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.#ctor(Numerics.NET.Curves.Generic.FunctionBasis{`0})">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> object.
            </summary>
      <param name="basis">The <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />
            whose member functions this <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" />
            is a linear combination of.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="basis" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.#ctor(Numerics.NET.Curves.Generic.FunctionBasis{`0},Numerics.NET.Vector{`0})">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> object.
            </summary>
      <param name="basis">The <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />
            whose member functions this <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" />
            is a linear combination of.</param>
      <param name="coefficients">A <typeparamref name="T" /> array
            that contains the coefficients to the functions
            in <paramref name="basis" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="basis" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="coefficients" /> is <see langword="null" />.</para></exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">
            The length of <paramref name="coefficients" /> is not equal to
            the size of <paramref name="basis" /> .
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.#ctor(Numerics.NET.Curves.Generic.FunctionBasis{`0},`0[])">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> object.
            </summary>
      <param name="basis">The <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />
            whose member functions this <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" />
            is a linear combination of.</param>
      <param name="coefficients">A <typeparamref name="T" /> array
            that contains the coefficients to the functions
            in <paramref name="basis" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="basis" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="coefficients" /> is <see langword="null" />.</para></exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">
            The length of <paramref name="coefficients" /> is not equal to
            the size of <paramref name="basis" /> .
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.Add(Numerics.NET.Curves.Generic.LinearCombination{`0})">
      <summary>
            Adds another <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> to this instance.
            </summary>
      <param name="combination">The <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> to add to this instance.</param>
      <returns>A reference to this instance.</returns>
      <remarks>
        <para>In order to add two linear combinations, they must have the same <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />.
            If this is not the case, an <see cref="T:System.ArgumentException" /> is thrown.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="combination" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.Add(Numerics.NET.Curves.Generic.LinearCombination{`0},Numerics.NET.Curves.Generic.LinearCombination{`0})">
      <summary>
            Adds two linear combinations.
            </summary>
      <param name="combination1">The first <see cref="T:Numerics.NET.Curves.PolynomialBase" />.</param>
      <param name="combination2">The second <see cref="T:Numerics.NET.Curves.PolynomialBase" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.PolynomialBase" /> that is the sum of the
            two operands.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="combination1" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="combination2" /> is <see langword="null" />.</para></exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.Add(`0,Numerics.NET.Curves.Generic.LinearCombination{`0})">
      <summary>
            Adds a multiple of another <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> to this instance.
            </summary>
      <param name="factor">Multiplier for the second <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" />.</param>
      <param name="combination">The <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> to add to this instance.</param>
      <returns>A reference to this instance.</returns>
      <remarks>
        <para>In order to add two linear combinations, they must have the same <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />.
            If this is not the case, an <see cref="T:System.ArgumentException" /> is thrown.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="combination" /> is <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException">
            This instance and <paramref name="combination" /> do not have the same <see cref="!:Basis&lt;T&gt;" />.</exception>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.LinearCombination`1.Basis">
      <summary>
            Gets the <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" /> associated with the linear combination.
            </summary>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.LinearCombination`1.Coefficient(System.Int32)">
      <summary>
            Gets or sets the coefficient of the function with the specified
            index.
            </summary>
      <value>A real number.</value>
      <remarks>
        <para>The <paramref name="index" /> parameter
            represents the index of the function in the underlying
            <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />. For classes deriving from
            <see cref="T:Numerics.NET.Curves.PolynomialBase" />, this corresponds to the
            degree or order of the basis polynomial.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.Divide(Numerics.NET.Curves.Generic.LinearCombination{`0},`0)">
      <summary>
            Divides a linear combination by a real number.
            </summary>
      <param name="factor">A real number.</param>
      <param name="combination">A <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> that is the product of the
            two operands.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.GetCurveFitter">
      <summary>
            Returns a <see cref="T:Numerics.NET.Curves.CurveFitter" /> object that can be used to fit the curve to data.
            </summary>
      <returns>A <see cref="T:Numerics.NET.Curves.LinearCurveFitter" /> object suitable for fitting the curve to data.</returns>
      <remarks>
        <para>
            The <see cref="T:Numerics.NET.Curves.CurveFitter" /> object returned by this method can be used to adjust the parameters
            of the instance to best fit the data supplied to the curve fitter object.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.Multiply(`0,Numerics.NET.Curves.Generic.LinearCombination{`0})">
      <summary>
            Multiplies a linear combination by a real number.
            </summary>
      <param name="factor">A real number.</param>
      <param name="combination">A <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> that is the product of the
            two operands.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="combination" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.Negate(Numerics.NET.Curves.Generic.LinearCombination{`0})">
      <summary>
            Returns the negation of a linear combination.
            </summary>
      <param name="combination">A <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> that is the
            negation of <paramref name="combination" /></returns>
      <remarks>
        <para>The negation of a linear combination is the
            linear combination whose coefficients are the negation of
            the coefficients of the original linear combination.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="combination" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.SlopeAt(`0)">
      <summary>
            Gets the slope of the curve at the specified
            X-coordinate.
            </summary>
      <param name="x">A real number.</param>
      <returns>The slope of the curve at the specified
            X-coordinate.</returns>
      <remarks>
        <para>This method evaluates the derivative of the curve
            at the point <paramref name="x" />. By default, the derivative
            is approximated numerically using central differences.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.Subtract(Numerics.NET.Curves.Generic.LinearCombination{`0})">
      <summary>
            Subtracts another <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> from this instance.
            </summary>
      <param name="combination">The <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" /> to subtract from this instance.</param>
      <returns>A reference to this instance.</returns>
      <remarks>
        <para>In order to add two linear combinations, they must have the same <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />.
            If this is not the case, an <see cref="T:System.ArgumentException" /> is thrown.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="combination" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.Subtract(Numerics.NET.Curves.Generic.LinearCombination{`0},Numerics.NET.Curves.Generic.LinearCombination{`0})">
      <summary>
            Subtracts two linear combinations.
            </summary>
      <param name="combination1">The first <see cref="T:Numerics.NET.Curves.PolynomialBase" />.</param>
      <param name="combination2">The second <see cref="T:Numerics.NET.Curves.PolynomialBase" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.PolynomialBase" /> that equals the
            second linear combination subtracted from the first.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="combination1" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="combination2" /> is <see langword="null" />.</para></exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCombination`1.ValueAt(`0)">
      <summary>
            Gets the Y-value of the curve at the specified
            X-coordinate.
            </summary>
      <param name="x">A real number.</param>
      <returns>The Y-value of the curve at the specified
            X-coordinate.</returns>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.LinearCurveFitter`1">
      <summary>
            Represents an algorithm that calculates a linear least squares fit of a curve.
            </summary>
      <remarks>
        <para>
            Use the <see cref="T:Numerics.NET.Curves.LinearCurveFitter" /> class to fit data
            to a curve by the method of least squares.
            The curve is specified by the <see cref="P:Numerics.NET.Curves.LinearCurveFitter.Curve" /> property.
            The parameters of this curve are modified to produce the best fit.
            The curve must be of a type that inherits from <see cref="T:Numerics.NET.Curves.LinearCombination" />,
            This includes instances of <see cref="T:Numerics.NET.Curves.Polynomial" /> and <see cref="T:Numerics.NET.Curves.ChebyshevSeries" />.</para>
        <para>The data is supplied as <see cref="T:Numerics.NET.Vector" /> objects
            through the <see cref="P:Numerics.NET.Curves.CurveFitter.XValues" /> and <see cref="P:Numerics.NET.Curves.CurveFitter.YValues" /> properties.</para>
        <para>By default, the observations are unweighted. You can supply a
            weighting method in two ways. You can set the <see cref="P:Numerics.NET.Curves.CurveFitter.WeightFunction" />
            property to a function of two variables delegate that computes the weight
            for each observation. The <see cref="T:Numerics.NET.Curves.WeightFunctions" /> class provides predefined
            delegates for the most common weight functions.
            Alternatively, you can set the individual weights by setting the <see cref="P:Numerics.NET.Curves.CurveFitter.WeightVector" />
            property to a <see cref="T:Numerics.NET.Vector" /> that contains the weight for each individual observation.</para>
        <para>The <see cref="M:Numerics.NET.Curves.CurveFitter.Fit" /> method performs the actual curve fit.
            By default, a QR decomposition is used. You can change the default behavior
            by setting the <see cref="P:Numerics.NET.Curves.Generic.LinearCurveFitter`1.Method" /> property to one of the <see cref="T:Numerics.NET.Curves.Generic.LinearLeastSquaresMethod" />
            values.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCurveFitter`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.LinearCurveFitter" /> object.
            </summary>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCurveFitter`1.#ctor(Numerics.NET.Curves.Generic.LinearLeastSquaresMethod)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.LinearCurveFitter" /> object.
            </summary>
      <param name="method">A <see cref="T:Numerics.NET.Curves.Generic.LinearLeastSquaresMethod" /> value that specifies
            how the least-squares solution is to be calculated.</param>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.LinearCurveFitter`1.Curve">
      <summary>
            Gets the non-linear curve that is being fitted.
            </summary>
      <value>A <see cref="P:Numerics.NET.Curves.Generic.LinearCurveFitter`1.Curve" /> object of a type that inherits from <see cref="T:Numerics.NET.Curves.LinearCombination" />.</value>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> is <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> is not an instance of a type that inherits form <see cref="T:Numerics.NET.Curves.LinearCombination" />.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCurveFitter`1.GetConfidenceBandwidth(`0,System.Double)">
      <summary>
            Gets the width of the confidence band around the best-fit curve at the specified point.
            </summary>
      <param name="x">The point at which to evaluate the bandwidth.</param>
      <param name="confidenceLevel">The confidence level of the confidence band.</param>
      <returns>The distance from the predicted value to the upper or lower confidence band.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.LinearCurveFitter`1.GetPredictionBandwidth(`0,System.Double)">
      <summary>
            Gets the width of the prediction band around the best-fit curve at the specified point.
            </summary>
      <param name="x">The point at which to evaluate the bandwidth.</param>
      <param name="confidenceLevel">The confidence level of the prediction band.</param>
      <returns>The distance from the predicted value to the upper or lower prediction band.</returns>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.LinearCurveFitter`1.Method">
      <summary>
            Gets or sets the method used to calculate the least-sqaures solution.
            </summary>
      <value>A <see cref="T:Numerics.NET.Curves.Generic.LinearLeastSquaresMethod" /> value.</value>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.LinearLeastSquaresMethod">
      <summary>
            Enumerates the possible methods for solving a least
            squares problem.
            </summary>
      <remarks>
        <para>This enumeration is used by the <see cref="T:Numerics.NET.Curves.LinearCurveFitter" /> class
            to specify how the least squares solution is to be calculated.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.Curves.Generic.LinearLeastSquaresMethod.NormalEquations">
      <summary>
            Use the normal equations computed from the input.
            </summary>
    </member>
    <member name="F:Numerics.NET.Curves.Generic.LinearLeastSquaresMethod.QRDecomposition">
      <summary>
            Use a QR decomposition. This is the default.
            </summary>
    </member>
    <member name="F:Numerics.NET.Curves.Generic.LinearLeastSquaresMethod.SingularValueDecomposition">
      <summary>
            Use a singular value decomposition. This is the most stable and reliable method, but also the slowest.
            </summary>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.Polynomial`1">
      <summary>
            Represents a polynomial.
            </summary>
      <remarks>
        <para>Use the <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> class to
            represent ordinary polynomials. A polynomial is an algebraic expression
            consisting of one or more summed terms, each term
            consisting of a constant multiplier and a variable raised
            to an integral exponent. It inherits from
            <see cref="T:Numerics.NET.Curves.Curve" /> and provides specialized
            implementation for most methods.</para>
        <para>The parameters of a <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />
            correspond to the coefficients of the polynomial.
            The coefficients can be accessed through the indexed
            <see cref="P:Numerics.NET.Curves.LinearCombination.Coefficient(System.Int32)" /> property. In C#, this property is
            the indexer for this class.</para>
        <para>The <see cref="M:Numerics.NET.Curves.Generic.Polynomial`1.ValueAt(`0)" /> method returns
            the value of the polynomial at a specific point.
            <see cref="M:Numerics.NET.Curves.Generic.Polynomial`1.SlopeAt(`0)" /> returns the derivative.
            <see cref="M:Numerics.NET.Curves.Generic.Polynomial`1.Integral(`0,`0)" />
            evaluates the definite integral over a specified
            interval.</para>
        <para>The <see cref="M:Numerics.NET.Curves.Generic.Polynomial`1.FindRoots" /> method attempts
            to find all real roots of the polynomial. It returns
            an array.
            The corresponding <see cref="M:Numerics.NET.Curves.Generic.Polynomial`1.FindComplexRoots" />
            method attempts to find all complex roots, and returns
            them as an array of complex number values.
            The roots are sorted in order of ascending real part.</para>
        <para>Methods for arithmetic operations on polynomials
            have been defined. Corresponding operator overloads
            are available for those languages that support them.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
            Constructs a new polynomial with the specified
            coefficients.
            </summary>
      <param name="coefficients">A vector
            containing the coefficients. The
            index into the array corresponds to the degree of the
            coefficient.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="coefficients" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.#ctor(System.Collections.Generic.IList{`0},System.Boolean)">
      <summary>
            Constructs a new polynomial with the specified
            coefficients.
            </summary>
      <param name="coefficients">A list of real numbers
            containing the coefficients. The
            index into the array corresponds to the degree of the
            coefficient.</param>
      <param name="descendingOrder">Specifies whether
            the coefficients are listed in descending order,
            with the coefficient of highest degree having index 0.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="coefficients" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.#ctor(System.Int32)">
      <summary>
            Constructs a new polynomial of the specified degree.
            </summary>
      <param name="degree">The degree of the polynomial.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.#ctor(`0[],System.Boolean)">
      <summary>
            Constructs a new polynomial with the specified
            coefficients.
            </summary>
      <param name="coefficients">A list of real numbers
            containing the coefficients. The
            index into the array corresponds to the degree of the
            coefficient.</param>
      <param name="descendingOrder">Specifies whether
            the coefficients are listed in descending order,
            with the coefficient of highest degree having index 0.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="coefficients" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Add(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Adds two polynomials.
            </summary>
      <param name="polynomial1">The first <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <param name="polynomial2">The second <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> that is the sum of the
            two operands.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Add(`0,Numerics.NET.Curves.Generic.LinearCombination{`0})">
      <summary>
            Adds a multiple of another <see cref="T:Numerics.NET.Curves.LinearCombination" /> to this instance.
            </summary>
      <param name="factor">Multiplier for the second <see cref="T:Numerics.NET.Curves.LinearCombination" />.</param>
      <param name="combination">The <see cref="T:Numerics.NET.Curves.LinearCombination" /> to add to this instance. It must be of type
            <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.LinearCombination" /> that contains a reference to this instance.</returns>
      <remarks>
        <para>In order to add two linear combinations, they must have the same <see cref="T:Numerics.NET.Curves.FunctionBasis" />.
            If this is not the case, an <see cref="T:System.ArgumentException" /> is thrown.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="combination" /> is <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="combination" /> is not an instance of <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.
            <para>-or-</para><para>The degree of <paramref name="combination" /> is greater than the maximum
            degree of the polynomial.</para></exception>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.Polynomial`1.Basis">
      <summary>
            Gets the function basis for the polynomial.
            </summary>
      <value>A <see cref="T:Numerics.NET.Curves.PolynomialBasis" /> object as a <see cref="T:Numerics.NET.Curves.FunctionBasis" />.</value>
      <remarks>
        <para>For polynomials, the basis is a <see cref="T:Numerics.NET.Curves.PolynomialBasis" />.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.ComplexSlopeAt(Numerics.NET.Complex{`0})">
      <summary>
            Evaluates the slope or first derivative of a polynomial
            for a complex number argument.
            </summary>
      <param name="z">A complex number number.</param>
      <returns>The slope of the polynomial for the specified
            argument.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.ComplexValueAt(Numerics.NET.Complex{`0})">
      <summary>
            Evaluates the polynomial for a complex number
            argument.
            </summary>
      <param name="z">A complex number number.</param>
      <returns>The value of the polynomial for the specified
            argument.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Deflate(`0)">
      <summary>
            Deflates a polynomial by dividing out a root.
            </summary>
      <param name="root">A real number.</param>
      <returns>A polynomial of degree one less than
            the original.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Divide(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Divides one <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> by another.
            </summary>
      <param name="polynomial1">The first polynomial.</param>
      <param name="polynomial2">The second polynomial.</param>
      <returns>A polynomial that, when multiplied by
            <paramref name="polynomial2" /> results in a polynomial that
            differs from <paramref name="polynomial1" /> only in the
            coefficients of degree smaller than the degree of
            <paramref name="polynomial2" />.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="polynomial1" /> is <see langword="null" />.
            <para>-or-</para><paramref name="polynomial2" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Divide(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0}@)">
      <summary>
            Divides one <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> by another.
            </summary>
      <param name="polynomial1">The first polynomial.</param>
      <param name="polynomial2">The second polynomial.</param>
      <param name="remainder">On exit, a <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />
            containing the remainder of the division.</param>
      <returns>A polynomial that, when multiplied by
            <paramref name="polynomial2" /> results in a polynomial that
            differs from <paramref name="polynomial1" /> only in the
            coefficients of degree smaller than the degree of
            <paramref name="polynomial2" />.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="polynomial1" /> is <see langword="null" />.
            <para>-or-</para><paramref name="polynomial2" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Equals(Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Overridden. Returns whether this
            instance is equal to a specified polynomial.
            </summary>
      <param name="other">A polynomial to compare with this instance.</param>
      <returns>
        <see langword="true" /> if <paramref name="other" /> 
            equals the value of this instance; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Equals(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Returns whether two <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> objects
            represent the same value.
            </summary>
      <param name="polynomial1">A <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <param name="polynomial2">A <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <returns>
        <see langword="true" /> if <paramref name="polynomial1" /> and <paramref name="polynomial2" />
            represent the same polynomial; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Equals(System.Object)">
      <summary>
            Overridden. Returns whether this
            instance is equal to a specified object.
            </summary>
      <param name="obj">An object to compare with this instance.</param>
      <returns>
        <see langword="true" /> if <paramref name="obj" /> is an
            instance of <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> and equals the value of this
            instance; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Evaluate(System.Collections.Generic.IList{`0},`0)">
      <summary>
            Evaluates a polynomial with the specified coefficients.
            </summary>
      <param name="coefficients">A list of coefficients,
            starting with the constant term.</param>
      <param name="x">The point at which to evaluate the polynomial.</param>
      <returns>The value of the polynomial with the elements of
            <paramref name="coefficients" /> as coefficients at the value 
            <paramref name="x" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="coefficients" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.FindComplexRoots">
      <summary>
            Gets the set of roots of the <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.
            </summary>
      <returns>An array containing the complex number
            roots of the <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</returns>
      <remarks>
        <para>A polynomial of degree <i>n</i>
            has exactly <i>n</i> complex roots.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.FindRoots">
      <summary>
            Gets the set of X-coordinates where the <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />
            crosses the X-axis.
            </summary>
      <returns>An array of X-coordinates where the
            <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> crosses the X-axis.</returns>
      <remarks>
        <para>In general, a polynomial of degree <i>n</i>
            has up to <i>n</i> roots.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.FromRoots(`0[])">
      <summary>
            Constructs a new polynomial that has the specified
            roots.
            </summary>
      <param name="roots">A list of roots.</param>
      <returns>A polynomial with the specified roots.</returns>
      <remarks>
        <para>The degree of the polynomial is equal to
            the number of roots. You can specify the same root
            multiple times.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="roots" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.GetDerivative">
      <summary>
            Returns a <see cref="T:Numerics.NET.Curves.Curve" /> of type <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />
            that represents the derivative of this <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.
            </summary>
      <returns>A <see cref="T:Numerics.NET.Curves.Curve" /> that represents the
            derivative of this curve.</returns>
      <remarks>
        <para>The value of the derivative of a curve at a
            point is the slope of the curve at that point.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.GetHashCode">
      <summary>
            Overridden. Returns the hash code for this instance.
            </summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.GetInterpolatingPolynomial(Numerics.NET.Vector{`0},Numerics.NET.Vector{`0})">
      <summary>
            Constructs the interpolating polynomial through a
            set of points.
            </summary>
      <param name="xValues">A <typeparamref name="T" /> vector containing
            the x-coordinates of the interpolation points. The
            elements of this array must be distinct.</param>
      <param name="yValues">A <typeparamref name="T" /> vector containing
            the y-coordinates of the interpolation points.</param>
      <returns>The interpolating <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />
            for the specified points.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><paramref name="yValues" /> is <see langword="null" />.
            </exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">
            The arrays <paramref name="xValues" /> and <paramref name="yValues" />
            have different lengths.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.GetInterpolatingPolynomial(`0[],`0[])">
      <summary>
            Constructs the interpolating polynomial through a
            set of points.
            </summary>
      <param name="xValues">A <typeparamref name="T" /> array containing
            the x-coordinates of the interpolation points. The
            elements of this array must be distinct.</param>
      <param name="yValues">A <typeparamref name="T" /> array containing
            the y-coordinates of the interpolation points.</param>
      <returns>The interpolating <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />
            for the specified points.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><paramref name="yValues" /> is <see langword="null" />.
            </exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">
            The arrays <paramref name="xValues" /> and <paramref name="yValues" />
            have different lengths.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Integral(`0,`0)">
      <summary>
            Gets the definite integral of the curve between the
            specified X-coordinates.
            </summary>
      <param name="lowerBound">The lower bound of the integration interval.</param>
      <param name="upperBound">The upper bound of the integration interval.</param>
      <returns>The definite integral of the curve between
            <paramref name="lowerBound" /> and <paramref name="upperBound" />.
            </returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.LeastSquaresFit(Numerics.NET.Vector{`0},Numerics.NET.Vector{`0},System.Int32)">
      <summary>
            Returns the <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> that is the best
            least squares fit through the given set of points.
            </summary>
      <param name="xValues">An array of numbers containing the
            X-coordinates of the points.</param>
      <param name="yValues">An array of numbers containing the
            Y-coordinates of the points.</param>
      <param name="degree">The degree of the least squares
            polynomial. Must be smaller than the number of
            data points.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />  that is the least
            squares fit through the given set of points.</returns>
      <remarks>
        <para>The least squares fit of a polynomial through
            a set of points is the polynomial that minimizes the
            sum of the squares of the residuals. The residuals are
            the differences between the predicted and the actual
            values.
            </para>
        <para>The coordinates of the points are provided in
            two <typeparamref name="T" /> arrays. These must have the
            same number of elements, or an exception is thrown.</para>
        <para>In rare cases, the least squares polynomial is
            a vertical line. In this case, a
            <see cref="T:System.DivideByZeroException" /> exception is thrown.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><paramref name="yValues" /> is <see langword="null" />.
            </exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">
            The arrays <paramref name="xValues" /> and <paramref name="yValues" />
            have different lengths.
            </exception>
      <exception cref="T:System.DivideByZeroException">The
            least-squares polynomial is a vertical line.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="degree" /> is less than zero.</exception>
      <exception cref="T:Numerics.NET.InsufficientDataException">
        <paramref name="degree" /> is greater than or equal to the number of data points.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.LeastSquaresFit(Numerics.NET.Vector{`0},Numerics.NET.Vector{`0},System.Int32,Numerics.NET.Vector{`0})">
      <summary>
            Returns the <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> that is the best
            weighted least squares fit through the given set of points.
            </summary>
      <param name="xValues">A vector containing the
            X-coordinates of the points.</param>
      <param name="yValues">A vector containing the
            Y-coordinates of the points.</param>
      <param name="degree">The degree of the least squares
            polynomial. Must be smaller than the number of
            data points.</param>
      <param name="weights">A vector containing the weights
            of the observations.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />  that is the least
            squares fit through the given set of points.</returns>
      <remarks>
        <para>The least squares fit of a polynomial through
            a set of points is the polynomial that minimizes the
            sum of the squares of the residuals. The residuals are
            the differences between the predicted and the actual
            values.
            </para>
        <para>The coordinates of the points are provided in
            two arrays. These must have the
            same number of elements, or an exception is thrown.</para>
        <para>In rare cases, the least squares polynomial is
            a vertical line. In this case, a
            <see cref="T:System.DivideByZeroException" /> exception is thrown.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="xValues" /> is <see langword="null" />.
            <para>-or-</para><paramref name="yValues" /> is <see langword="null" />.
            </exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">
            The arrays <paramref name="xValues" /> and <paramref name="yValues" />
            have different lengths.<br />
            -or-
            The arrays <paramref name="xValues" /> and <paramref name="weights" />
            have different lengths.
            </exception>
      <exception cref="T:System.DivideByZeroException">The
            least-squares polynomial is a vertical line.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="degree" /> is less than zero or greater than the number of data points.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Modulus(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Divides one <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> by another and
            returns the remainder.
            </summary>
      <param name="polynomial1">The first polynomial.</param>
      <param name="polynomial2">The second polynomial.</param>
      <returns>A polynomial of degree smaller than the
            degree of <paramref name="polynomial2" />, so that when it
            is subtracted from <paramref name="polynomial1" />, the result
            is exactly divisible by <paramref name="polynomial2" />.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="polynomial1" /> is <see langword="null" />.
            <para>-or-</para><paramref name="polynomial2" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Multiply(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Multiplies two polynomials.
            </summary>
      <param name="polynomial1">The first <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <param name="polynomial2">The second <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> that is the product of the
            two operands.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="polynomial1" /> is <see langword="null" />.
            <para>-or-</para><paramref name="polynomial2" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.op_Addition(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Adds two polynomials.
            </summary>
      <param name="polynomial1">The first <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <param name="polynomial2">The second <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> that is the sum of the
            two operands.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.op_Division(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Divides one <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> by another.
            </summary>
      <param name="polynomial1">The first polynomial.</param>
      <param name="polynomial2">The second polynomial.</param>
      <returns>A polynomial that, when multiplied by
            <paramref name="polynomial2" /> results in a polynomial that
            differs from <paramref name="polynomial1" /> only in the
            coefficients of degree smaller than the degree of
            <paramref name="polynomial2" />.
            </returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.op_Equality(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Compares two <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> objects for
            equality.
            </summary>
      <param name="polynomial1">The first <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <param name="polynomial2">The second <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <returns>
        <see langword="true" /> if the two polynomials are equal;
            otherwise <see langword="false" />.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.op_Inequality(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Compares two <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> objects for
            inequality.
            </summary>
      <param name="polynomial1">The first <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <param name="polynomial2">The second <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <returns>
        <see langword="true" /> if the two polynomials are different;
            otherwise <see langword="false" />.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.op_Modulus(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Divides one <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> by another and
            returns the remainder.
            </summary>
      <param name="polynomial1">The first polynomial.</param>
      <param name="polynomial2">The second polynomial.</param>
      <returns>A polynomial of degree smaller than the
            degree of <paramref name="polynomial2" />, so that when it
            is subtracted from <paramref name="polynomial1" />, the result
            is exactly divisible by <paramref name="polynomial2" />.
            </returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.op_Multiply(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Multiplies two polynomials.
            </summary>
      <param name="polynomial1">The first <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <param name="polynomial2">The second <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> that is the product of the
            two operands.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.op_Subtraction(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Subtracts two polynomials.
            </summary>
      <param name="polynomial1">The first <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <param name="polynomial2">The second <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> that equals the
            second polynomial subtracted from the first.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.SlopeAt(`0)">
      <summary>
            Evaluates the slope or first derivative of a polynomial
            for a real argument.
            </summary>
      <param name="x">A real number.</param>
      <returns>The slope of the polynomial for the specified
            argument.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.Subtract(Numerics.NET.Curves.Generic.Polynomial{`0},Numerics.NET.Curves.Generic.Polynomial{`0})">
      <summary>
            Subtracts two polynomials.
            </summary>
      <param name="polynomial1">The first <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <param name="polynomial2">The second <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" />.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Generic.Polynomial`1" /> that equals the
            second polynomial subtracted from the first.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.ToString">
      <summary>
            Returns a string representation of this instance.
            </summary>
      <returns>A string representation of this instance.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.ToString(System.String)">
      <summary>
            Returns a string representation of this instance using the specified string to format the coefficients.
            </summary>
      <returns>A string representation of this instance.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.ToString(System.String,System.IFormatProvider)">
      <summary>
            Returns a string representation of this instance using the specified string and format provider
            to format the coefficients.
            </summary>
      <returns>A string representation of this instance.</returns>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.Polynomial`1.ValueAt(`0)">
      <summary>
            Evaluates the polynomial for a real argument.
            </summary>
      <param name="x">A real number.</param>
      <returns>The value of the polynomial for the specified
            argument.</returns>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.PolynomialBase`1">
      <summary>
            Serves as an abstract base class for <see cref="T:Numerics.NET.Curves.Curve" />
            derived classes that represent polynomials.
            </summary>
      <remarks>
        <para>
            This base class is provided to make it easier for
            implementers to create classes that implement linear
            combinations of specific types of univariate
            polynomials.</para>
        <para>This is an abstract base class and cannot
            be instantiated directly. Instead, create an instance
            of one of the defined derived classes, or create a
            class that inherits from
            <see cref="T:Numerics.NET.Curves.PolynomialBase" />.</para>
        <para>
            The following derived classes have been defined:
            <list type="table"><listheader><term>Class</term><description>Description</description></listheader><item><term>Polynomial</term><description>Ordinary polynomials.</description></item><item><term>ChebyshevSeries</term><description>Linear combination of Chebyshev
            polynomials.</description></item></list></para>
        <para>
          <strong>Note to inheritors:</strong> When you
            inherit from <see cref="T:Numerics.NET.Curves.PolynomialBase" />, you should
            create a corresponding class that inherits from
            <see cref="T:Numerics.NET.Curves.FunctionBasis" />. In addition, you must
            override the following members: <see cref="M:Numerics.NET.Curves.Curve.ValueAt(System.Double)" />,
            <see cref="M:Numerics.NET.Curves.Curve.SlopeAt(System.Double)" />, <see cref="M:Numerics.NET.Curves.Curve.Integral(System.Double,System.Double)" />.
            You may also want to override <see cref="M:Numerics.NET.Curves.Curve.FindRoots" />
            and <see cref="M:Numerics.NET.Curves.Curve.GetDerivative" />.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.PolynomialBase`1.#ctor(System.Int32)">
      <summary>
            Constructs a new curve with the specified number of
            parameters.
            </summary>
      <param name="parameterCount">The number of parameters.</param>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.PolynomialBase`1.#ctor(`0[])">
      <summary>
            Constructs a new curve with a specified set of
            parameters.
            </summary>
      <param name="parameters">An array of real numbers.</param>
      <remarks>
        <para>The meaning of the parameters is determined
            by the inheriting class.</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.PolynomialBase`1.Degree">
      <summary>
            Gets the degree of the polynomial.
            </summary>
      <value>The degree of the polynomial.</value>
      <remarks>
        <para>The degree of a polynomial is the order of the first non-zero term.
            It may be less than the number of parameters plus 1.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.PolynomialBase`1.OnParameterChanged(System.Int32,`0)">
      <summary>
            Called when a coefficient of the polynomial is changed.
            </summary>
      <param name="index">An integer specifying the index of the coefficient.</param>
      <param name="value">The value of the new coefficient.</param>
      <remarks>
        <para>This method is called internally to ensure that the <see cref="P:Numerics.NET.Curves.Generic.PolynomialBase`1.Degree" /> property
            maintains the proper value.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.PolynomialBase`1.Reduce">
      <summary>
            Reduces the degree of a polynomial so that the leading coefficient is different
            from zero.
            </summary>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.PolynomialBase`1.Reduce(`0)">
      <summary>
            Reduces the degree of a polynomial so that the leading coefficient is greater than
            the specified tolerance.
            </summary>
      <param name="tolerance">The absolute tolerance to use as the threshold for considering
            a coefficient equal to zero.</param>
    </member>
    <member name="T:Numerics.NET.Curves.Generic.PolynomialBasis`1">
      <summary>
            Represents a <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" /> for the polynomials
            up to a specified degree.
            </summary>
      <remarks>
        <para>Use a <see cref="T:Numerics.NET.Curves.Generic.PolynomialBasis`1" /> object to represent
            a basis for the polynomials. Only in rare cases will it be necessary
            to construct a <see cref="T:Numerics.NET.Curves.Generic.PolynomialBasis`1" />, as most functionality
            is available through the <see cref="T:Numerics.NET.Curves.Polynomial" /> class.</para>
        <para>The basis functions of a <see cref="T:Numerics.NET.Curves.Generic.PolynomialBasis`1" />
            are the monomials of degree 0 up to and including the specified
            degree.</para>
        <para>The Chebyshev polynomials form an <see cref="T:Numerics.NET.Curves.Generic.ChebyshevBasis`1">alternate
            basis</see> for the polynomials and have many desirable numerical
            properties.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.PolynomialBasis`1.#ctor(System.Int32)">
      <summary>
            Constructs a new <see cref="!:GeneralFunctionBasis&lt;T&gt;" />
            from an array of function of one variable
            delegates.
            </summary>
      <param name="degree">The degree of the highest order
            power in the function basis.</param>
      <remarks>
        <para>The number of basis functions equals the degree plus 1.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.PolynomialBasis`1.FillDerivatives(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})">
      <summary>
            Fills a vector with the derivatives of the
            member functions at a specified value.
            </summary>
      <param name="x">The value at which to evaluate the
            derivatives.</param>
      <param name="derivatives">A vector with
            length equal to the number of functions in this
            <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="derivatives" /> is <see langword="null" />.
            </exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            length of <paramref name="derivatives" /> is not equal to
            the number of member functions in this
            <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.PolynomialBasis`1.FillValues(`0,Numerics.NET.LinearAlgebra.DenseVector{`0})">
      <summary>
            Fills a dense vector with the values of the
            member functions at a specified value.
            </summary>
      <param name="x">The value at which to evaluate the
            member functions.</param>
      <param name="values">A dense vector with
            length equal to the number of functions in this
            <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="values" /> is <see langword="null" />.
            </exception>
      <exception cref="T:Numerics.NET.DimensionMismatchException">The
            length of <paramref name="values" /> is not equal to
            the number of member functions in this
            <see cref="T:Numerics.NET.Curves.Generic.FunctionBasis`1" />.</exception>
    </member>
    <member name="M:Numerics.NET.Curves.Generic.PolynomialBasis`1.GetFunction(Numerics.NET.Vector{`0})">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Curves.Polynomial" /> with the
            specified coefficients.
            </summary>
      <param name="coefficients">A vector
            containing the coefficients of the polynomial. The
            first element in the array corresponds to the constant
            term.</param>
      <returns>A <see cref="T:Numerics.NET.Curves.Polynomial" /> cast as a
            <see cref="T:Numerics.NET.Curves.Generic.LinearCombination`1" />.</returns>
    </member>
    <member name="P:Numerics.NET.Curves.Generic.PolynomialBasis`1.Item(System.Int32)">
      <summary>
            Gets an element of the collection as a
            function of one variable.
            </summary>
      <param name="index">The index of the function.</param>
      <value>A delegate that represents a function of one variable.</value>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero or greater
            than or equal to the number of functions in this
            <see cref="T:Numerics.NET.Curves.Generic.PolynomialBasis`1" />.</exception>
    </member>
    <member name="T:Numerics.NET.EquationSolvers.Generic.BisectionSolver`1">
      <summary>
            Represents a <see cref="T:Numerics.NET.EquationSolvers.EquationSolver" /> that uses the
            bisection algorithm.
            </summary>
      <remarks>
        <para>
            Use the <see cref="T:Numerics.NET.EquationSolvers.BisectionSolver" /> class to
            solve a simple non-linear equation if you have
            an interval that includes a root with certainty, and
            when you only need a rough approximation of the root.
            If you need higher accuracy, other algorithms are more
            efficient. <see cref="T:Numerics.NET.EquationSolvers.RobustSolver">TOMS algorithm 748</see> 
            is the method of choice for these situations.</para>
        <para>
          <see cref="T:Numerics.NET.EquationSolvers.BisectionSolver" /> inherits from
            <see cref="T:Numerics.NET.EquationSolvers.RootBracketingSolver" />, which in turn inherits
            from <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" />.
            All properties of <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" /> are available.
            The <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.AbsoluteTolerance" /> and
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.RelativeTolerance" /> properties set the desired
            precision as specified by the
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.ConvergenceCriterion" /> property. The default
            value for both tolerances is
            <see cref="F:Numerics.NET.MachineConstants.SqrtEpsilon" /> (roughly
            10<sup>-8</sup>). <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.MaxIterations" /> sets the
            maximum number of iterations.</para>
        <para>The <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.TargetFunction" /> property is a
            function of one variable that specifies
            the function we want to find a root for.
            The <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.LowerBound" /> and
            <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.UpperBound" />
            properties specify the bounds of the bracketing interval.
            The target function must have a different sign at each
            end of this interval.</para>
        <para>The <see cref="M:Numerics.NET.EquationSolvers.EquationSolver.Solve" /> method performs the actual
            approximation of the root. This method returns the
            best approximation that was found. The
            <see cref="T:Numerics.NET.AlgorithmStatus" /> property indicates
            whether the algorithm was successful. The
            <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.EstimatedError" /> property gives an upper
            bound for the difference between the approximated and
            the actual root.</para>
        <para>The bisection method is the simplest of the root
            bracketing algorithms. It works by dividing the
            bracketing interval into two equal parts in each
            iteration. Not taking into account round-off error,
            the number of iterations needed to achieve a
            certain accuracy can be estimated easily as the base
            2 logarithm of the relative accuracy. It takes about
            10 iterations to gain three digits in accuracy.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.BisectionSolver`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.BisectionSolver" />.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.BisectionSolver`1.#ctor(System.Func{`0,`0},`0,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.BisectionSolver" /> for a specified
            target function over a given bracketing interval.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the bracketing
            interval.</param>
      <param name="upperBound">The upper bound of the bracketing
            interval.</param>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.BisectionSolver`1.#ctor(System.Func{`0,`0},`0,`0,Numerics.NET.ConvergenceCriterion,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.BisectionSolver" /> for a specified
            target function over a given bracketing interval and
            tolerance.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the bracketing
            interval.</param>
      <param name="upperBound">The upper bound of the bracketing
            interval.</param>
      <param name="convergenceCriterion">One of the
            <see cref="T:Numerics.NET.ConvergenceCriterion" /> values that specifies
            the criterion that is to be used in the convergence
            test for the algorithm.</param>
      <param name="tolerance">The tolerance to use when
            approximating the roots of the target function.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="T:Numerics.NET.EquationSolvers.Generic.DekkerBrentSolver`1">
      <summary>
            Represents a root finder that uses Dekker and Brent's
            algorithm.
            </summary>
      <remarks>
        <para>Use the <see cref="T:Numerics.NET.EquationSolvers.DekkerBrentSolver" /> class to
            find a root of a function if you have
            an interval that includes a root with certainty.
            This is one of the more robust of the root bracketing 
            solver algorithms. The <see cref="T:Numerics.NET.EquationSolvers.RobustSolver" />,
            based on TOMS algorithm 748, is generally somewhat faster
            and more reliable.</para>
        <para>
          <see cref="T:Numerics.NET.EquationSolvers.DekkerBrentSolver" /> inherits from
            <see cref="T:Numerics.NET.EquationSolvers.RootBracketingSolver" />, which in turn inherits
            from <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" />.
            All properties of <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" /> are available.
            The <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.AbsoluteTolerance" /> and
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.RelativeTolerance" /> properties set the desired
            precision as specified by the
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.ConvergenceCriterion" /> property. The default
            value for both tolerances is
            <see cref="F:Numerics.NET.MachineConstants.SqrtEpsilon" /> (roughly
            10<sup>-8</sup>). <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.MaxIterations" /> sets the
            maximum number of iterations.</para>
        <para>The <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.TargetFunction" /> property is a
            function of one variable that specifies
            the function we want to find a root for.
            The <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.LowerBound" /> and
            <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.UpperBound" />
            properties specify the bounds of the bracketing interval.
            The target function must have a different sign at each
            end of this interval.</para>
        <para>The <see cref="M:Numerics.NET.EquationSolvers.EquationSolver.Solve" /> method performs the actual
            approximation of the root. This method returns the
            best approximation that was found. The
            <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" /> property indicates
            whether the algorithm was successful. The
            <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.EstimatedError" /> property gives an upper
            bound for the difference between the approximated and
            the actual root.</para>
        <para>The Dekker-Brent method is the most advanced of the
            <see cref="T:Numerics.NET.EquationSolvers.RootBracketingSolver">root bracketing
            algorithms</see>. It combines the robustness of the
            <see cref="T:Numerics.NET.EquationSolvers.BisectionSolver">bisection method</see> with the
            increased speed of the <see cref="T:Numerics.NET.EquationSolvers.RegulaFalsiSolver">regula
            falsi</see> (false positioning) method.</para>
        <para>At each iteration, either a bisection or a regula falsi
            step is taken, depending on the behavior of the algorithm
            up to that point. As a result, the Dekker-Brent method will
            converge as fast as the best case regula falsi method at its
            best, and as slow as the bisection method at its worst.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.DekkerBrentSolver`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.DekkerBrentSolver" />.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.DekkerBrentSolver`1.#ctor(System.Func{`0,`0},`0,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.DekkerBrentSolver" /> for a specified
            target function over a given bracketing interval and
            tolerance.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the bracketing
            interval.</param>
      <param name="upperBound">The upper bound of the bracketing
            interval.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.DekkerBrentSolver`1.#ctor(System.Func{`0,`0},`0,`0,Numerics.NET.ConvergenceCriterion,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.DekkerBrentSolver" /> for a specified
            target function over a given bracketing interval and
            tolerance.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the bracketing
            interval.</param>
      <param name="upperBound">The upper bound of the bracketing
            interval.</param>
      <param name="convergenceCriterion">One of the
            <see cref="T:Numerics.NET.ConvergenceCriterion" /> values that specifies
            the criterion that is to be used in the convergence
            test for the algorithm.</param>
      <param name="tolerance">The tolerance to use when
            approximating the roots of the target function.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="T:Numerics.NET.EquationSolvers.Generic.EquationSolver`1">
      <summary>
            Serves as an abstract base class for root finders.
            </summary>
      <remarks>
        <para>The <see cref="T:Numerics.NET.EquationSolvers.EquationSolver" /> class is the
            abstract base class of all classes that implement
            equation solving algorithms. The class inherits from
            <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" />. All the
            properties and methods exposed by this interface are
            available to all derived classes.</para>
        <para>This class cannot be instantiated directly.
            Instead, use one of the following derived classes:
            <list type="Table"><listheader><term>Class</term><description>Description</description></listheader><item><term>BisectionSolver</term><description>Represents a EquationSolver that uses the
            bisection algorithm.</description></item><item><term>RegulaFalsiSolver</term><description>Represents a root finder that uses the
            regula falsi or false position algorithm.</description></item><item><term>DekkerBrentSolver</term><description>Represents a root finder that uses
            Dekker and Brent's root bracketing algorithm.</description></item><item><term>TOMS748Solver</term><description>Represents a root finder that uses
            Algorithm 748 from the ACM's Transactions On 
            Mathematical Software (TOMS).</description></item><item><term>NewtonRaphsonSolver</term><description>Represents a root finder based on
            the Newton-Raphson algorithm. </description></item></list></para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.EquationSolver" /> object.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.#ctor(System.Func{`0,`0})">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.EquationSolver" /> object for the
            specified target function.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.#ctor(System.Func{`0,`0},Numerics.NET.ConvergenceCriterion,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.EquationSolver" /> object for the
            specified target function and tolerance.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="convergenceCriterion">One of the
            <see cref="T:Numerics.NET.ConvergenceCriterion" /> values that specifies
            the criterion that is to be used in the convergence
            test for the algorithm.</param>
      <param name="tolerance">The tolerance to use when
            approximating the roots of the target function.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.#ctor(System.Func{`0,`0},`0,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.EquationSolver" /> object for the
            specified target function and convergence parameters.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the
            bracketing interval.</param>
      <param name="upperBound">The upper bound of the
            bracketing interval.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.#ctor(System.Func{`0,`0},`0,`0,Numerics.NET.ConvergenceCriterion,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.EquationSolver" /> object for the
            specified target function and tolerance.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the
            bracketing interval.</param>
      <param name="upperBound">The upper bound of the
            bracketing interval.</param>
      <param name="convergenceCriterion">One of the
            <see cref="T:Numerics.NET.ConvergenceCriterion" /> values that specifies
            the criterion that is to be used in the convergence
            test for the algorithm.</param>
      <param name="tolerance">The tolerance to use when
            approximating the roots of the target function.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="P:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.CurrentLowerBound">
      <summary>
            Gets the lower bound of the convergence interval
            at the current iteration.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The convergence mode of the algorithm is not set to Interval.</exception>
    </member>
    <member name="P:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.CurrentUpperBound">
      <summary>
            Gets the upper bound of the convergence interval
            at the current iteration.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The convergence mode of the algorithm is not set to Interval.</exception>
    </member>
    <member name="F:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.DefaultMaxIterations">
      <summary>
            Specifies the default maximum number of iterations to use
            when approximating the roots of the target function.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.Evaluate(`0)">
      <summary>
            Evaluates the target function and increments the number of evaluations.
            </summary>
      <param name="x">The point at which to evaluate the function.</param>
      <returns>The value of the target function at <paramref name="x" />.</returns>
    </member>
    <member name="P:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.LowerBound">
      <summary>
            Gets or sets the lower bound for the solution.
            </summary>
      <remarks>
        <para>The target function will not be evaluated 
            at values less than this lower bound.</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.RightHandSide">
      <summary>
            Gets or sets the value of the target function to solve for.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.Solve">
      <summary>
            Attempts to find a root or zero of the target function.
            </summary>
      <returns>The best approximation to the root.</returns>
      <exception cref="T:Numerics.NET.Algorithms.ConvergenceException">The root finding
            algorithm failed to converge to within the specified
            tolerance.</exception>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.Solve(`0)">
      <summary>
            Attempts to find the point where the target function equals the specified value.
            </summary>
      <param name="rightHandSide">The right-hand side of the equation.</param>
      <returns>The best approximation to the root.</returns>
      <exception cref="T:Numerics.NET.Algorithms.ConvergenceException">The root finding
            algorithm failed to converge to within the specified
            tolerance.</exception>
    </member>
    <member name="P:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.TargetFunction">
      <summary>
            Gets or sets the target function for the <see cref="T:Numerics.NET.EquationSolvers.EquationSolver" />.
            </summary>
      <value>A delegate that represents a function of one variable delegate.</value>
    </member>
    <member name="P:Numerics.NET.EquationSolvers.Generic.EquationSolver`1.UpperBound">
      <summary>
            Gets or sets the upper bound for the solution.
            </summary>
      <remarks>
        <para>The target function will not be evaluated 
            at values greater than this upper bound.</para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.EquationSolvers.Generic.NewtonRaphsonSolver`1">
      <summary>
            Represents a root finder based on the Newton-Raphson
            algorithm.
            </summary>
      <remarks>
        <para>The Newton-Raphson algorithm starts from a single starting
            value. It then uses the derivative of the target function to
            find successive approximations of the root.</para>
        <para>
          <see cref="T:Numerics.NET.EquationSolvers.NewtonRaphsonSolver" /> inherits from
            <see cref="T:Numerics.NET.EquationSolvers.EquationSolver" />, which in turn inherits
            from <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" />.
            All properties of <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" /> are available.
            The <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.AbsoluteTolerance" /> and
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.RelativeTolerance" /> properties set the desired
            precision as specified by the
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.ConvergenceCriterion" /> property. The default
            value for both tolerances is
            <see cref="F:Numerics.NET.MachineConstants.SqrtEpsilon" /> (roughly
            10<sup>-8</sup>). <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.MaxIterations" /> sets the
            maximum number of iterations.</para>
        <para>The <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.TargetFunction" /> property is a
            function of one variable that specifies
            the function we want to find a root for.
            The <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.LowerBound" /> and
            <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.UpperBound" />
            properties specify the bounds of the bracketing interval.
            The target function must have a different sign at each
            end of this interval.</para>
        <para>The <see cref="M:Numerics.NET.EquationSolvers.EquationSolver.Solve" /> method performs the actual
            approximation of the root. This method returns the
            best approximation that was found. The
            <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" /> property indicates
            whether the algorithm was successful. The
            <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.EstimatedError" /> property gives an upper
            bound for the difference between the approximated and
            the actual root.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.NewtonRaphsonSolver`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.NewtonRaphsonSolver" /> object.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.NewtonRaphsonSolver`1.#ctor(System.Func{`0,`0},System.Func{`0,`0},`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.NewtonRaphsonSolver" /> object.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable
            delegate that specifies the target function.</param>
      <param name="derivativeOfTargetFunction">A delegate that represents a function of one variable
            delegate that specifies the derivative of the target
            function.</param>
      <param name="x0">The initial guess for the root.</param>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.NewtonRaphsonSolver`1.#ctor(System.Func{`0,`0},System.Func{`0,`0},`0,Numerics.NET.ConvergenceCriterion,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.NewtonRaphsonSolver" /> object.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable
            delegate that specifies the target function.</param>
      <param name="derivativeOfTargetFunction">A delegate that represents a function of one variable
            delegate that specifies the derivative of the target
            function.</param>
      <param name="x0">The initial guess for the root.</param>
      <param name="convergenceCriterion">One of the
            <see cref="T:Numerics.NET.ConvergenceCriterion" /> values that specifies
            the criterion that is to be used in the convergence
            test for the algorithm.</param>
      <param name="tolerance">The tolerance to use when
            approximating the roots of the target function.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="P:Numerics.NET.EquationSolvers.Generic.NewtonRaphsonSolver`1.DerivativeOfTargetFunction">
      <summary>
            Gets or sets the derivative of the target function.
            </summary>
      <value>A delegate that represents a function of one variable.</value>
    </member>
    <member name="P:Numerics.NET.EquationSolvers.Generic.NewtonRaphsonSolver`1.InitialGuess">
      <summary>
            Gets or sets the initial value for the Newton-Raphson
            iteration.
            </summary>
    </member>
    <member name="T:Numerics.NET.EquationSolvers.Generic.RegulaFalsiSolver`1">
      <summary>
            Represents a root finder that uses a modified regula falsi or
            false position algorithm.
            </summary>
      <remarks>
        <para>The regula falsi method, also called the method of
            false position, is a <see cref="T:Numerics.NET.EquationSolvers.RootBracketingSolver">root
            bracketing algorithm</see>. It works by approximating the
            target function by a line. The bracketing interval is
            divided at the point where this line crosses the axis.</para>
        <para>The regula falsi method is superior to the
            <see cref="T:Numerics.NET.EquationSolvers.BisectionSolver">bisection method</see> in that
            it will, in most cases, converge faster. However, in certain
            situations it can get 'stuck,' and convergence may actually
            be slower than the bisection method.</para>
        <para>The <see cref="T:Numerics.NET.EquationSolvers.DekkerBrentSolver">Dekker-Brent method</see>,
            and a further refinement implemented by the <see cref="T:Numerics.NET.EquationSolvers.RobustSolver" />
            class, combine the best of both worlds.</para>
        <para>
          <see cref="T:Numerics.NET.EquationSolvers.RegulaFalsiSolver" /> inherits from
            <see cref="T:Numerics.NET.EquationSolvers.RootBracketingSolver" />, which in turn inherits
            from <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" />.
            All properties of <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" /> are available.
            The <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.AbsoluteTolerance" /> and
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.RelativeTolerance" /> properties set the desired
            precision as specified by the
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.ConvergenceCriterion" /> property. The default
            value for both tolerances is
            <see cref="F:Numerics.NET.MachineConstants.SqrtEpsilon" /> (roughly
            10<sup>-8</sup>). <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.MaxIterations" /> sets the
            maximum number of iterations.</para>
        <para>The <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.TargetFunction" /> property is a
            function of one variable that specifies
            the function we want to find a root for.
            The <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.LowerBound" /> and
            <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.UpperBound" />
            properties specify the bounds of the bracketing interval.
            The target function must have a different sign at each
            end of this interval.</para>
        <para>The <see cref="M:Numerics.NET.EquationSolvers.EquationSolver.Solve" /> method performs the actual
            approximation of the root. This method returns the
            best approximation that was found. The
            <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" /> property indicates
            whether the algorithm was successful. The
            <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.EstimatedError" /> property gives an upper
            bound for the difference between the approximated and
            the actual root.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RegulaFalsiSolver`1.#ctor">
      <summary>
            Constructs a new <strong>RegulaFalsiSolver&gt;</strong>.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RegulaFalsiSolver`1.#ctor(System.Func{`0,`0},`0,`0)">
      <summary>
            Constructs a new <strong>RegulaFalsiSolver&gt;</strong> for a specified
            target function over a given bracketing interval and
            tolerance.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the bracketing
            interval.</param>
      <param name="upperBound">The upper bound of the bracketing
            interval.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RegulaFalsiSolver`1.#ctor(System.Func{`0,`0},`0,`0,Numerics.NET.ConvergenceCriterion,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.RegulaFalsiSolver" /> for a specified
            target function over a given bracketing interval and
            tolerance.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the bracketing
            interval.</param>
      <param name="upperBound">The upper bound of the bracketing
            interval.</param>
      <param name="convergenceCriterion">One of the
            <see cref="T:Numerics.NET.ConvergenceCriterion" /> values that specifies
            the criterion that is to be used in the convergence
            test for the algorithm.</param>
      <param name="tolerance">The tolerance to use when
            approximating the roots of the target function.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="T:Numerics.NET.EquationSolvers.Generic.RobustSolver`1">
      <summary>
            Represents a root finder that uses an algorithm by
            Alefeld, Potra, and Shi.
            </summary>
      <remarks>
        <para>Use the <see cref="T:Numerics.NET.EquationSolvers.RobustSolver" /> class to
            find a root of a function if you have
            an interval that includes a root with certainty.
            This is the most robust of the root bracketing solver algorithms.</para>
        <para>
          <see cref="T:Numerics.NET.EquationSolvers.RobustSolver" /> inherits from
            <see cref="T:Numerics.NET.EquationSolvers.EquationSolver" />, which in turn inherits
            from <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" />.
            All properties of <see cref="T:Numerics.NET.Algorithms.IterativeAlgorithm`1" /> are available.
            The <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.AbsoluteTolerance" /> and
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.RelativeTolerance" /> properties set the desired
            precision as specified by the
            <see cref="P:Numerics.NET.Algorithms.IterativeAlgorithm`1.ConvergenceCriterion" /> property. The default
            value for both tolerances is
            <see cref="F:Numerics.NET.MachineConstants.SqrtEpsilon" /> (roughly
            10<sup>-8</sup>). <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.MaxIterations" /> sets the
            maximum number of iterations.</para>
        <para>The <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.TargetFunction" /> property is a
            function of one variable that specifies
            the function we want to find a root for.
            The <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.LowerBound" /> and
            <see cref="P:Numerics.NET.EquationSolvers.EquationSolver.UpperBound" />
            properties specify the bounds of the bracketing interval.
            The target function must have a different sign at each
            end of this interval.</para>
        <para>The <see cref="M:Numerics.NET.EquationSolvers.EquationSolver.Solve" /> method performs the actual
            approximation of the root. This method returns the
            best approximation that was found. The
            <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.Status" /> property indicates
            whether the algorithm was successful. The
            <see cref="P:Numerics.NET.Algorithms.ManagedIterativeAlgorithm`3.EstimatedError" /> property gives an upper
            bound for the difference between the approximated and
            the actual root.</para>
        <para>The Dekker-Brent method is the most advanced of the
            <see cref="T:Numerics.NET.EquationSolvers.EquationSolver">root bracketing
            algorithms</see>. It combines the robustness of the
            <see cref="T:Numerics.NET.EquationSolvers.BisectionSolver">bisection method</see> with the
            increased speed of the <see cref="T:Numerics.NET.EquationSolvers.RegulaFalsiSolver">regula
            falsi</see> method.</para>
        <para>At each iteration, either a bisection or a regula falsi
            step is taken, depending on the behavior of the algorithm
            up to that point. As a result, the Dekker-Brent method will
            converge as fast as the best case regula falsi method at its
            best, and as slow as the bisection method at its worst.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RobustSolver`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.RobustSolver" />.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RobustSolver`1.#ctor(System.Func{`0,`0},`0,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.RobustSolver" /> for a specified
            target function over a given bracketing interval and
            tolerance.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the bracketing
            interval.</param>
      <param name="upperBound">The upper bound of the bracketing
            interval.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RobustSolver`1.#ctor(System.Func{`0,`0},`0,`0,Numerics.NET.ConvergenceCriterion,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.RobustSolver" /> for a specified
            target function over a given bracketing interval and
            tolerance.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the bracketing
            interval.</param>
      <param name="upperBound">The upper bound of the bracketing
            interval.</param>
      <param name="convergenceCriterion">One of the
            <see cref="T:Numerics.NET.ConvergenceCriterion" /> values that specifies
            the criterion that is to be used in the convergence
            test for the algorithm.</param>
      <param name="tolerance">The tolerance to use when
            approximating the roots of the target function.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="T:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1">
      <summary>
            Represents the abstract base class for root finders for real
            functions of one variable that use root bracketing.
            </summary>
      <remarks>
        <para>When two points are known where the target function
            has different signs, the target function has a root in the
            interval between the two points, provided the target
            function is continuous.</para>
        <para>Root bracketing root finders use this property by
            generating smaller and smaller intervals until the length
            of the interval is smaller than the requested tolerance.</para>
            There are three main root bracketing methods. Each method
            is implemented in a <see cref="T:Numerics.NET.EquationSolvers.RootBracketingSolver" /> derived
            class as follows:
            <list type="table"><listheader><term>Method</term><description>Description</description></listheader><item><term><see cref="T:Numerics.NET.EquationSolvers.BisectionSolver">Bi-section method</see></term><description>Iteratively bisects the current bracketing
            interval and proceeds with the subinterval that still
            brackets the root.</description></item><item><term><see cref="T:Numerics.NET.EquationSolvers.RegulaFalsiSolver">Regula falsi method</see></term><description>Determines a new interval by approximating the
            target function by a line. The bracketing interval is
            divided at the point where this line crosses the X-axis.
            </description></item><item><term><see cref="T:Numerics.NET.EquationSolvers.DekkerBrentSolver">Dekker-Brent method</see></term><description>Uses a combination of bi-section and inverse
            quadratic interpolation. This is one of the fastest and
            most reliable methods.
            </description></item><item><term><see cref="T:Numerics.NET.EquationSolvers.RobustSolver">TOMS Algorithm 748</see></term><description>Uses a combination of bi-section, inverse
            quadratic, and inverse cubic interpolation. This is usually 
            the fastest and most reliable method.
            </description></item></list><para><see cref="T:Numerics.NET.EquationSolvers.RootBracketingSolver" /> is an abstract class
            that cannot be instantiated directly. Use one of the
            derived classes instead.</para></remarks>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.RootBracketingSolver" /> object.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.#ctor(System.Func{`0,`0},`0,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.RootBracketingSolver" /> object for the
            specified target function and convergence parameters.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="lowerBound">The lower bound of the
            bracketing interval.</param>
      <param name="upperBound">The upper bound of the
            bracketing interval.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.#ctor(System.Func{`0,`0},`0,`0,Numerics.NET.ConvergenceCriterion,`0)">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.EquationSolvers.RootBracketingSolver" /> object for the
            specified target function and convergence parameters.
            </summary>
      <param name="targetFunction">A delegate that represents a function of one variable delegate
            that specifies the target function.</param>
      <param name="convergenceCriterion">One of the
            <see cref="T:Numerics.NET.ConvergenceCriterion" /> values that specifies
            the criterion that is to be used in the convergence
            test for the algorithm.</param>
      <param name="tolerance">The tolerance to use when
            approximating the roots of the target function.</param>
      <param name="lowerBound">The lower bound of the
            bracketing interval.</param>
      <param name="upperBound">The upper bound of the
            bracketing interval.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The tolerance is less than zero.</exception>
    </member>
    <member name="P:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.CurrentLowerBoundValue">
      <summary>
            Gets or sets the value of the target function at the lower bound of the interval.
            </summary>
    </member>
    <member name="P:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.CurrentUpperBoundValue">
      <summary>
            Gets or sets the value of the target function at the upper bound of the interval.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.ErrorEvaluator">
      <summary>
            Returns the estimated error for testing whether the algorithm has converged.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.Iterated">
      <summary>
            Performs tasks after the iteration is completed, but before
            the status of the algorithm is finalized.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.OnInit">
      <summary>
            Performs initialization tasks when the algorithm is first run.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.ReportFailure(Numerics.NET.AlgorithmStatus)">
      <summary>
            Reports that the algoritm has failed. No further iterations will be performed.
            </summary>
      <param name="status">A <see cref="T:Numerics.NET.AlgorithmStatus" /> value that specifies
            the reason for the failure.</param>
      <remarks>The result and estimated error are set to the values returned by the
            <see cref="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.ValueEvaluator" /> and <see cref="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.ErrorEvaluator" /> properties.
            </remarks>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.ReportSuccess">
      <summary>
            Reports that the algoritm has succeeded. No further iterations will be performed.
            </summary>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.UpdateLowerBound(`0,`0)">
      <summary>
            Updates the lower bound and the corresponding value of the target function.
            </summary>
      <param name="value">The new lower bound.</param>
      <param name="functionValue">The function value at the new lower bound.</param>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.UpdateUpperBound(`0,`0)">
      <summary>
            Updates the upper bound and the corresponding value of the target function.
            </summary>
      <param name="value">The new upper bound.</param>
      <param name="functionValue">The function value at the new upper bound.</param>
    </member>
    <member name="M:Numerics.NET.EquationSolvers.Generic.RootBracketingSolver`1.ValueEvaluator">
      <summary>
            Returns the value to compare the estimated error to 
            when testing whether the algorithm has converged.
            </summary>
    </member>
    <member name="T:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1">
      <summary>
            Specifies the methods that must be implemented by a
            class to support complex LAPACK routines
            for general matrices.
            </summary>
      <remarks>
        <para>The Linear Algebra PACKage (LAPACK) is the de facto
            standard for more complex linear algebra problems. It complements
            the Basic Linear Algebra Subroutines (BLAS), which defines standards
            for low level vector and matrix operations.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band
            matrix A, in the same storage format as A.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The factorization has the form
               A = U<sup>H</sup> * U,  if UPLO = 'U', or
               A = L  * L<sup>H</sup>,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
             Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band
            matrix A, in the same storage format as A.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The factorization has the form
               A = U<sup>H</sup> * U,  if UPLO = 'U', or
               A = L  * L<sup>H</sup>,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
             Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite band matrix using
            the Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> computed by
            ZPBTRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="anorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            The 1-norm (or infinity-norm) of the Hermitian band matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
        </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Span{`0},System.Int32,`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite band matrix using the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPBTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TReal" /> array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="aNorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            The 1-norm (or infinity-norm) of the symmetric band matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>DPBCON</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskySolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a Hermitian
            positive definite band matrix A using the Cholesky factorization
            A = U<sup>H</sup> *U or A = L*L<sup>H</sup> computed by ZPBTRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>H</sup> *U or A = L*L<sup>H</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TComplex" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskySolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite band matrix A using the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPBTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TReal" /> array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TReal" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>This method corresponds to the LAPACK routine <c>?PBTRS</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes an LU factorization of a complex m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes an LU factorization of a complex m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUEstimateCondition(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{System.Int32},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a complex
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by ZGBTRF.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="anorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUEstimateCondition(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{System.Int32},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a complex
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by ZGBTRF.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="anorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{System.Int32},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations
               A * X = B,  A<sup>T</sup> * X = B,  or  A<sup>H</sup> * X = B
            with a general band matrix A using the LU factorization computed
            by ZGBTRF.</para>
      </summary>
      <param name="trans">
        <pre>
            Specifies the form of the system of equations.
            = 'N':  A * X = B     (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose)
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TComplex" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{System.Int32},System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations
               A * X = B,  A<sup>T</sup> * X = B,  or  A<sup>H</sup> * X = B
            with a general band matrix A using the LU factorization computed
            by ZGBTRF.</para>
      </summary>
      <param name="trans">
        <pre>
            Specifies the form of the system of equations.
            = 'N':  A * X = B     (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose)
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TComplex" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandTriangularSolve(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a triangular system of the form
               A * X = B  or  A<sup>T</sup> * X = B,
            where A is a triangular band matrix of order N, and B is an
            N-by NRHS matrix.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
      </param>
      <param name="trans">
        <pre>
            Specifies the form the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose = Transpose)
            </pre>
      </param>
      <param name="diag">
        <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TReal" /> array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TReal" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, the i-th diagonal element of A is zero,
                  indicating that the matrix is singular and the
                  solutions X have not been computed.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            A check is made to verify that A is nonsingular.
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>?TBTRS</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
            Factors a symmetric positive definite matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
            Factors a symmetric positive definite matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,`0,`0@,System.Int32@)">
      <summary>
            Estimates the reciprocal of the condition number of a factored hermitian matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="aNorm">The norm of the matrix.</param>
      <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{`0},System.Int32,`0,`0@,System.Int32@)">
      <summary>
            Estimates the reciprocal of the condition number of a factored hermitian matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="aNorm">The norm of the matrix.</param>
      <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyInvert(Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
            Computes the inverse of a factored hermitian matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyInvert(Numerics.NET.MatrixTriangle,System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
            Computes the inverse of a factored hermitian matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskySolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
            Solves a hermitian system of equations.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="nrhs">The number of right hand sides.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the components of the right-hand side(s).</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskySolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
            Solves a hermitian system of equations.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="nrhs">The number of right hand sides.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the components of the right-hand side(s).</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.EigenvalueDecompose(System.Char,System.Char,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes for an N-by-N complex non-symmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <pre>
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of are computed.
            </pre>
      </param>
      <param name="jobvr">
        <pre>
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A. N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="w">
        <pre>
            W is <typeparamref name="TComplex" /> array, dimension (N)
            W contains the computed eigenvalues.
            </pre>
      </param>
      <param name="vl">
        <pre>
            VL is <typeparamref name="TComplex" /> array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            u(j) = VL(:,j), the j-th column of VL.
            </pre>
      </param>
      <param name="ldvl">
        <pre>
            The leading dimension of the array VL.  LDVL &gt;= 1; if
            JOBVL = 'V', LDVL &gt;= N.
            </pre>
      </param>
      <param name="vr">
        <pre>
            VR is <typeparamref name="TComplex" /> array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            v(j) = VR(:,j), the j-th column of VR.
            </pre>
      </param>
      <param name="ldvr">
        <pre>
            The leading dimension of the array VR.  LDVR &gt;= 1; if
            JOBVR = 'V', LDVR &gt;= N.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements and i+1:N of W contain eigenvalues which have
                  converged.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**H * A = lambda(j) * u(j)**H
            where u(j)**H denotes the conjugate transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.EigenvalueDecompose(System.Char,System.Char,System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Span{`0},System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes for an N-by-N real non-symmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <pre>
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.
            </pre>
      </param>
      <param name="jobvr">
        <pre>
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A. N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="wr">
        <pre>
            WR is <typeparamref name="TReal" /> array, dimension (N)
            </pre>
      </param>
      <param name="wi">
        <pre>
            WI is <typeparamref name="TReal" /> array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.
            </pre>
      </param>
      <param name="vl">
        <pre>
            VL is <typeparamref name="TReal" /> array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).
            </pre>
      </param>
      <param name="ldvl">
        <pre>
            The leading dimension of the array VL.  LDVL &gt;= 1; if
            JOBVL = 'V', LDVL &gt;= N.
            </pre>
      </param>
      <param name="vr">
        <pre>
            VR is <typeparamref name="TReal" /> array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).
            </pre>
      </param>
      <param name="ldvr">
        <pre>
            The leading dimension of the array VR.  LDVR &gt;= 1; if
            JOBVR = 'V', LDVR &gt;= N.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**T * A = lambda(j) * u(j)**T
            where u(j)**T denotes the transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>?GEEV</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.GeneralizedEigenvalueDecompose(System.Char,System.Char,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Span{Numerics.NET.Complex{`0}},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes for a pair of N-by-N complex nonsymmetric matrices
            (A,B), the generalized eigenvalues, and optionally, the left and/or
            right generalized eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <code>
            JOBVL is CHARACTER*1
            = 'N':  do not compute the left generalized eigenvectors;
            = 'V':  compute the left generalized eigenvectors.
            </code>
      </param>
      <param name="jobvr">
        <code>
            JOBVR is CHARACTER*1
            = 'N':  do not compute the right generalized eigenvectors;
            = 'V':  compute the right generalized eigenvectors.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A, B, VL, and VR.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the matrix A in the pair (A,B).
            On exit, A has been overwritten.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB, N)
            On entry, the matrix B in the pair (A,B).
            On exit, B has been overwritten.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="alpha">
        <code>
            ALPHA is COMPLEX*16 array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is COMPLEX*16 array, dimension (N)
            On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the
            generalized eigenvalues.
            Note: the quotients ALPHA(j)/BETA(j) may easily over- or
            underflow, and BETA(j) may even be zero.  Thus, the user
            should avoid naively computing the ratio alpha/beta.
            However, ALPHA will be always less than and usually
            comparable with norm(A) in magnitude, and BETA always less
            than and usually comparable with norm(B).
            </code>
      </param>
      <param name="vl">
        <code>
            VL is COMPLEX*16 array, dimension (LDVL,N)
            If JOBVL = 'V', the left generalized eigenvectors u(j) are
            stored one after another in the columns of VL, in the same
            order as their eigenvalues.
            Each eigenvector is scaled so the largest component has
            abs(real part) + abs(imag. part) = 1.
            Not referenced if JOBVL = 'N'.
            </code>
      </param>
      <param name="ldvl">
        <code>
            LDVL is INTEGER
            The leading dimension of the matrix VL. LDVL &gt;= 1, and
            if JOBVL = 'V', LDVL &gt;= N.
            </code>
      </param>
      <param name="vr">
        <code>
            VR is COMPLEX*16 array, dimension (LDVR,N)
            If JOBVR = 'V', the right generalized eigenvectors v(j) are
            stored one after another in the columns of VR, in the same
            order as their eigenvalues.
            Each eigenvector is scaled so the largest component has
            abs(real part) + abs(imag. part) = 1.
            Not referenced if JOBVR = 'N'.
            </code>
      </param>
      <param name="ldvr">
        <code>
            LDVR is INTEGER
            The leading dimension of the matrix VR. LDVR &gt;= 1, and
            if JOBVR = 'V', LDVR &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            =1,...,N:
                  The QZ iteration failed.  No eigenvectors have been
                  calculated, but ALPHA(j) and BETA(j) should be
                  correct for j=INFO+1,...,N.
            &gt; N:  =N+1: other then QZ iteration failed in DHGEQZ,
                  =N+2: error return from DTGEVC.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            A generalized eigenvalue for a pair of matrices (A,B) is a scalar
            lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
            singular. It is usually represented as the pair (alpha,beta), as
            there is a reasonable interpretation for beta=0, and even for both
            being zero.
            The right generalized eigenvector v(j) corresponding to the
            generalized eigenvalue lambda(j) of (A,B) satisfies
                         A * v(j) = lambda(j) * B * v(j).
            The left generalized eigenvector u(j) corresponding to the
            generalized eigenvalues lambda(j) of (A,B) satisfies
                         u(j)**H * A = lambda(j) * u(j)**H * B
            where u(j)**H is the conjugate-transpose of u(j).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  April 2012</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.GeneralizedEigenvalueDecompose(System.Char,System.Char,System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Span{`0},System.Span{`0},System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes for a pair of N-by-N real nonsymmetric matrices (A,B)
            the generalized eigenvalues, and optionally, the left and/or right
            generalized eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <code>
            JOBVL is CHARACTER*1
            = 'N':  do not compute the left generalized eigenvectors;
            = 'V':  compute the left generalized eigenvectors.
            </code>
      </param>
      <param name="jobvr">
        <code>
            JOBVR is CHARACTER*1
            = 'N':  do not compute the right generalized eigenvectors;
            = 'V':  compute the right generalized eigenvectors.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A, B, VL, and VR.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the matrix A in the pair (A,B).
            On exit, A has been overwritten.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the matrix B in the pair (A,B).
            On exit, B has been overwritten.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="alphar">
        <code>
            ALPHAR is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="alphai">
        <code>
            ALPHAI is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
            be the generalized eigenvalues.  If ALPHAI(j) is zero, then
            the j-th eigenvalue is real; if positive, then the j-th and
            (j+1)-st eigenvalues are a complex conjugate pair, with
            ALPHAI(j+1) negative.
            Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
            may easily over- or underflow, and BETA(j) may even be zero.
            Thus, the user should avoid naively computing the ratio
            alpha/beta.  However, ALPHAR and ALPHAI will be always less
            than and usually comparable with norm(A) in magnitude, and
            BETA always less than and usually comparable with norm(B).
            </code>
      </param>
      <param name="vl">
        <code>
            VL is DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order as
            their eigenvalues. If the j-th eigenvalue is real, then
            u(j) = VL(:,j), the j-th column of VL. If the j-th and
            (j+1)-th eigenvalues form a complex conjugate pair, then
            u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
            Each eigenvector is scaled so the largest component has
            abs(real part)+abs(imag. part)=1.
            Not referenced if JOBVL = 'N'.
            </code>
      </param>
      <param name="ldvl">
        <code>
            LDVL is INTEGER
            The leading dimension of the matrix VL. LDVL &gt;= 1, and
            if JOBVL = 'V', LDVL &gt;= N.
            </code>
      </param>
      <param name="vr">
        <code>
            VR is DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order as
            their eigenvalues. If the j-th eigenvalue is real, then
            v(j) = VR(:,j), the j-th column of VR. If the j-th and
            (j+1)-th eigenvalues form a complex conjugate pair, then
            v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
            Each eigenvector is scaled so the largest component has
            abs(real part)+abs(imag. part)=1.
            Not referenced if JOBVR = 'N'.
            </code>
      </param>
      <param name="ldvr">
        <code>
            LDVR is INTEGER
            The leading dimension of the matrix VR. LDVR &gt;= 1, and
            if JOBVR = 'V', LDVR &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1,...,N:
                  The QZ iteration failed.  No eigenvectors have been
                  calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                  should be correct for j=INFO+1,...,N.
            &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.
                  =N+2: error return from DTGEVC.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            A generalized eigenvalue for a pair of matrices (A,B) is a scalar
            lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
            singular. It is usually represented as the pair (alpha,beta), as
            there is a reasonable interpretation for beta=0, and even for both
            being zero.
            The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
            of (A,B) satisfies
                             A * v(j) = lambda(j) * B * v(j).
            The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
            of (A,B) satisfies
                             u(j)**H * A  = lambda(j) * u(j)**H * B .
            where u(j)**H is the conjugate-transpose of u(j).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  April 2012</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.GeneralizedSchurDecompose(System.Char,System.Char,System.Char,System.Func{Numerics.NET.Complex{`0},Numerics.NET.Complex{`0},System.Boolean},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@,System.Span{Numerics.NET.Complex{`0}},System.Span{Numerics.NET.Complex{`0}},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
          <code>
            Computes for a pair of N-by-N complex nonsymmetric matrices
            (A,B), the generalized eigenvalues, the generalized complex Schur
            form (S, T), and optionally left and/or right Schur vectors (VSL
            and VSR).
            </code>
        </para>
      </summary>
      <param name="jobvsl">
        <code>
            JOBVSL is CHARACTER*1
            = 'N':  do not compute the left Schur vectors;
            = 'V':  compute the left Schur vectors.
            </code>
      </param>
      <param name="jobvsr">
        <code>
            JOBVSR is CHARACTER*1
            = 'N':  do not compute the right Schur vectors;
            = 'V':  compute the right Schur vectors.
            </code>
      </param>
      <param name="sort">
        <code>
            SORT is CHARACTER*1
            Specifies whether or not to order the eigenvalues on the
            diagonal of the generalized Schur form.
            = 'N':  Eigenvalues are not ordered;
            = 'S':  Eigenvalues are ordered (see SELCTG).
            </code>
      </param>
      <param name="selctg">
        <code>
            SELCTG is a LOGICAL FUNCTION of two COMPLEX*16 arguments
            SELCTG must be declared EXTERNAL in the calling subroutine.
            If SORT = 'N', SELCTG is not referenced.
            If SORT = 'S', SELCTG is used to select eigenvalues to sort
            to the top left of the Schur form.
            An eigenvalue ALPHA(j)/BETA(j) is selected if
            SELCTG(ALPHA(j),BETA(j)) is true.
            Note that a selected complex eigenvalue may no longer satisfy
            SELCTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since
            ordering may change the value of complex eigenvalues
            (especially if the eigenvalue is ill-conditioned), in this
            case INFO is set to N+2 (See INFO below).
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A, B, VSL, and VSR.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the first of the pair of matrices.
            On exit, A has been overwritten by its generalized Schur
            form S.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB, N)
            On entry, the second of the pair of matrices.
            On exit, B has been overwritten by its generalized Schur
            form T.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="sdim">
        <code>
            SDIM is INTEGER
            If SORT = 'N', SDIM = 0.
            If SORT = 'S', SDIM = number of eigenvalues (after sorting)
            for which SELCTG is true.
            </code>
      </param>
      <param name="alpha">
        <code>
            ALPHA is COMPLEX*16 array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is COMPLEX*16 array, dimension (N)
            On exit,  ALPHA(j)/BETA(j), j=1,...,N, will be the
            generalized eigenvalues.  ALPHA(j), j=1,...,N  and  BETA(j),
            j=1,...,N  are the diagonals of the complex Schur form (A,B)
            output by ZGGES. The  BETA(j) will be non-negative real.
            Note: the quotients ALPHA(j)/BETA(j) may easily over- or
            underflow, and BETA(j) may even be zero.  Thus, the user
            should avoid naively computing the ratio alpha/beta.
            However, ALPHA will be always less than and usually
            comparable with norm(A) in magnitude, and BETA always less
            than and usually comparable with norm(B).
            </code>
      </param>
      <param name="vsl">
        <code>
            VSL is COMPLEX*16 array, dimension (LDVSL,N)
            If JOBVSL = 'V', VSL will contain the left Schur vectors.
            Not referenced if JOBVSL = 'N'.
            </code>
      </param>
      <param name="ldvsl">
        <code>
            LDVSL is INTEGER
            The leading dimension of the matrix VSL. LDVSL &gt;= 1, and
            if JOBVSL = 'V', LDVSL &gt;= N.
            </code>
      </param>
      <param name="vsr">
        <code>
            VSR is COMPLEX*16 array, dimension (LDVSR,N)
            If JOBVSR = 'V', VSR will contain the right Schur vectors.
            Not referenced if JOBVSR = 'N'.
            </code>
      </param>
      <param name="ldvsr">
        <code>
            LDVSR is INTEGER
            The leading dimension of the matrix VSR. LDVSR &gt;= 1, and
            if JOBVSR = 'V', LDVSR &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            =1,...,N:
                  The QZ iteration failed.  (A,B) are not in Schur
                  form, but ALPHA(j) and BETA(j) should be correct for
                  j=INFO+1,...,N.
            &gt; N:  =N+1: other than QZ iteration failed in ZHGEQZ
                  =N+2: after reordering, roundoff changed values of
                        some complex eigenvalues so that leading
                        eigenvalues in the Generalized Schur form no
                        longer satisfy SELCTG=.TRUE.  This could also
                        be caused due to scaling.
                  =N+3: reordering failed in ZTGSEN.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            This gives the generalized Schur factorization
                    (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
            where (VSR)**H is the conjugate-transpose of VSR.
            Optionally, it also orders the eigenvalues so that a selected cluster
            of eigenvalues appears in the leading diagonal blocks of the upper
            triangular matrix S and the upper triangular matrix T. The leading
            columns of VSL and VSR then form an unitary basis for the
            corresponding left and right eigenspaces (deflating subspaces).
            (If only the generalized eigenvalues are needed, use the driver
            ZGGEV instead, which is faster.)
            A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
            or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
            usually represented as the pair (alpha,beta), as there is a
            reasonable interpretation for beta=0, and even for both being zero.
            A pair of matrices (S,T) is in generalized complex Schur form if S
            and T are upper triangular and, in addition, the diagonal elements
            of T are non-negative real numbers.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.GeneralizedSchurDecompose(System.Char,System.Char,System.Char,System.Func{`0,`0,`0,System.Boolean},System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Int32@,System.Span{`0},System.Span{`0},System.Span{`0},System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
          <code>
            Computes for a pair of N-by-N real nonsymmetric matrices (A,B),
            the generalized eigenvalues, the generalized real Schur form (S,T),
            optionally, the left and/or right matrices of Schur vectors (VSL and
            VSR).
            </code>
        </para>
      </summary>
      <param name="jobvsl">
        <code>
            JOBVSL is CHARACTER*1
            = 'N':  do not compute the left Schur vectors;
            = 'V':  compute the left Schur vectors.
            </code>
      </param>
      <param name="jobvsr">
        <code>
            JOBVSR is CHARACTER*1
            = 'N':  do not compute the right Schur vectors;
            = 'V':  compute the right Schur vectors.
            </code>
      </param>
      <param name="sort">
        <code>
            SORT is CHARACTER*1
            Specifies whether or not to order the eigenvalues on the
            diagonal of the generalized Schur form.
            = 'N':  Eigenvalues are not ordered;
            = 'S':  Eigenvalues are ordered (see SELCTG);
            </code>
      </param>
      <param name="selctg">
        <code>
            SELCTG is a LOGICAL FUNCTION of three DOUBLE PRECISION arguments
            SELCTG must be declared EXTERNAL in the calling subroutine.
            If SORT = 'N', SELCTG is not referenced.
            If SORT = 'S', SELCTG is used to select eigenvalues to sort
            to the top left of the Schur form.
            An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
            SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
            one of a complex conjugate pair of eigenvalues is selected,
            then both complex eigenvalues are selected.
            Note that in the ill-conditioned case, a selected complex
            eigenvalue may no longer satisfy SELCTG(ALPHAR(j),ALPHAI(j),
            BETA(j)) = .TRUE. after ordering. INFO is to be set to N+2
            in this case.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A, B, VSL, and VSR.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the first of the pair of matrices.
            On exit, A has been overwritten by its generalized Schur
            form S.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the second of the pair of matrices.
            On exit, B has been overwritten by its generalized Schur
            form T.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="sdim">
        <code>
            SDIM is INTEGER
            If SORT = 'N', SDIM = 0.
            If SORT = 'S', SDIM = number of eigenvalues (after sorting)
            for which SELCTG is true.  (Complex conjugate pairs for which
            SELCTG is true for either eigenvalue count as 2.)
            </code>
      </param>
      <param name="alphar">
        <code>
            ALPHAR is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="alphai">
        <code>
            ALPHAI is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
            be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
            and  BETA(j),j=1,...,N are the diagonals of the complex Schur
            form (S,T) that would result if the 2-by-2 diagonal blocks of
            the real Schur form of (A,B) were further reduced to
            triangular form using 2-by-2 complex unitary transformations.
            If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
            positive, then the j-th and (j+1)-st eigenvalues are a
            complex conjugate pair, with ALPHAI(j+1) negative.
            Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
            may easily over- or underflow, and BETA(j) may even be zero.
            Thus, the user should avoid naively computing the ratio.
            However, ALPHAR and ALPHAI will be always less than and
            usually comparable with norm(A) in magnitude, and BETA always
            less than and usually comparable with norm(B).
            </code>
      </param>
      <param name="vsl">
        <code>
            VSL is DOUBLE PRECISION array, dimension (LDVSL,N)
            If JOBVSL = 'V', VSL will contain the left Schur vectors.
            Not referenced if JOBVSL = 'N'.
            </code>
      </param>
      <param name="ldvsl">
        <code>
            LDVSL is INTEGER
            The leading dimension of the matrix VSL. LDVSL &gt;=1, and
            if JOBVSL = 'V', LDVSL &gt;= N.
            </code>
      </param>
      <param name="vsr">
        <code>
            VSR is DOUBLE PRECISION array, dimension (LDVSR,N)
            If JOBVSR = 'V', VSR will contain the right Schur vectors.
            Not referenced if JOBVSR = 'N'.
            </code>
      </param>
      <param name="ldvsr">
        <code>
            LDVSR is INTEGER
            The leading dimension of the matrix VSR. LDVSR &gt;= 1, and
            if JOBVSR = 'V', LDVSR &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1,...,N:
                  The QZ iteration failed.  (A,B) are not in Schur
                  form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
                  be correct for j=INFO+1,...,N.
            &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.
                  =N+2: after reordering, roundoff changed values of
                        some complex eigenvalues so that leading
                        eigenvalues in the Generalized Schur form no
                        longer satisfy SELCTG=.TRUE.  This could also
                        be caused due to scaling.
                  =N+3: reordering failed in DTGSEN.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            This gives the generalized Schur factorization
                     (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
            Optionally, it also orders the eigenvalues so that a selected cluster
            of eigenvalues appears in the leading diagonal blocks of the upper
            quasi-triangular matrix S and the upper triangular matrix T.The
            leading columns of VSL and VSR then form an orthonormal basis for the
            corresponding left and right eigenspaces (deflating subspaces).
            (If only the generalized eigenvalues are needed, use the driver
            DGGEV instead, which is faster.)
            A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
            or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
            usually represented as the pair (alpha,beta), as there is a
            reasonable interpretation for beta=0 or both being zero.
            A pair of matrices (S,T) is in generalized real Schur form if T is
            upper triangular with non-negative diagonal and S is block upper
            triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
            to real generalized eigenvalues, while 2-by-2 blocks of S will be
            "standardized" by making the corresponding elements of T have the
            form:
                    [  a  0  ]
                    [  0  b  ]
            and the pair of corresponding 2-by-2 blocks in S and T will have a
            complex conjugate pair of generalized eigenvalues.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.GeneralizedSingularValueDecompose(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{`0},System.Span{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the generalized singular value decomposition (GSVD)
            of an M-by-N complex matrix A and P-by-N complex matrix B:
                  U**H*A*Q = D1*( 0 R ),    V**H*B*Q = D2*( 0 R )
            where U, V and Q are unitary matrices.</para>
      </summary>
      <param name="jobu">
        <code>
            JOBU is CHARACTER*1
            = 'U':  Unitary matrix U is computed;
            = 'N':  U is not computed.
            </code>
      </param>
      <param name="jobv">
        <code>
            JOBV is CHARACTER*1
            = 'V':  Unitary matrix V is computed;
            = 'N':  V is not computed.
            </code>
      </param>
      <param name="jobq">
        <code>
            JOBQ is CHARACTER*1
            = 'Q':  Unitary matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N &gt;= 0.
            </code>
      </param>
      <param name="p">
        <code>
            P is INTEGER
            The number of rows of the matrix B.  P &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            </code>
      </param>
      <param name="l">
        <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose.
            K + L = effective numerical rank of (A**H,B**H)**H.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular matrix R, or part of R.
            See Purpose for details.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains part of the triangular matrix R if
            M-K-L &lt; 0.  See Purpose for details.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB &gt;= max(1,P).
            </code>
      </param>
      <param name="alpha">
        <code>
            ALPHA is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L &gt;= 0,
              ALPHA(K+1:K+L) = C,
              BETA(K+1:K+L)  = S,
            or if M-K-L &lt; 0,
              ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
              BETA(K+1:M) =S, BETA(M+1:K+L) =1
            and
              ALPHA(K+L+1:N) = 0
              BETA(K+L+1:N)  = 0
            </code>
      </param>
      <param name="u">
        <code>
            U is COMPLEX*16 array, dimension (LDU,M)
            If JOBU = 'U', U contains the M-by-M unitary matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
      </param>
      <param name="ldu">
        <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU &gt;= max(1,M) if
            JOBU = 'U'; LDU &gt;= 1 otherwise.
            </code>
      </param>
      <param name="v">
        <code>
            V is COMPLEX*16 array, dimension (LDV,P)
            If JOBV = 'V', V contains the P-by-P unitary matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
      </param>
      <param name="ldv">
        <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV &gt;= max(1,P) if
            JOBV = 'V'; LDV &gt;= 1 otherwise.
            </code>
      </param>
      <param name="q">
        <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the N-by-N unitary matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
      </param>
      <param name="ldq">
        <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ &gt;= max(1,N) if
            JOBQ = 'Q'; LDQ &gt;= 1 otherwise.
            </code>
      </param>
      <param name="ipiv">
        <code>
            IPIV is INTEGER array, dimension (N)
            On exit, IPIV stores the sorting information. More
            precisely, the following loop will sort ALPHA
               for I = K+1, min(M,K+L)
                   swap ALPHA(I) and ALPHA(IPIV(I))
               endfor
            such that ALPHA(1) &gt;= ALPHA(2) &gt;= ... &gt;= ALPHA(N).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = 1, the Jacobi-type procedure failed to
                  converge.  For further details, see subroutine ZTGSJA.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            Let K+L = the effective numerical rank of the
            matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
            triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
            matrices and of the following structures, respectively:
            If M-K-L &gt;= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                              K  L
                   D2 =   L ( 0  S )
                        P-L ( 0  0 )
                            N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 )
                        L (  0    0   R22 )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &lt; 0,
                              K M-K K+L-M
                   D1 =   K ( I  0    0   )
                        M-K ( 0  C    0   )
                                K M-K K+L-M
                   D2 =   M-K ( 0  S    0  )
                        K+L-M ( 0  0    I  )
                          P-L ( 0  0    0  )
                               N-K-L  K   M-K  K+L-M
              ( 0 R ) =     K ( 0    R11  R12  R13  )
                          M-K ( 0     0   R22  R23  )
                        K+L-M ( 0     0    0   R33  )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(M) ),
              S = diag( BETA(K+1),  ... , BETA(M) ),
              C**2 + S**2 = I.
              (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
              ( 0  R22 R23 )
              in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The routine computes C, S, R, and optionally the unitary
            transformation matrices U, V and Q.
            In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
            A and B implicitly gives the SVD of A*inv(B):
                                 A*inv(B) = U*(D1*inv(D2))*V**H.
            If ( A**H,B**H)**H has orthonormal columns, then the GSVD of A and B is also
            equal to the CS decomposition of A and B. Furthermore, the GSVD can
            be used to derive the solution of the eigenvalue problem:
                                 A**H*A x = lambda* B**H*B x.
            In some literature, the GSVD of A and B is presented in the form
                             U**H*A*X = ( 0 D1 ),   V**H*B*X = ( 0 D2 )
            where U and V are orthogonal and X is nonsingular, and D1 and D2 are
            ``diagonal''.  The former GSVD form can be converted to the latter
            form by taking the nonsingular matrix X as
                                  X = Q*(  I   0    )
                                        (  0 inv(R) )
            </code>
        </para>
        <h4> Contributors:</h4>
        <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
        <h4> Further Details:</h4>
        <para>
             ZGGSVD3 replaces the deprecated subroutine ZGGSVD.
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  August 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.GeneralizedSingularValueDecompose(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Span{`0},System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the generalized singular value decomposition (GSVD)
            of an M-by-N complex matrix A and P-by-N complex matrix B:
                  U**H*A*Q = D1*( 0 R ),    V**H*B*Q = D2*( 0 R )
            where U, V and Q are unitary matrices.</para>
      </summary>
      <param name="jobu">
        <code>
            JOBU is CHARACTER*1
            = 'U':  Unitary matrix U is computed;
            = 'N':  U is not computed.
            </code>
      </param>
      <param name="jobv">
        <code>
            JOBV is CHARACTER*1
            = 'V':  Unitary matrix V is computed;
            = 'N':  V is not computed.
            </code>
      </param>
      <param name="jobq">
        <code>
            JOBQ is CHARACTER*1
            = 'Q':  Unitary matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N &gt;= 0.
            </code>
      </param>
      <param name="p">
        <code>
            P is INTEGER
            The number of rows of the matrix B.  P &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            </code>
      </param>
      <param name="l">
        <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose.
            K + L = effective numerical rank of (A**H,B**H)**H.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular matrix R, or part of R.
            See Purpose for details.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains part of the triangular matrix R if
            M-K-L &lt; 0.  See Purpose for details.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB &gt;= max(1,P).
            </code>
      </param>
      <param name="alpha">
        <code>
            ALPHA is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L &gt;= 0,
              ALPHA(K+1:K+L) = C,
              BETA(K+1:K+L)  = S,
            or if M-K-L &lt; 0,
              ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
              BETA(K+1:M) =S, BETA(M+1:K+L) =1
            and
              ALPHA(K+L+1:N) = 0
              BETA(K+L+1:N)  = 0
            </code>
      </param>
      <param name="u">
        <code>
            U is COMPLEX*16 array, dimension (LDU,M)
            If JOBU = 'U', U contains the M-by-M unitary matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
      </param>
      <param name="ldu">
        <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU &gt;= max(1,M) if
            JOBU = 'U'; LDU &gt;= 1 otherwise.
            </code>
      </param>
      <param name="v">
        <code>
            V is COMPLEX*16 array, dimension (LDV,P)
            If JOBV = 'V', V contains the P-by-P unitary matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
      </param>
      <param name="ldv">
        <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV &gt;= max(1,P) if
            JOBV = 'V'; LDV &gt;= 1 otherwise.
            </code>
      </param>
      <param name="q">
        <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the N-by-N unitary matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
      </param>
      <param name="ldq">
        <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ &gt;= max(1,N) if
            JOBQ = 'Q'; LDQ &gt;= 1 otherwise.
            </code>
      </param>
      <param name="ipiv">
        <code>
            IPIV is INTEGER array, dimension (N)
            On exit, IPIV stores the sorting information. More
            precisely, the following loop will sort ALPHA
               for I = K+1, min(M,K+L)
                   swap ALPHA(I) and ALPHA(IPIV(I))
               endfor
            such that ALPHA(1) &gt;= ALPHA(2) &gt;= ... &gt;= ALPHA(N).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = 1, the Jacobi-type procedure failed to
                  converge.  For further details, see subroutine ZTGSJA.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            Let K+L = the effective numerical rank of the
            matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
            triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
            matrices and of the following structures, respectively:
            If M-K-L &gt;= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                              K  L
                   D2 =   L ( 0  S )
                        P-L ( 0  0 )
                            N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 )
                        L (  0    0   R22 )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &lt; 0,
                              K M-K K+L-M
                   D1 =   K ( I  0    0   )
                        M-K ( 0  C    0   )
                                K M-K K+L-M
                   D2 =   M-K ( 0  S    0  )
                        K+L-M ( 0  0    I  )
                          P-L ( 0  0    0  )
                               N-K-L  K   M-K  K+L-M
              ( 0 R ) =     K ( 0    R11  R12  R13  )
                          M-K ( 0     0   R22  R23  )
                        K+L-M ( 0     0    0   R33  )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(M) ),
              S = diag( BETA(K+1),  ... , BETA(M) ),
              C**2 + S**2 = I.
              (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
              ( 0  R22 R23 )
              in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The routine computes C, S, R, and optionally the unitary
            transformation matrices U, V and Q.
            In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
            A and B implicitly gives the SVD of A*inv(B):
                                 A*inv(B) = U*(D1*inv(D2))*V**H.
            If ( A**H,B**H)**H has orthonormal columns, then the GSVD of A and B is also
            equal to the CS decomposition of A and B. Furthermore, the GSVD can
            be used to derive the solution of the eigenvalue problem:
                                 A**H*A x = lambda* B**H*B x.
            In some literature, the GSVD of A and B is presented in the form
                             U**H*A*X = ( 0 D1 ),   V**H*B*X = ( 0 D2 )
            where U and V are orthogonal and X is nonsingular, and D1 and D2 are
            ``diagonal''.  The former GSVD form can be converted to the latter
            form by taking the nonsingular matrix X as
                                  X = Q*(  I   0    )
                                        (  0 inv(R) )
            </code>
        </para>
        <h4> Contributors:</h4>
        <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
        <h4> Further Details:</h4>
        <para>
             ZGGSVD3 replaces the deprecated subroutine ZGGSVD.
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  August 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the factorization of a complex Hermitian matrix A
            using the Bunch-Kaufman diagonal pivoting method.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The form of the
            factorization is
               A = U*D*U<sup>H</sup>  or  A = L*D*L<sup>H</sup>
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is Hermitian and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            If UPLO = 'U', then A = U*D*U<sup>H</sup>, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L<sup>H</sup>, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </pre>
        </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianEigenvalueDecompose(System.Char,Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{`0},System.Int32@)">
      <summary>
        <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            complex Hermitian matrix A.</para>
      </summary>
      <param name="jobz">
        <pre>
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </pre>
      </param>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="w">
        <pre>
            W is <typeparamref name="TReal" /> array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the sub-matrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
             Modified description of INFO. Sven, 16 Feb 05.
            </para>
        <h4> Contributors:</h4>
        <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{System.Int32},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a complex
            Hermitian matrix A using the factorization A = U*D*U<sup>H</sup> or
            A = L*D*L<sup>H</sup> computed by ZHETRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
      </param>
      <param name="anorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            The 1-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
        </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianGeneralizedEigenvalueDecompose(System.Int32,System.Char,Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{`0},System.Int32@)">
      <summary>
        <para>
            Computes all the eigenvalues, and optionally, the eigenvectors
            of a complex generalized Hermitian-definite eigenproblem, of the form
            A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.</para>
      </summary>
      <param name="itype">
        <code>
            ITYPE is INTEGER
            Specifies the problem type to be solved:
            = 1:  A*x = (lambda)*B*x
            = 2:  A*B*x = (lambda)*x
            = 3:  B*A*x = (lambda)*x
            </code>
      </param>
      <param name="jobz">
        <code>
            JOBZ is CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </code>
      </param>
      <param name="uplo">
        <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangles of A and B are stored;
            = 'L':  Lower triangles of A and B are stored.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A and B.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            matrix Z of eigenvectors.  The eigenvectors are normalized
            as follows:
            if ITYPE = 1 or 2, Z**H*B*Z = I;
            if ITYPE = 3, Z**H*inv(B)*Z = I.
            If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
            or the lower triangle (if UPLO='L') of A, including the
            diagonal, is destroyed.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB, N)
            On entry, the Hermitian matrix B.  If UPLO = 'U', the
            leading N-by-N upper triangular part of B contains the
            upper triangular part of the matrix B.  If UPLO = 'L',
            the leading N-by-N lower triangular part of B contains
            the lower triangular part of the matrix B.
            On exit, if INFO &lt;= N, the part of B containing the matrix is
            overwritten by the triangular factor U or L from the Cholesky
            factorization B = U**H*U or B = L*L**H.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="w">
        <code>
            W is DOUBLE PRECISION array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  ZPOTRF or ZHEEVD returned an error code:
               &lt;= N:  if INFO = i and JOBZ = 'N', then the algorithm
                      failed to converge; i off-diagonal elements of an
                      intermediate tridiagonal form did not converge to
                      zero;
                      if INFO = i and JOBZ = 'V', then the algorithm
                      failed to compute an eigenvalue while working on
                      the submatrix lying in rows and columns INFO/(N+1)
                      through mod(INFO,N+1);
               &gt; N:   if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading
                      minor of order i of B is not positive definite.
                      The factorization of B could not be completed and
                      no eigenvalues or eigenvectors were computed.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            Here A and
            B are assumed to be Hermitian and B is also positive definite.
            If eigenvectors are desired, it uses a divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
        </para>
        <h4> Further Details:</h4>
        <para>
          <code>
            Modified so that no backsubstitution is performed if ZHEEVD fails to
            converge (NEIG in old code could be greater than N causing out of
            bounds reference to A - reported by Ralf Meyer).  Also corrected the
            description of INFO and the test on ITYPE. Sven, 16 Feb 05.
            </code>
        </para>
        <h4> Contributors:</h4>
        <para>
                Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianInvert(Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the inverse of a complex Hermitian indefinite matrix
            A using the factorization A = U*D*U<sup>H</sup> or A = L*D*L<sup>H</sup> computed by
            ZHETRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by ZHETRF.
            On exit, if INFO = 0, the (Hermitian) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            &gt; 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </pre>
      </param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianSolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{System.Int32},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a complex
            Hermitian matrix A using the factorization A = U*D*U<sup>H</sup> or
            A = L*D*L<sup>H</sup> computed by ZHETRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TComplex" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LQDecompose(System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Computes an LQ factorization of a complex M-by-N matrix A:
            A = L * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &lt;= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k)**H . . . H(2)**H H(1)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
            A(i,i+1:n), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LQDecompose(System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32@)">
      <summary>
        <para>
            Computes an LQ factorization of a complex M-by-N matrix A:
            A = L * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &lt;= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k)**H . . . H(2)**H H(1)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
            A(i,i+1:n), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LQOrthogonalMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{`0},System.Int32,System.ReadOnlySpan{`0},System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGELQF in the first k rows of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(2) H(1)
            as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LQUnitaryMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k)**H .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGELQF in the first k rows of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGELQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(2)**H H(1)**H
            as returned by ZGELQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUDecompose(System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>ZGETRF computes an LU decomposition of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
        <para>
            The decomposition has the form</para>
        <para>
          <center>A = P * L * U</center>.</para>
        <para>where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m &gt; n), and U is upper
            triangular (upper trapezoidal if m &lt; n).
            </para>
        <para>
            This is the right-looking Level 3 BLAS version of the algorithm.
            </para>
      </summary>
      <param name="m">An integer specifying the number of rows
            of the matrix <paramref name="a" />. Must be greater than
            or equal to zero.</param>
      <param name="n">An integer specifying the number of
            columns of the matrix <paramref name="a" />. Must be
            greater than or equal to zero.
            </param>
      <param name="a">complex array specifying the
            <paramref name="m" />-by-<paramref name="n" /> matrix
            to be factored. On exit, the factors L and U from the
            decomposition A = P*L*U; the unit diagonal elements of
            L are not stored.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="ipiv">Integer array of length
            min(<paramref name="m" />,<paramref name="n" />) that
            will hold the pivot indexes. Row <i>i</i> of the
            matrix was interchanged with row
            <paramref name="ipiv" />[<i>i</i>].</param>
      <param name="info">Reference to an integer containing a
            result code. Zero indicates success. Greater than zero
            indicates U(i,i) is exactly zero. The decomposition
            has been completed, but the factor U is exactly
            singular, and division by zero will occur if it is used
            to solve a system of equations.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUDecompose(System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>ZGETRF computes an LU decomposition of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
        <para>
            The decomposition has the form</para>
        <para>
          <center>A = P * L * U</center>.</para>
        <para>where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m &gt; n), and U is upper
            triangular (upper trapezoidal if m &lt; n).
            </para>
        <para>
            This is the right-looking Level 3 BLAS version of the algorithm.
            </para>
      </summary>
      <param name="m">An integer specifying the number of rows
            of the matrix <paramref name="a" />. Must be greater than
            or equal to zero.</param>
      <param name="n">An integer specifying the number of
            columns of the matrix <paramref name="a" />. Must be
            greater than or equal to zero.
            </param>
      <param name="a">complex array specifying the
            <paramref name="m" />-by-<paramref name="n" /> matrix
            to be factored. On exit, the factors L and U from the
            decomposition A = P*L*U; the unit diagonal elements of
            L are not stored.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="ipiv">Integer array of length
            min(<paramref name="m" />,<paramref name="n" />) that
            will hold the pivot indexes. Row <i>i</i> of the
            matrix was interchanged with row
            <paramref name="ipiv" />[<i>i</i>].</param>
      <param name="info">Reference to an integer containing a
            result code. Zero indicates success. Greater than zero
            indicates U(i,i) is exactly zero. The decomposition
            has been completed, but the factor U is exactly
            singular, and division by zero will occur if it is used
            to solve a system of equations.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUEstimateCondition(Numerics.NET.MatrixNorm,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,`0,`0@,System.Int32@)">
      <summary>
             ZGECON estimates the reciprocal of the condition number of a general
             real matrix A, inthis. either the 1-norm or the infinity-norm, using
             the LU decomposition computed by ZGETRF.
            
             An estimate is obtained for norm(inv(A)), and the reciprocal of the
             condition number is computed as
                RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            
             Arguments
             =========
            
             NORM    (input) CHARACTER*1
             Specifies whether the 1-norm condition number or the
             infinity-norm condition number is required:
                = '1' or 'O':  1-norm;
                = 'I':         Infinity-norm.
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             A       (input) DOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             ANORM   (input) DOUBLE PRECISION
             If NORM = '1' or 'O', the 1-norm of the original matrix A.
             If NORM = 'I', the infinity-norm of the original matrix A.
            
             RCOND   (output) DOUBLE PRECISION
             The reciprocal of the condition number of the matrix A,
             computed as RCOND = 1/(norm(A) * norm(inv(A))).
            
             WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
            
             IWORK   (workspace) INTEGER array, dimension (N)
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
            
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUEstimateCondition(Numerics.NET.MatrixNorm,System.Int32,System.Span{`0},System.Int32,`0,`0@,System.Int32@)">
      <summary>
             ZGECON estimates the reciprocal of the condition number of a general
             real matrix A, inthis. either the 1-norm or the infinity-norm, using
             the LU decomposition computed by ZGETRF.
            
             An estimate is obtained for norm(inv(A)), and the reciprocal of the
             condition number is computed as
                RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            
             Arguments
             =========
            
             NORM    (input) CHARACTER*1
             Specifies whether the 1-norm condition number or the
             infinity-norm condition number is required:
                = '1' or 'O':  1-norm;
                = 'I':         Infinity-norm.
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             A       (input) DOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             ANORM   (input) DOUBLE PRECISION
             If NORM = '1' or 'O', the 1-norm of the original matrix A.
             If NORM = 'I', the infinity-norm of the original matrix A.
            
             RCOND   (output) DOUBLE PRECISION
             The reciprocal of the condition number of the matrix A,
             computed as RCOND = 1/(norm(A) * norm(inv(A))).
            
             WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
            
             IWORK   (workspace) INTEGER array, dimension (N)
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
            
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUInvert(System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
             ZGETRI computes the inverse of a matrix using the LU decomposition
             computed by ZGETRF.
            
             This method inverts U and then computes inv(A) by solving the system
             inv(A)*L = inv(U) for inv(A).
            
             Arguments
             =========
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the factors L and U from the decomposition
             A = P*L*U as computed by ZGETRF.
             On exit, if INFO = 0, the inverse of the original matrix A.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO =0, then WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK &gt;= Max(1,N).
             For optimal performance LWORK &gt;= N*NB, where NB is
             the optimal blocksize returned by ILAENV.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
             &gt; 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
             singular and its inverse could not be computed.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUInvert(System.Int32,System.Span{`0},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
             ZGETRI computes the inverse of a matrix using the LU decomposition
             computed by ZGETRF.
            
             This method inverts U and then computes inv(A) by solving the system
             inv(A)*L = inv(U) for inv(A).
            
             Arguments
             =========
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the factors L and U from the decomposition
             A = P*L*U as computed by ZGETRF.
             On exit, if INFO = 0, the inverse of the original matrix A.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO =0, then WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK &gt;= Max(1,N).
             For optimal performance LWORK &gt;= N*NB, where NB is
             the optimal blocksize returned by ILAENV.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
             &gt; 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
             singular and its inverse could not be computed.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{System.Int32},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
             ZGETRS solves a system of linear equations
                A * X = B  or  A' * X = B
             with a general N-by-N matrix A using the LU decomposition computed
             by ZGETRF.
            
             Arguments
             =========
            
             TRANS   (input) CHARACTER*1
             Specifies the form of the system of equations:
                = 'N':  A * X = B  (No transpose)
                = TransposeOperation.Transpose:  A'* X = B  (Transpose)
                = 'C':  A'* X = B  (Conjugate transpose = Transpose)
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             NRHS    (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS &gt;= 0.
            
             A       (input) DOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the right hand side matrix B.
             On exit, the solution matrix X.
            
             LDB     (input) INTEGER
             The leading dimension of the array B.  LDB &gt;= Max(1,N).
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
             =====================================================================
            
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{System.Int32},System.Span{`0},System.Int32,System.Int32@)">
      <summary>
             ZGETRS solves a system of linear equations
                A * X = B  or  A' * X = B
             with a general N-by-N matrix A using the LU decomposition computed
             by ZGETRF.
            
             Arguments
             =========
            
             TRANS   (input) CHARACTER*1
             Specifies the form of the system of equations:
                = 'N':  A * X = B  (No transpose)
                = TransposeOperation.Transpose:  A'* X = B  (Transpose)
                = 'C':  A'* X = B  (Conjugate transpose = Transpose)
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             NRHS    (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS &gt;= 0.
            
             A       (input) DOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the right hand side matrix B.
             On exit, the solution matrix X.
            
             LDB     (input) INTEGER
             The leading dimension of the array B.  LDB &gt;= Max(1,N).
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
             =====================================================================
            
            </summary>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.Name">
      <summary>
            Gets the name of the implementation.
            </summary>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.Platform">
      <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QLDecompose(System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Computes a QL factorization of a complex M-by-N matrix A:
            A = Q * L.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &gt;= n, the lower triangle of the subarray
            A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
            if m &lt;= n, the elements on and below the (n-m)-th
            superdiagonal contain the M-by-N lower trapezoidal matrix L;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of elementary reflectors
            (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k) . . . H(2) H(1), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
            A(1:m-k+i-1,n-k+i), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QLDecompose(System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32@)">
      <summary>
        <para>
            Computes a QL factorization of a complex M-by-N matrix A:
            A = Q * L.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &gt;= n, the lower triangle of the subarray
            A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
            if m &lt;= n, the elements on and below the (n-m)-th
            superdiagonal contain the M-by-N lower trapezoidal matrix L;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of elementary reflectors
            (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k) . . . H(2) H(1), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
            A(1:m-k+i-1,n-k+i), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QLOrthogonalMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{`0},System.Int32,System.ReadOnlySpan{`0},System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQLF in the last k columns of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQLF.
            </code>
      </param>
      <param name="c">
        <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(2) H(1)
            as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QLUnitaryMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Transpose, apply Q**H.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQLF in the last k columns of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQLF.
            </code>
      </param>
      <param name="c">
        <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(2) H(1)
            as returned by ZGEQLF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRDecompose(System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32@)">
      <summary>
             ZGEQRF computes a QR decomposition of a real M-by-N matrix A:
             A = Q * R.
            
             Arguments
             =========
            
             M       (input) INTEGER
             The number of rows of the matrix A.  M &gt;= 0.
            
             N       (input) INTEGER
             The number of columns of the matrix A.  N &gt;= 0.
            
             A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the elements on and above the diagonal of the array
             contain the min(M,N)-by-N upper trapezoidal matrix R (R is
             upper triangular if m &gt;= n); the elements below the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of min(m,n) elementary reflectors (see Further
             Zetails).
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= max(1,M).
            
             TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Zetails).
            
             WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK &gt;= max(1,N).
             For optimum performance LWORK &gt;= N*NB, where NB is
             the optimal blocksize.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
             Further Zetails
             ===============
            
             The matrix Q is represented as a product of elementary reflectors
            
                Q = H(1) H(2) . . . H(k), where k = min(m,n).
            
             Each H(i) has the form
            
                H(i) = I - tau * v * v'
            
             where tau is a real scalar, and v is a real vector with
             v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit inthis. A(i+1:m,i),
             and tau inthis. TAU(i).
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRDecompose(System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{System.Int32},System.Span{`0},System.Int32@)">
      <summary>
        <para>
            Computes a QR factorization with column pivoting of a
            matrix A:  A*P = Q*R  using Level 3 BLAS.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A. M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper trapezoidal matrix R; the elements below
            the diagonal, together with the array TAU, represent the
            orthogonal matrix Q as a product of min(M,N) elementary
            reflectors.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A. LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="jpvt">
        <pre>
            Dimension (N)
            On entry, if JPVT(J).ne.0, the J-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(J)=0,
            the J-th column of A is a free column.
            On exit, if JPVT(J)=K, then the J-th column of A*P was the
            the K-th column of A.
            </pre>
      </param>
      <param name="tau">
        <pre>
            TAU is <typeparamref name="TReal" /> array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0: successful exit.
            &lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </pre>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <pre>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real/complex scalar, and v is a real/complex vector
            with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
            A(i+1:m,i), and tau in TAU(i).
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
        <para>This method corresponds to the LAPACK routine <c>DGEQP3</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRDecompose(System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32@)">
      <summary>
             ZGEQRF computes a QR decomposition of a real M-by-N matrix A:
             A = Q * R.
            
             Arguments
             =========
            
             M       (input) INTEGER
             The number of rows of the matrix A.  M &gt;= 0.
            
             N       (input) INTEGER
             The number of columns of the matrix A.  N &gt;= 0.
            
             A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the elements on and above the diagonal of the array
             contain the min(M,N)-by-N upper trapezoidal matrix R (R is
             upper triangular if m &gt;= n); the elements below the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of min(m,n) elementary reflectors (see Further
             Zetails).
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= max(1,M).
            
             TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Zetails).
            
             WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK &gt;= max(1,N).
             For optimum performance LWORK &gt;= N*NB, where NB is
             the optimal blocksize.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
             Further Zetails
             ===============
            
             The matrix Q is represented as a product of elementary reflectors
            
                Q = H(1) H(2) . . . H(k), where k = min(m,n).
            
             Each H(i) has the form
            
                H(i) = I - tau * v * v'
            
             where tau is a real scalar, and v is a real vector with
             v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit inthis. A(i+1:m,i),
             and tau inthis. TAU(i).
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QROrthogonalMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{`0},System.Int32,System.ReadOnlySpan{`0},System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q<sup>T</sup> * C       C * Q<sup>T</sup>
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
      </summary>
      <param name="side">
        <pre>
            = 'L': apply Q or Q<sup>T</sup> from the Left;
            = 'R': apply Q or Q<sup>T</sup> from the Right.
            </pre>
      </param>
      <param name="trans">
        <pre>
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q<sup>T</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the matrix C. M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix C. N &gt;= 0.
            </pre>
      </param>
      <param name="k">
        <pre>
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="tau">
        <pre>
            TAU is <typeparamref name="TReal" /> array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is <typeparamref name="TReal" /> array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q<sup>T</sup>*C or C*Q<sup>T</sup> or C*Q.
            </pre>
      </param>
      <param name="ldc">
        <pre>
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            . . H(k)
            as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>?ORMQR</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRUnitaryMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q<sup>H</sup> * C       C * Q<sup>H</sup>
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
      </summary>
      <param name="side">
        <pre>
            = 'L': apply Q or Q<sup>H</sup> from the Left;
            = 'R': apply Q or Q<sup>H</sup> from the Right.
            </pre>
      </param>
      <param name="trans">
        <pre>
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q<sup>H</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the matrix C. M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix C. N &gt;= 0.
            </pre>
      </param>
      <param name="k">
        <pre>
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQRF in the first k columns of its array argument A.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="tau">
        <pre>
            TAU is <typeparamref name="TComplex" /> array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQRF.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is <typeparamref name="TComplex" /> array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q<sup>H</sup>*C or C*Q<sup>H</sup> or C*Q.
            </pre>
      </param>
      <param name="ldc">
        <pre>
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            . . H(k)
            as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </pre>
        </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.RQDecompose(System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Computes an RQ factorization of a complex M-by-N matrix A:
            A = R * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &lt;= n, the upper triangle of the subarray
            A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
            if m &gt;= n, the elements on and above the (m-n)-th subdiagonal
            contain the M-by-N upper trapezoidal matrix R;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of min(m,n) elementary
            reflectors (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1)**H H(2)**H . . . H(k)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
            exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.RQDecompose(System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32@)">
      <summary>
        <para>
            Computes an RQ factorization of a complex M-by-N matrix A:
            A = R * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &lt;= n, the upper triangle of the subarray
            A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
            if m &gt;= n, the elements on and above the (m-n)-th subdiagonal
            contain the M-by-N upper trapezoidal matrix R;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of min(m,n) elementary
            reflectors (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1)**H H(2)**H . . . H(k)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
            exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.RQOrthogonalMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{`0},System.Int32,System.ReadOnlySpan{`0},System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGERQF in the last k rows of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGERQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(k)
            as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.RQUnitaryMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1)**H H(2)**H .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Transpose, apply Q**H.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGERQF in the last k rows of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGERQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(k)**H
            as returned by ZGERQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SchurDecompose(System.Char,System.Char,System.Func{Numerics.NET.Complex{`0},System.Boolean},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@,System.Span{Numerics.NET.Complex{`0}},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
          <code>
            Computes for an N-by-N complex nonsymmetric matrix A, the
            eigenvalues, the Schur form T, and, optionally, the matrix of Schur
            vectors Z.
            </code>
        </para>
      </summary>
      <param name="jobvs">
        <code>
            JOBVS is CHARACTER*1
            = 'N': Schur vectors are not computed;
            = 'V': Schur vectors are computed.
            </code>
      </param>
      <param name="sort">
        <code>
            SORT is CHARACTER*1
            Specifies whether or not to order the eigenvalues on the
            diagonal of the Schur form.
            = 'N': Eigenvalues are not ordered:
            = 'S': Eigenvalues are ordered (see SELECT).
            </code>
      </param>
      <param name="select">
        <code>
            SELECT is a LOGICAL FUNCTION of one COMPLEX*16 argument
            SELECT must be declared EXTERNAL in the calling subroutine.
            If SORT = 'S', SELECT is used to select eigenvalues to order
            to the top left of the Schur form.
            IF SORT = 'N', SELECT is not referenced.
            The eigenvalue W(j) is selected if SELECT(W(j)) is true.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrix A. N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten by its Schur form T.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="sdim">
        <code>
            SDIM is INTEGER
            If SORT = 'N', SDIM = 0.
            If SORT = 'S', SDIM = number of eigenvalues for which
                           SELECT is true.
            </code>
      </param>
      <param name="w">
        <code>
            W is COMPLEX*16 array, dimension (N)
            W contains the computed eigenvalues, in the same order that
            they appear on the diagonal of the output Schur form T.
            </code>
      </param>
      <param name="vs">
        <code>
            VS is COMPLEX*16 array, dimension (LDVS,N)
            If JOBVS = 'V', VS contains the unitary matrix Z of Schur
            vectors.
            If JOBVS = 'N', VS is not referenced.
            </code>
      </param>
      <param name="ldvs">
        <code>
            LDVS is INTEGER
            The leading dimension of the array VS.  LDVS &gt;= 1; if
            JOBVS = 'V', LDVS &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value.
            &gt; 0: if INFO = i, and i is
                 &lt;= N:  the QR algorithm failed to compute all the
                        eigenvalues; elements 1:ILO-1 and i+1:N of W
                        contain those eigenvalues which have converged;
                        if JOBVS = 'V', VS contains the matrix which
                        reduces A to its partially converged Schur form.
                 = N+1: the eigenvalues could not be reordered because
                        some eigenvalues were too close to separate (the
                        problem is very ill-conditioned);
                 = N+2: after reordering, roundoff changed values of
                        some complex eigenvalues so that leading
                        eigenvalues in the Schur form no longer satisfy
                        SELECT = .TRUE..  This could also be caused by
                        underflow due to scaling.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            This gives the Schur factorization A = Z*T*(Z**H).
            Optionally, it also orders the eigenvalues on the diagonal of the
            Schur form so that selected eigenvalues are at the top left.
            The leading columns of Z then form an orthonormal basis for the
            invariant subspace corresponding to the selected eigenvalues.
            A complex matrix is in Schur form if it is upper triangular.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SchurDecompose(System.Char,System.Char,System.Func{`0,`0,System.Boolean},System.Int32,System.Span{`0},System.Int32,System.Int32@,System.Span{`0},System.Span{`0},System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
          <code>
            Computes for an N-by-N real nonsymmetric matrix A, the
            eigenvalues, the real Schur form T, and, optionally, the matrix of
            Schur vectors Z.
            </code>
        </para>
      </summary>
      <param name="jobvs">
        <code>
            JOBVS is CHARACTER*1
            = 'N': Schur vectors are not computed;
            = 'V': Schur vectors are computed.
            </code>
      </param>
      <param name="sort">
        <code>
            SORT is CHARACTER*1
            Specifies whether or not to order the eigenvalues on the
            diagonal of the Schur form.
            = 'N': Eigenvalues are not ordered;
            = 'S': Eigenvalues are ordered (see SELECT).
            </code>
      </param>
      <param name="select">
        <code>
            SELECT is a LOGICAL FUNCTION of two DOUBLE PRECISION arguments
            SELECT must be declared EXTERNAL in the calling subroutine.
            If SORT = 'S', SELECT is used to select eigenvalues to sort
            to the top left of the Schur form.
            If SORT = 'N', SELECT is not referenced.
            An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
            SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex
            conjugate pair of eigenvalues is selected, then both complex
            eigenvalues are selected.
            Note that a selected complex eigenvalue may no longer
            satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
            ordering may change the value of complex eigenvalues
            (especially if the eigenvalue is ill-conditioned); in this
            case INFO is set to N+2 (see INFO below).
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrix A. N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten by its real Schur form T.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="sdim">
        <code>
            SDIM is INTEGER
            If SORT = 'N', SDIM = 0.
            If SORT = 'S', SDIM = number of eigenvalues (after sorting)
                           for which SELECT is true. (Complex conjugate
                           pairs for which SELECT is true for either
                           eigenvalue count as 2.)
            </code>
      </param>
      <param name="wr">
        <code>
            WR is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="wi">
        <code>
            WI is DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues in the same order
            that they appear on the diagonal of the output Schur form T.
            Complex conjugate pairs of eigenvalues will appear
            consecutively with the eigenvalue having the positive
            imaginary part first.
            </code>
      </param>
      <param name="vs">
        <code>
            VS is DOUBLE PRECISION array, dimension (LDVS,N)
            If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
            vectors.
            If JOBVS = 'N', VS is not referenced.
            </code>
      </param>
      <param name="ldvs">
        <code>
            LDVS is INTEGER
            The leading dimension of the array VS.  LDVS &gt;= 1; if
            JOBVS = 'V', LDVS &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value.
            &gt; 0: if INFO = i, and i is
               &lt;= N: the QR algorithm failed to compute all the
                     eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
                     contain those eigenvalues which have converged; if
                     JOBVS = 'V', VS contains the matrix which reduces A
                     to its partially converged Schur form.
               = N+1: the eigenvalues could not be reordered because some
                     eigenvalues were too close to separate (the problem
                     is very ill-conditioned);
               = N+2: after reordering, roundoff changed values of some
                     complex eigenvalues so that leading eigenvalues in
                     the Schur form no longer satisfy SELECT=.TRUE.  This
                     could also be caused by underflow due to scaling.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            This gives the Schur factorization A = Z*T*(Z**T).
            Optionally, it also orders the eigenvalues on the diagonal of the
            real Schur form so that selected eigenvalues are at the top left.
            The leading columns of Z then form an orthonormal basis for the
            invariant subspace corresponding to the selected eigenvalues.
            A matrix is in real Schur form if it is upper quasi-triangular with
            1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
            form
                    [  a  b  ]
                    [  c  a  ]
            where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SingularValueDecompose(System.Char,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors, by using divide-and-conquer method.</para>
      </summary>
      <param name="jobz">
        <pre>
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V<sup>H</sup> are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V<sup>H</sup> are returned in the arrays U
                    and VT;
            = 'O':  If M &gt;= N, the first N columns of U are overwritten
                    in the array A and all rows of V<sup>H</sup> are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V<sup>H</sup> are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V<sup>H</sup> are computed.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the input matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the input matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M &gt;= N;
                            A is overwritten with the first M rows
                            of V<sup>H</sup> (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="s">
        <pre>
            S is <typeparamref name="TReal" /> array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) &gt;= S(i+1).
            </pre>
      </param>
      <param name="u">
        <pre>
            U is <typeparamref name="TComplex" /> array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
            unitary matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.
            </pre>
      </param>
      <param name="ldu">
        <pre>
            The leading dimension of the array U.  LDU &gt;= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.
            </pre>
      </param>
      <param name="vt">
        <pre>
            VT is <typeparamref name="TComplex" /> array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the
            N-by-N unitary matrix V<sup>H</sup>;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V<sup>H</sup> (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
            </pre>
      </param>
      <param name="ldvt">
        <pre>
            The leading dimension of the array VT.  LDVT &gt;= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N;
            if JOBZ = 'S', LDVT &gt;= min(M,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  The updating process of DBDSDC did not converge.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The SVD is written
                 A = U * SIGMA * conjugate-transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V<sup>H</sup>, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SingularValueDecompose(System.Char,System.Int32,System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors, by using divide-and-conquer method.</para>
      </summary>
      <param name="jobz">
        <pre>
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V<sup>H</sup> are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V<sup>H</sup> are returned in the arrays U
                    and VT;
            = 'O':  If M &gt;= N, the first N columns of U are overwritten
                    in the array A and all rows of V<sup>H</sup> are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V<sup>H</sup> are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V<sup>H</sup> are computed.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the input matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the input matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M &gt;= N;
                            A is overwritten with the first M rows
                            of V<sup>H</sup> (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="s">
        <pre>
            S is <typeparamref name="TReal" /> array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) &gt;= S(i+1).
            </pre>
      </param>
      <param name="u">
        <pre>
            U is <typeparamref name="TComplex" /> array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
            unitary matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.
            </pre>
      </param>
      <param name="ldu">
        <pre>
            The leading dimension of the array U.  LDU &gt;= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.
            </pre>
      </param>
      <param name="vt">
        <pre>
            VT is <typeparamref name="TComplex" /> array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the
            N-by-N unitary matrix V<sup>H</sup>;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V<sup>H</sup> (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
            </pre>
      </param>
      <param name="ldvt">
        <pre>
            The leading dimension of the array VT.  LDVT &gt;= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N;
            if JOBZ = 'S', LDVT &gt;= min(M,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  The updating process of DBDSDC did not converge.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The SVD is written
                 A = U * SIGMA * conjugate-transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V<sup>H</sup>, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Span{`0},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the factorization of a real symmetric matrix A using
            the Bunch-Kaufman diagonal pivoting method.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The form of the
            factorization is
               A = U*D*U<sup>T</sup>  or  A = L*D*L<sup>T</sup>
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is symmetric and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            If UPLO = 'U', then A = U*D*U<sup>T</sup>, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L<sup>T</sup>, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>?SYTRF</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricEigenvalueDecompose(System.Char,Numerics.NET.MatrixTriangle,System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32@)">
      <summary>
        <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            real symmetric matrix A.</para>
      </summary>
      <param name="jobz">
        <pre>
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </pre>
      </param>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="w">
        <pre>
            W is <typeparamref name="TReal" /> array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the sub-matrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            Because of large use of BLAS of level 3, DSYEVD needs N**2 more
            workspace than DSYEVX.
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee \n
             Modified description of INFO. Sven, 16 Feb 05. \n
            </para>
        <para>This method corresponds to the LAPACK routine <c>DSYEVD</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{System.Int32},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric matrix A using the factorization
            A = U*D*U<sup>T</sup> or A = L*D*L<sup>T</sup> computed by DSYTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
      </param>
      <param name="anorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            The 1-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>?SYCON</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricGeneralizedEigenvalueDecompose(System.Int32,System.Char,Numerics.NET.MatrixTriangle,System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32@)">
      <summary>
        <para>
            Computes all the eigenvalues, and optionally, the eigenvectors
            of a real generalized symmetric-definite eigenproblem, of the form
            A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.</para>
      </summary>
      <param name="itype">
        <code>
            ITYPE is INTEGER
            Specifies the problem type to be solved:
            = 1:  A*x = (lambda)*B*x
            = 2:  A*B*x = (lambda)*x
            = 3:  B*A*x = (lambda)*x
            </code>
      </param>
      <param name="jobz">
        <code>
            JOBZ is CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </code>
      </param>
      <param name="uplo">
        <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangles of A and B are stored;
            = 'L':  Lower triangles of A and B are stored.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A and B.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            matrix Z of eigenvectors.  The eigenvectors are normalized
            as follows:
            if ITYPE = 1 or 2, Z**T*B*Z = I;
            if ITYPE = 3, Z**T*inv(B)*Z = I.
            If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
            or the lower triangle (if UPLO='L') of A, including the
            diagonal, is destroyed.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the symmetric matrix B.  If UPLO = 'U', the
            leading N-by-N upper triangular part of B contains the
            upper triangular part of the matrix B.  If UPLO = 'L',
            the leading N-by-N lower triangular part of B contains
            the lower triangular part of the matrix B.
            On exit, if INFO &lt;= N, the part of B containing the matrix is
            overwritten by the triangular factor U or L from the Cholesky
            factorization B = U**T*U or B = L*L**T.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="w">
        <code>
            W is DOUBLE PRECISION array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  DPOTRF or DSYEVD returned an error code:
               &lt;= N:  if INFO = i and JOBZ = 'N', then the algorithm
                      failed to converge; i off-diagonal elements of an
                      intermediate tridiagonal form did not converge to
                      zero;
                      if INFO = i and JOBZ = 'V', then the algorithm
                      failed to compute an eigenvalue while working on
                      the submatrix lying in rows and columns INFO/(N+1)
                      through mod(INFO,N+1);
               &gt; N:   if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading
                      minor of order i of B is not positive definite.
                      The factorization of B could not be completed and
                      no eigenvalues or eigenvectors were computed.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            Here A and
            B are assumed to be symmetric and B is also positive definite.
            If eigenvectors are desired, it uses a divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
        </para>
        <h4> Further Details:</h4>
        <para>
          <code>
            Modified so that no backsubstitution is performed if DSYEVD fails to
            converge (NEIG in old code could be greater than N causing out of
            bounds reference to A - reported by Ralf Meyer).  Also corrected the
            description of INFO and the test on ITYPE. Sven, 16 Feb 05.
            </code>
        </para>
        <h4> Contributors:</h4>
        <para>
                Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricInvert(Numerics.NET.MatrixTriangle,System.Int32,System.Span{`0},System.Int32,System.ReadOnlySpan{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the inverse of a real symmetric indefinite matrix
            A using the factorization A = U*D*U<sup>T</sup> or A = L*D*L<sup>T</sup> computed by
            DSYTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by DSYTRF.
            On exit, if INFO = 0, the (symmetric) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            &gt; 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </pre>
      </param>
      <remarks>
        <para>This method corresponds to the LAPACK routine <c>?SYTRI</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricSolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{System.Int32},System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a real
            symmetric matrix A using the factorization A = U*D*U<sup>T</sup> or
            A = L*D*L<sup>T</sup> computed by DSYTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TReal" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>This method corresponds to the LAPACK routine <c>?SYTRS</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricTridiagonalEigenvalueDecompose(System.Char,System.Int32,System.Span{`0},System.Span{`0},System.Span{`0},System.Int32,System.Int32@)">
      <summary>
        <para>
          <code>
            Computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the implicit QL or QR method.
            </code>
        </para>
      </summary>
      <param name="compz">
        <code>
            COMPZ is CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'V':  Compute eigenvalues and eigenvectors of the original
                    symmetric matrix.  On entry, Z must contain the
                    orthogonal matrix used to reduce the original matrix
                    to tridiagonal form.
            = 'I':  Compute eigenvalues and eigenvectors of the
                    tridiagonal matrix.  Z is initialized to the identity
                    matrix.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrix.  N &gt;= 0.
            </code>
      </param>
      <param name="d">
        <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
      </param>
      <param name="e">
        <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.
            </code>
      </param>
      <param name="z">
        <code>
            Z is DOUBLE PRECISION array, dimension (LDZ, N)
            On entry, if  COMPZ = 'V', then Z contains the orthogonal
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original symmetric matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If COMPZ = 'N', then Z is not referenced.
            </code>
      </param>
      <param name="ldz">
        <code>
            LDZ is INTEGER
            The leading dimension of the array Z.  LDZ &gt;= 1, and if
            eigenvectors are desired, then  LDZ &gt;= max(1,N).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  the algorithm has failed to find all the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero; on exit, D
                  and E contain the elements of a symmetric tridiagonal
                  matrix which is orthogonally similar to the original
                  matrix.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            The eigenvectors of a full or band symmetric matrix can also be found
            if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
            tridiagonal form.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularEstimateCondition(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,`0@,System.Int32@)">
      <summary>
            Approximates the reciprocal of the condition number of a complex triangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> value that specifies which norm to use in the expression for the condition number.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularEstimateCondition(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{`0},System.Int32,`0@,System.Int32@)">
      <summary>
            Approximates the reciprocal of the condition number of a complex triangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> value that specifies which norm to use in the expression for the condition number.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularInvert(Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
            Computes the inverse of a complex triangular matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularInvert(Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
            Computes the inverse of a complex triangular matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularSolve(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Int32@)">
      <summary>
            Solves a complex triangular system of equations.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="trans">A <see cref="T:Numerics.NET.TransposeOperation" /> value that indicates if the matrix should be transposed or not.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="nrhs">The number of right hand sides.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the components of the right-hand side(s).</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularSolve(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32,System.Int32@)">
      <summary>
            Solves a complex triangular system of equations.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="trans">A <see cref="T:Numerics.NET.TransposeOperation" /> value that indicates if the matrix should be transposed or not.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="nrhs">The number of right hand sides.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the components of the right-hand side(s).</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="T:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1">
      <summary>
            Implements the BLAS (Basic Linear Algebra Subroutines) for
            generic element types.
            </summary>
      <typeparam name="T">The element type of the arrays.</typeparam>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.AbsoluteMaxIndex(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Finds the index of element having max.</para>
      </summary>
      <param name="n">The number of elements in the vector <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in the storage array.</param>
      <remarks>
        <para>
          <pre>
            absolute value.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 1/15/85.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.AbsoluteMaxIndex(System.Int32,System.ReadOnlySpan{`0},System.Int32)">
      <summary>
        <para>
            Finds the index of element having max.</para>
      </summary>
      <param name="n">The number of elements in the vector <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in the storage array.</param>
      <remarks>
        <para>
          <pre>
            absolute value.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 1/15/85.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ApplyModifiedGivensRotation(System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32,`0[])">
      <summary>
        <para>
            THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX
               (DX<sup>T</sup>) , WHERE **T INDICATES TRANSPOSE.</para>
      </summary>
      <param name="n">
        <pre>
            number of elements in input vector(s)
            </pre>
      </param>
      <param name="x">
        <pre>
            Dimension N
            T precision vector with N elements
            </pre>
      </param>
      <param name="incx">
        <pre>
            storage spacing between elements of DX
            </pre>
      </param>
      <param name="y">
        <pre>
            Dimension N
            T precision vector with N elements
            </pre>
      </param>
      <param name="incy">
        <pre>
            storage spacing between elements of DY
            </pre>
      </param>
      <param name="dparam">
        <pre>
            Dimension 5
            AM(1)=DFLAG
            RAM(2)=DH11
            ARAM(3)=DH21
            PARAM(4)=DH12
            DPARAM(5)=DH22
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            THE ELEMENTS OF DX ARE IN
               (DY<sup>T</sup>)
               DX(LX+I*INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX  &gt;=  0, ELSE
               LX = (-INCX)*N, AND SIMILARLY FOR SY USING LY AND INCY.
               WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.
               DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0
                 (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0)
               H=(          )    (          )    (          )    (          )
                 (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0).
               SEE DROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandHermitianMultiplyAndAddInPlace(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x, incx and y are n element vectors and
            A is an n by n hermitian band matrix, with k super-diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the band matrix A is being supplied as
             follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    being supplied.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    being supplied.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry, K specifies the number of super-diagonals of the
             matrix A. K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the hermitian matrix, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer the upper
             triangular part of a hermitian band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the hermitian matrix, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer the lower
             triangular part of a hermitian band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandMatrixNorm(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Computes the norm of a general band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="kl">The number of sub-diagonals of the matrix.</param>
      <param name="ku">The number of super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGB</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandMatrixNorm(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32)">
      <summary>
            Computes the norm of a general band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="kl">The number of sub-diagonals of the matrix.</param>
      <param name="ku">The number of super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGB</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandMultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,   or
               y := alpha*A<sup>H</sup>*x + beta*y,
            where alpha and beta are scalars, x, incx and y are vectors and A is an
            m by n band matrix, with kl sub-diagonals and ku super-diagonals.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>H</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="kl">
        <pre>
             On entry, KL specifies the number of sub-diagonals of the
             matrix A. KL must satisfy  0 .le. KL.
            </pre>
      </param>
      <param name="ku">
        <pre>
             On entry, KU specifies the number of super-diagonals of the
             matrix A. KU must satisfy  0 .le. KU.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry, the leading ( kl + ku + 1 ) by n part of the
             array A must contain the matrix of coefficients, supplied
             column by column, with the leading diagonal of the matrix in
             row ( ku + 1 ) of the array, the first super-diagonal
             starting at position 2 in row ku, the first sub-diagonal
             starting at position 1 in row ( ku + 2 ), and so on.
             Elements in the array A that do not correspond to elements
             in the band matrix (such as the top left ku by ku triangle)
             are not referenced.
             The following program segment will transfer a band matrix
             from conventional full matrix storage to band storage:
                   DO 20, J = 1, N
                      K = KU + 1 - J
                      DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
                         A( K + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( kl + ku + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandMultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{`0},System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n band matrix, with kl sub-diagonals and ku super-diagonals.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>T</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="kl">
        <pre>
             On entry, KL specifies the number of sub-diagonals of the
             matrix A. KL must satisfy  0 .le. KL.
            </pre>
      </param>
      <param name="ku">
        <pre>
             On entry, KU specifies the number of super-diagonals of the
             matrix A. KU must satisfy  0 .le. KU.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading ( kl + ku + 1 ) by n part of the
             array A must contain the matrix of coefficients, supplied
             column by column, with the leading diagonal of the matrix in
             row ( ku + 1 ) of the array, the first super-diagonal
             starting at position 2 in row ku, the first sub-diagonal
             starting at position 1 in row ( ku + 2 ), and so on.
             Elements in the array A that do not correspond to elements
             in the band matrix (such as the top left ku by ku triangle)
             are not referenced.
             The following program segment will transfer a band matrix
             from conventional full matrix storage to band storage:
                   DO 20, J = 1, N
                      K = KU + 1 - J
                      DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
                         A( K + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( kl + ku + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandSymmetricMultiplyAndAddInPlace(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{`0},System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric band matrix, with k super-diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the band matrix A is being supplied as
             follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    being supplied.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    being supplied.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry, K specifies the number of super-diagonals of the
             matrix A. K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the symmetric matrix, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer the upper
             triangular part of a symmetric band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the symmetric matrix, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer the lower
             triangular part of a symmetric band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularMultiplyInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular band matrix, with ( k + 1 ) diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularMultiplyInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular band matrix, with ( k + 1 ) diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularSolveInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular band matrix, with ( k + 1 )
            diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularSolveInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular band matrix, with ( k + 1 )
            diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ComplexOneNorm(Numerics.NET.Complex{`0})">
      <summary>
        <para>
            Computes the sum of the absolute values of a complex number
            </para>
      </summary>
      <remarks>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ConjugateDotProduct(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Forms the dot product of a vector.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ConjugateRankUpdate(System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs the rank 1 operation
               A := alpha*x*y**H + A,
            where alpha is a scalar, x, incx is an m element vector, y, incy is an n element
            vector and A is an m by n matrix.</para>
      </summary>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Copy(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Copies the specified elements of a complex matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies which part of the matrix should be copied.</param>
      <param name="m">The number of rows of the matrices.</param>
      <param name="n">The number of columns of the matrices.</param>
      <param name="a">A complex array that contains the data for the source matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the data for the destination matrix.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <remarks>This method corresponds to the LAPACK routine <c>?LACPY</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Copy(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
            Copies the specified elements of a complex matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies which part of the matrix should be copied.</param>
      <param name="m">The number of rows of the matrices.</param>
      <param name="n">The number of columns of the matrices.</param>
      <param name="a">A complex array that contains the data for the source matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the data for the destination matrix.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <remarks>This method corresponds to the LAPACK routine <c>?LACPY</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Copy(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Copies a vector, x, incx, to a vector, y, incy.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the elements of <paramref name="x" />.</param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, linpack, 4/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Copy(System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Copies a vector, x, incx, to a vector, y, incy.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the elements of <paramref name="x" />.</param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, linpack, 4/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.CreateGivensRotation(Numerics.NET.Complex{`0}@,Numerics.NET.Complex{`0},`0@,Numerics.NET.Complex{`0}@)">
      <summary>
        <para>
            Determines a complex Givens rotation.</para>
      </summary>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.CreateGivensRotation(`0@,`0@,`0@,`0@)">
      <summary>
        <para>
            Construct givens plane rotation.</para>
      </summary>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, linpack, 3/11/78.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.CreateModifiedGivensRotation(`0@,`0@,`0@,`0,`0[])">
      <summary>
        <para>
            THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS
               THE SECOND COMPONENT OF THE 2-VECTOR  (DSQRT(DD1)*DX1,DSQRT(DD2)*&gt;    DY2)**T.</para>
      </summary>
      <param name="dd1">
        <pre></pre>
      </param>
      <param name="dd2">
        <pre></pre>
      </param>
      <param name="dx1">
        <pre></pre>
      </param>
      <param name="dy1">
        <pre></pre>
      </param>
      <param name="dparam">
        <pre>
            Dimension 5
            AM(1)=DFLAG
            RAM(2)=DH11
            ARAM(3)=DH21
            PARAM(4)=DH12
            DPARAM(5)=DH22
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
               WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.
               DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0
                 (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0)
               H=(          )    (          )    (          )    (          )
                 (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0).
               LOCATIONS 2-4 OF DPARAM CONTAIN DH11, DH21, DH12, AND DH22
               RESPECTIVELY. (VALUES OF 1.D0, -1.D0, OR 0.D0 IMPLIED BY THE
               VALUE OF DPARAM(1) ARE NOT STORED IN DPARAM.)
               THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE
               INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE
               OF DD1 AND DD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.DotProduct(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Forms the dot product of two vectors.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.DotProduct(System.Int32,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{`0},System.Int32)">
      <summary>
        <para>
            Forms the dot product of two vectors.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.FullMatrixNorm(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Computes the norm of a general rectangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="m">The number of rows of the matrix.</param>
      <param name="n">The number of columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGE</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.FullMatrixNorm(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32)">
      <summary>
            Computes the norm of a general rectangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="m">The number of rows of the matrix.</param>
      <param name="n">The number of columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGE</c>.</remarks>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HasSharedDegreeOfParallelism">
      <summary>
            Indicates whether the degree of parallelism is a property that is shared
            across instances.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianBandMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Computes the norm of a symmetric band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="k">The number of sub- and super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to 
            the LAPACK routine <c>?LANHB</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Computes the norm of a Hermitian matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANHE</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianMultiplyAndAddInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where alpha and beta are scalars, A is an hermitian matrix and  B and
            C are m by n matrices.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE  specifies whether  the  hermitian matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  hermitian  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    hermitian matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    hermitian matrix is to be referenced.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is n  otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  hermitian matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  hermitian matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  hermitian
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  hermitian matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  hermitian matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  hermitian
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Note that the imaginary parts  of the diagonal elements need
             not be set, they are assumed to be zero.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianMultiplyAndAddInPlace(Numerics.NET.MatrixTriangle,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x, incx and y are n element vectors and
            A is an n by n hermitian matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced.
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,`0,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the hermitian rank 2k operations
               C := alpha*A*B<sup>H</sup> + conjg( alpha )*B*A<sup>H</sup> + beta*C,
            or
               C := alpha*A<sup>H</sup>*B + conjg( alpha )*B<sup>H</sup>*A + beta*C,
            where  alpha and beta  are scalars with  beta  real,  C is an  n by n
            hermitian matrix and  A and B  are  n by k matrices in the first case
            and  k by n  matrices in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'    C := alpha*A*B<sup>H</sup>          +
                                           conjg( alpha )*B*A<sup>H</sup> +
                                           beta*C.
                TRANS = 'C' or 'c'    C := alpha*A<sup>H</sup>*B          +
                                           conjg( alpha )*B<sup>H</sup>*A +
                                           beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is complex .
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
             Unchanged on exit.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION .
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.
               Ed Anderson, Cray Research Inc.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,`0,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,`0,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the hermitian rank k operations
               C := alpha*A*A<sup>H</sup> + beta*C,
            or
               C := alpha*A<sup>H</sup>*A + beta*C,
            where  alpha and beta  are  real scalars,  C is an  n by n  hermitian
            matrix and  A  is an  n by k  matrix in the  first case and a  k by n
            matrix in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>H</sup> + beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>H</sup>*A + beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION .
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.
               Ed Anderson, Cray Research Inc.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Numerics.NET.MatrixTriangle,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs the hermitian rank 2 operation
               A := alpha*x*y**H + conjg( alpha )*y*x**H + A,
            where alpha is a scalar, x, incx and y are n element vectors and A is an n
            by n hermitian matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Numerics.NET.MatrixTriangle,System.Int32,`0,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs the hermitian rank 1 operation
               A := alpha*x*x**H + A,
            where alpha is a real scalar, x, incx is an n element vector and A is an
            n by n hermitian matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MaxDegreeOfParallelism">
      <summary>
            Gets or sets the maximum degree of parallelism enabled by the instance.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*op( A )*op( B ) + beta*C,
            where  op( X ) is one of
               op( X ) = X   or   op( X ) = X<sup>T</sup>   or   op( X ) = X<sup>H</sup>,
            alpha and beta are scalars, and A, B and C are matrices, with op( A )
            an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</para>
      </summary>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n',  op( A ) = A.
                TRANSA = 'T' or 't',  op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c',  op( A ) = A<sup>H</sup>.
            </pre>
      </param>
      <param name="transb">
        <pre>
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:
                TRANSB = 'N' or 'n',  op( B ) = B.
                TRANSB = 'T' or 't',  op( B ) = B<sup>T</sup>.
                TRANSB = 'C' or 'c',  op( B ) = B<sup>H</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="transB">Specifies the operation to be
            performed on the matrix <paramref name="b" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{`0},System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*op( A )*op( B ) + beta*C,
            where  op( X ) is one of
               op( X ) = X   or   op( X ) = X<sup>T</sup>,
            alpha and beta are scalars, and A, B and C are matrices, with op( A )
            an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</para>
      </summary>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n',  op( A ) = A.
                TRANSA = 'T' or 't',  op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c',  op( A ) = A<sup>T</sup>.
            </pre>
      </param>
      <param name="transb">
        <pre>
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:
                TRANSB = 'N' or 'n',  op( B ) = B.
                TRANSB = 'T' or 't',  op( B ) = B<sup>T</sup>.
                TRANSB = 'C' or 'c',  op( B ) = B<sup>T</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="transB">Specifies the operation to be
            performed on the matrix <paramref name="b" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,   or
               y := alpha*A<sup>H</sup>*x + beta*y,
            where alpha and beta are scalars, x, incx and y are vectors and A is an
            m by n matrix.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>H</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{`0},System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n matrix.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>T</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Constant times a vector plus a vector.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.</param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Constant times a vector plus a vector.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.</param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre>
            uses unrolled loops for increments equal to one.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, linpack, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyInPlace(System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Scales a vector by a constant.</para>
      </summary>
      <param name="n">The number of elements in the vector
            <paramref name="x" />.</param>
      <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            The elements of <paramref name="x" /> are overwritten with
            the result.</param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyInPlace(System.Int32,`0,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Scales a vector by a constant.</para>
      </summary>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyInPlace(System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Scales a vector by a constant.</para>
      </summary>
      <param name="n">The number of elements in the vector
            <paramref name="x" />.</param>
      <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            The elements of <paramref name="x" /> are overwritten with
            the result.</param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Name">
      <summary>
            Gets the name of the implementation.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.OneNorm(System.Int32,System.ReadOnlySpan{`0},System.Int32)">
      <summary>
        <para>
            Takes the sum of the absolute values.</para>
      </summary>
      <param name="n">The number of elements in the vector <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, linpack, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Platform">
      <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.RankUpdate(System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs the rank 1 operation
               A := alpha*x*y**T + A,
            where alpha is a scalar, x, incx is an m element vector, y, incy is an n element
            vector and A is an m by n matrix.</para>
      </summary>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.RankUpdate(System.Int32,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs the rank 1 operation
               A := alpha*x*y**T + A,
            where alpha is a scalar, x is an m element vector, y is an n element
            vector and A is an m by n matrix.</para>
      </summary>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.RealOneNorm(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Takes the sum of the absolute values.</para>
      </summary>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Rotate(System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,`0,`0)">
      <summary>
        <para>
            A plane rotation, where the cos and sin (c and s) are real
            and the vectors cx and cy are complex.</para>
      </summary>
      <param name="n">
        <pre>
             On entry, N specifies the order of the vectors cx and cy.
             N must be at least zero.
            </pre>
      </param>
      <param name="cx">
        <pre>
            CX is complex array, dimension at least
             ( 1 + ( N - 1 )*abs( INCX ) ).
             Before entry, the incremented array CX must contain the n
             element vector cx. On exit, CX is overwritten by the updated
             vector cx.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             CX. INCX must not be zero.
            </pre>
      </param>
      <param name="cy">
        <pre>
            CY is complex array, dimension at least
             ( 1 + ( N - 1 )*abs( INCY ) ).
             Before entry, the incremented array CY must contain the n
             element vector cy. On exit, CY is overwritten by the updated
             vector cy.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             CY. INCY must not be zero.
            </pre>
      </param>
      <param name="c">
        <pre>
             On entry, C specifies the cosine, cos.
            </pre>
      </param>
      <param name="s">
        <pre>
             On entry, S specifies the sine, sin.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            jack dongarra, linpack, 3/11/78.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Rotate(System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32,`0,`0)">
      <summary>
        <para>
            A plane rotation, where the cos and sin (c and s) are real
            and the vectors cx and cy are complex.</para>
      </summary>
      <param name="n">
        <pre>
             On entry, N specifies the order of the vectors cx and cy.
             N must be at least zero.
            </pre>
      </param>
      <param name="cx">
        <pre>
            CX is complex array, dimension at least
             ( 1 + ( N - 1 )*abs( INCX ) ).
             Before entry, the incremented array CX must contain the n
             element vector cx. On exit, CX is overwritten by the updated
             vector cx.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             CX. INCX must not be zero.
            </pre>
      </param>
      <param name="cy">
        <pre>
            CY is complex array, dimension at least
             ( 1 + ( N - 1 )*abs( INCY ) ).
             Before entry, the incremented array CY must contain the n
             element vector cy. On exit, CY is overwritten by the updated
             vector cy.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             CY. INCY must not be zero.
            </pre>
      </param>
      <param name="c">
        <pre>
             On entry, C specifies the cosine, cos.
            </pre>
      </param>
      <param name="s">
        <pre>
             On entry, S specifies the sine, sin.
            </pre>
      </param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <remarks>
        <para>
          <pre>
            jack dongarra, linpack, 3/11/78.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Swap(System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Interchanges two vectors.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Swap(System.Int32,System.Span{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Interchanges two vectors.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricBandMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Computes the norm of a symmetric band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="k">The number of sub- and super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>
        <para>This method corresponds to the LAPACK routine <c>?LANSB</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricBandMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32)">
      <summary>
            Computes the norm of a symmetric band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="k">The number of sub- and super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>
        <para>This method corresponds to the LAPACK routine <c>?LANSB</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Computes the norm of a symmetric matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANSY</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{`0},System.Int32)">
      <summary>
            Computes the norm of a symmetric matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANSY</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMultiplyAndAddInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where  alpha and beta are scalars, A is a symmetric matrix and  B and
            C are m by n matrices.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE  specifies whether  the  symmetric matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  symmetric  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    symmetric matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    symmetric matrix is to be referenced.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is n  otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>                                                                                                                                                                  /// Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMultiplyAndAddInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{`0},System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where alpha and beta are scalars,  A is a symmetric matrix and  B and
            C are  m by n matrices.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE  specifies whether  the  symmetric matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  symmetric  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    symmetric matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    symmetric matrix is to be referenced.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is  n otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMultiplyAndAddInPlace(Numerics.NET.MatrixTriangle,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{`0},System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the symmetric rank k operations
               C := alpha*A*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
            and  A  is an  n by k  matrix in the first case and a  k by n  matrix
            in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>T</sup> + beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*A + beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="c" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the symmetric rank 2k operations
               C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
            and  A and B  are  n by k  matrices  in the  first  case  and  k by n
            matrices in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'    C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> +
                                           beta*C.
                TRANS = 'T' or 't'    C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                           beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{`0},System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs one of the symmetric rank 2k operations
               C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
            and  A and B  are  n by k  matrices  in the  first  case  and  k by n
            matrices in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> +
                                          beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                          beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                          beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrices  A and B.  K must be at least  zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs one of the symmetric rank k operations
               C := alpha*A*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
            and  A  is an  n by k  matrix in the first case and a  k by n  matrix
            in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>T</sup> + beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*A + beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>T</sup>*A + beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrix  A.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="c" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs the symmetric rank 2 operation
               A := alpha*x*y**T + alpha*y*x**T + A,
            where alpha is a scalar, x and y are n element vectors and A is an n
            by n symmetric matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs the symmetric rank 1 operation
               A := alpha*x*x**T + A,
            where alpha is a real scalar, x is an n element vector and A is an
            n by n symmetric matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularBandMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Computes the norm of a triangular band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="diag">Specifies whether or not
            the matrix is unit triangular.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="k">The number of sub- or super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGB</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularBandMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32)">
      <summary>
            Computes the norm of a triangular band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="diag">Specifies whether or not
            the matrix is unit triangular.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="k">The number of sub- or super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGB</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Computes the norm of a triangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix is upper or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the diagonal
            elements are all equal to one.</param>
      <param name="m">The number of rows of the matrix.</param>
      <param name="n">The number of columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANTR</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{`0},System.Int32)">
      <summary>
            Computes the norm of a triangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix is upper or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the diagonal
            elements are all equal to one.</param>
      <param name="m">The number of rows of the matrix.</param>
      <param name="n">The number of columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANTR</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               B := alpha*op( A )*B,   or   B := alpha*B*op( A )
            where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>   or   op( A ) = A<sup>H</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
                SIDE = 'L' or 'l'   B := alpha*op( A )*B.
                SIDE = 'R' or 'r'   B := alpha*B*op( A ).
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>H</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is (input/output) complex array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
            where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
                SIDE = 'L' or 'l'   B := alpha*op( A )*B.
                SIDE = 'R' or 'r'   B := alpha*B*op( A ).
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>T</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
            when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
            Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
            upper triangular part of the array  A must contain the upper
            triangular matrix  and the strictly lower triangular part of
            A is not referenced.
            Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
            lower triangular part of the array  A must contain the lower
            triangular matrix  and the strictly upper triangular part of
            A is not referenced.
            Note that when  DIAG = 'U' or 'u',  the diagonal elements of
            A  are not referenced either,  but are assumed to be  unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,Numerics.NET.Complex{`0},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Solves one of the matrix equations
               op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
            where alpha is a scalar, X and B are m by n matrices, A is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>   or   op( A ) = A<sup>H</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:
                SIDE = 'L' or 'l'   op( A )*X = alpha*B.
                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>H</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, k ),
             where k is m when SIDE = 'L' or 'l'
               and k is n when SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre>
            The matrix X is overwritten on B.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,`0,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Solves one of the matrix equations
               op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
            where alpha is a scalar, X and B are m by n matrices, A is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:
                SIDE = 'L' or 'l'   op( A )*X = alpha*B.
                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>T</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, k ),
             where k is m when SIDE = 'L' or 'l'
               and k is n when SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre>
            The matrix X is overwritten on B.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TwoNorm(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
        <para>
          <pre>
            Returns the euclidean norm of a vector via the function
            name, so that
               DZNRM2 := sqrt( x**H*x )
            </pre>
        </para>
      </summary>
      <remarks>
        <h4>Further Details:</h4>
        <para>
             -- This version written on 25-October-1982.</para>
        <para>
          <pre>
            Modified on 14-October-1993 to inline the call to ZLASSQ.
            Sven Hammarling, Nag Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TwoNorm(System.Int32,System.ReadOnlySpan{`0},System.Int32)">
      <summary>
        <para>
          <pre>
            Returns the euclidean norm of a vector via the function
            name, so that
               DZNRM2 := sqrt( x**H*x )
            </pre>
        </para>
      </summary>
      <param name="n">The number of elements in the vector <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
             -- This version written on 25-October-1982.</para>
        <para>
          <pre>
            Modified on 14-October-1993 to inline the call to ZLASSQ.
            Sven Hammarling, Nag Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1">
      <summary>
            Implements the sparse BLAS (Basic Linear Algebra Subroutines) for
            generic element types.
            </summary>
      <typeparam name="T">The element type of the arrays.</typeparam>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperations" /> object.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{`0},Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Multiplies a dense vector by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="xStride">The distance between successive elements in <paramref name="x" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="y" />.
            </param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,Numerics.NET.Complex{`0},Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,Numerics.NET.Complex{`0},System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Multiplies a dense matrix by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="n">The number of columns in the matrix <paramref name="c" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="n" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="n" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="b">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="b" />.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="c" />.
            </param>
      <param name="c">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="c" />.
            The elements of <paramref name="c" /> are overwritten with
            the result.
            </param>
      <param name="ldc">The leading dimension of the matrix <paramref name="c" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,`0,Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{`0},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{`0},System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
            Multiplies a dense matrix by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="n">The number of columns in the matrix <paramref name="c" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="n" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="n" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="b">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="b" />.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="c" />.
            </param>
      <param name="c">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="c" />.
            The elements of <paramref name="c" /> are overwritten with
            the result.
            </param>
      <param name="ldc">The leading dimension of the matrix <paramref name="c" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,`0,Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{`0},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{`0},System.Int32,`0,System.Span{`0},System.Int32)">
      <summary>
            Multiplies a dense vector by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="xStride">The distance between successive elements in <paramref name="x" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="y" />.
            </param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.Name">
      <summary>
            Gets the name of the implementation.
            </summary>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.Platform">
      <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Numerics.NET.TransposeOperation,System.Int32,Numerics.NET.Complex{`0},Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Solves for a dense vector for a sparse matrix in compressed sparse column format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="xStride">The distance between successive elements in <paramref name="x" />.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{`0},Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{Numerics.NET.Complex{`0}},System.Int32,System.Span{Numerics.NET.Complex{`0}},System.Int32)">
      <summary>
            Solves for a dense matrix for a sparse matrix in compressed sparse column format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="n">The number of columns in the matrix <paramref name="b" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="b">A two-dimensional array
            containing the elements of the right-hand side.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="c">A two-dimensional array
            containing the elements of the solution.
            </param>
      <param name="ldc">The leading dimension of the matrix <paramref name="c" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,`0,Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{`0},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
            Solves for a dense vector for a sparse matrix in compressed sparse column format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="xStride">The distance between successive elements in <paramref name="x" />.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
      <param name="n">The number of columns in the matrix <paramref name="b" />.</param>
      <param name="b">A two-dimensional array
            containing the elements of the right-hand side.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="c">A two-dimensional array
            containing the elements of the solution.
            </param>
      <param name="ldc">The leading dimension of the matrix <paramref name="c" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Numerics.NET.TransposeOperation,System.Int32,`0,Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{`0},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{`0},System.Int32,System.Span{`0},System.Int32)">
      <summary>
            Solves for a dense vector for a sparse matrix in compressed sparse column format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="xStride">The distance between successive elements in <paramref name="x" />.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
    </member>
  </members>
</doc>