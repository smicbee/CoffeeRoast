<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Numerics.NET.SinglePrecision</name>
  </assembly>
  <members>
    <member name="T:Numerics.NET.SingleConstants">
      <summary>
            Contains various mathematical constants in single precision.
            </summary>
      <remarks>
        <para>Some real numbers return time and again in
            mathematical calculations. This class provides pre-calculated
            values for many of these numbers:
            <list type="bullet"><listItem>Square roots.</listItem><listItem>Logarithms and exponentials.</listItem><listItem>π and its variations: common multiples, square
            roots and integer powers.</listItem><listItem>Various other mathematical constants with more
            complicated definitions.</listItem></list></para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Catalan">
      <summary>
            Represents Catalan's constant.
            </summary>
      <remarks>
        <para>The value of this field is 0.915965594177219015055.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Degree">
      <summary>
            Represents the size of a 1 degree angle in radians.
            </summary>
      <remarks>
        <para>The value of this field is 0.0174532925199432957692.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.E">
      <summary>
            Represents the base for the natural logarithm, <i>e</i>.
            </summary>
      <remarks>
        <para>The value of this field is 2.71828182845904523536028747135266249.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.EulersConstant">
      <summary>
            Represents Euler's constant.
            </summary>
      <remarks>
        <para>Euler's constant is defined as
            </para>
        <para>
          <center>
            <IMG src="images/constantsEulerGamma.gif" height="48" width="136" baseline="20" />
          </center>
        </para>
        <para>The value of this field is 0.5772156649015328606065120900824.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Feigenbaum">
      <summary>
            Represents Feigenbaum's constant.
            </summary>
      <remarks>
        <para>The value of this field is 4.66920160910299067185.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.GoldenRatio">
      <summary>
            Represents the Golden Ratio.
            </summary>
      <remarks>
        <para>
            A line segment can be divided into two pieces in such
            a way that the ratio between the lengths of the whole
            and the largest piece equals the ratio of the lengths
            of the largest piece and the smallest piece. This
            ratio is called the Golden Ratio. Its value is equal to
            </para>
        <para>
          <center>
            <IMG src="images\constantsGoldenRatio.gif" height="45" width="70" baseline="16" />
          </center>
        </para>
        <para>The value of this field is 1.61803398874989484820458683436.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.InvLog10">
      <summary>
            Represents the base-10 logarithm of <see cref="F:Numerics.NET.SingleConstants.E" />.
            </summary>
      <remarks>
        <para>The value of this field is 0.434294481903251827651128918916605.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Log10">
      <summary>
            Represents the natural logarithm of 10.
            </summary>
      <remarks>
        <para>The value of this field is 2.302585092994045684017991454684364.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Log10E">
      <summary>
            Represents the base 10 logarithm of <see cref="F:Numerics.NET.SingleConstants.E" />.
            </summary>
      <remarks>
        <para>The value of this field is 2.302585092994045684017991454684364.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Log17">
      <summary>
            Represents the natural logarithm of 17.
            </summary>
      <remarks>
        <para>The value of this field is 2.8332133440562160802495346178731.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Log2">
      <summary>
            Represents the natural logarithm of 2.
            </summary>
      <remarks>
        <para>The value of this field is 0.6931471805599453094172321214581765681.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Log3">
      <summary>
            Represents the natural logarithm of 3.
            </summary>
      <remarks>
        <para>The value of this field is 1.0986122886681096913952452369225.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.LogTwoPi">
      <summary>
            Represents the natural logarithm of two times <see cref="F:Numerics.NET.SingleConstants.Pi" />.
            </summary>
      <remarks>
        <para>The value of this field is 1.837877066409345483560659472811235279723.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.OneOverSqrtPi">
      <summary>
            Represents the inverse of the square root of <see cref="F:Numerics.NET.SingleConstants.Pi" />.
            </summary>
      <remarks>
        <para>The value of this field is 0.56418958354775628694807945156082.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.OneOverSqrtTwoPi">
      <summary>
            Represents the inverse of the square root of two times <see cref="F:Numerics.NET.SingleConstants.Pi" />.
            </summary>
      <remarks>
        <para>The value of this field is 0.39894228040143267793994605993439.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Pi">
      <summary>
            Represents pi, the ratio of the circumference of a cirlce
            to its diameter.
            </summary>
      <remarks>
        <para>The value of this field is 3.141592653589793238462643383279502884.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.PiOverFour">
      <summary>
            Represents 0.25 times <see cref="F:Numerics.NET.SingleConstants.Pi" />.
            </summary>
      <remarks>
        <para>The value of this field is 0.785398163397448309615660845819876.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.PiOverTwo">
      <summary>
            Represents 0.5 times <see cref="F:Numerics.NET.SingleConstants.Pi" />.
            </summary>
      <remarks>
        <para>The value of this field is 1.570796326794896619231321691639751.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.PiSquared">
      <summary>
            Represents <see cref="F:Numerics.NET.SingleConstants.Pi" /> squared.
            </summary>
      <remarks>
        <para>The value of this field is 9.869604401089358618834490999873.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Sqrt17">
      <summary>
            Represents the square root of 17.
            </summary>
      <remarks>
        <para>The value of this field is 4.1231056256176605498214098559741.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Sqrt2">
      <summary>
            Represents the square root of 2.
            </summary>
      <remarks>
        <para>The value of this field is 1.414213562373095048801688724209698.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Sqrt3">
      <summary>
            Represents the square root of 3.
            </summary>
      <remarks>
        <para>The value of this field is 1.732050807568877293527446341505872.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Sqrt5">
      <summary>
            Represents the square root of 5.
            </summary>
      <remarks>
        <para>The value of this field is 2.236067977499789696409173668731276.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.Sqrt7">
      <summary>
            Represents the square root of 7.
            </summary>
      <remarks>
        <para>The value of this field is 2.645751311064590590501615753639260.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.SqrtPi">
      <summary>
            Represents the square root of <see cref="F:Numerics.NET.SingleConstants.Pi" />.
            </summary>
      <remarks>
        <para>The value of this field is 1.772453850905516027298167483341145.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.SqrtTwoPi">
      <summary>
            Represents the square root of two times <see cref="F:Numerics.NET.SingleConstants.Pi" />.
            </summary>
      <remarks>
        <para>The value of this field is 2.506628274631000502415765284811045.</para>
      </remarks>
    </member>
    <member name="F:Numerics.NET.SingleConstants.TwoPi">
      <summary>
            Represents two times <see cref="F:Numerics.NET.SingleConstants.Pi" />.
            </summary>
      <remarks>
        <para>The value of this field is 6.283185307179586476925286766558.</para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.SinglePrecisionImplementations">
      <summary>
            Provides access to the single-precision providers.
            </summary>
    </member>
    <member name="M:Numerics.NET.SinglePrecisionImplementations.RegisterSinglePrecisionProvider(Numerics.NET.Providers.ProviderManager,System.Boolean)">
      <summary>
            Registers the provider of generic implementations of linear
            algebra functions.
            </summary>
      <param name="providerManager"></param>
      <param name="native">Indicates whether native providers should
            be loaded.</param>
    </member>
    <member name="T:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle">
      <summary>
            Contains the default implementation for the 
            BLAS for single precision real numbers.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.#ctor">
      <summary>
            Constructs a new managed linear algebra implementation 
            for single precision real and complex vectors and matrices.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Abs(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the absolute value for each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Acos(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the inverse cosine of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Acosh(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the inverse hyperbolic cosine of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Asin(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the inverse sine of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Asinh(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the inverse hyperbolic sine of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Atan(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the inverse tangent of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Atan2(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the inverse tangent of each element of two arrays.
            </summary>
      <param name="length">The number of elements in the arrays.</param>
      <param name="y">The span that holds the y-values.</param>
      <param name="yStride">The distance between elements in <paramref name="y" />.</param>
      <param name="x">The span that holds the x-values.</param>
      <param name="xStride">The distance between elements in <paramref name="x" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Atanh(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the inverse hyperbolic tangent of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Ceiling(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the smallest integer greater than or equal to each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Cos(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the cosine of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Cosh(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the hyperbolic cosine of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Divide(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Divides each element of a span by the corresponding element in another span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="first">The span that holds the first operands.</param>
      <param name="firstStride">The distance between elements in <paramref name="first" />.</param>
      <param name="second">The span that holds the second operands.</param>
      <param name="secondStride">The distance between elements in <paramref name="second" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Exp(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the exponential function for each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Floor(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the largest integer less than or equal to each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Hypot(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the hypotenuse of corresponding elements of two arrays.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="first">The span that holds the first operands.</param>
      <param name="firstStride">The distance between elements in <paramref name="first" />.</param>
      <param name="second">The span that holds the second operands.</param>
      <param name="secondStride">The distance between elements in <paramref name="second" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Log(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the logarithm of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Max(System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
            Computes the maximum of all elements in the span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <returns>The maximum of the elements of <paramref name="operand" />.</returns>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Min(System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
            Computes the minimum of all elements in the span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <returns>The minimum of the elements of <paramref name="operand" />.</returns>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Multiply(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Multiplies each element of a span by the corresponding element in another span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="first">The span that holds the first operands.</param>
      <param name="firstStride">The distance between elements in <paramref name="first" />.</param>
      <param name="second">The span that holds the second operands.</param>
      <param name="secondStride">The distance between elements in <paramref name="second" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Pow(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the element-wise power of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="values">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="values" />.</param>
      <param name="exponent">The exponent.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Pow(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the element-wise power of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="values">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="values" />.</param>
      <param name="exponent">The exponent.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Sin(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the sine of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Sinh(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the hyperbolic sine of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Sqrt(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the square root of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Sum(System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
            Computes the sum of all elements in the span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <returns>The sum of the elements of <paramref name="operand" />.</returns>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Tan(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the tangent of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Tanh(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the hyperbolic tangent of each element of a span.
            </summary>
      <param name="length">The number of elements in the span.</param>
      <param name="operand">The span that holds the operands.</param>
      <param name="stride">The distance between elements in <paramref name="operand" />.</param>
      <param name="result">The span that holds the results.</param>
      <param name="resultStride">The distance between elements in <paramref name="result" />.</param>
    </member>
    <member name="T:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle">
      <summary>
            Specifies the methods that must be implemented by a
            class to support complex single precision LAPACK routines
            for general matrices.
            </summary>
      <remarks>
        <para>The Linear Algebra PACKage (LAPACK) is the de facto
            standard for more complex linear algebra problems. It complements
            the Basic Linear Algebra Subroutines (BLAS), which defines standards
            for low level vector and matrix operations.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskyDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band
            matrix A, in the same storage format as A.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The factorization has the form
               A = U<sup>H</sup> * U,  if UPLO = 'U', or
               A = L  * L<sup>H</sup>,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
             Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskyDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band
            matrix A, in the same storage format as A.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The factorization has the form
               A = U<sup>H</sup> * U,  if UPLO = 'U', or
               A = L  * L<sup>H</sup>,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
             Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskyEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Single,System.Single@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite band matrix using
            the Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> computed by
            ZPBTRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="anorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            The 1-norm (or infinity-norm) of the Hermitian band matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
        </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskyEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Single,System.Single@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite band matrix using the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPBTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TReal" /> array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="aNorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            The 1-norm (or infinity-norm) of the symmetric band matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>DPBCON</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskySolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a Hermitian
            positive definite band matrix A using the Cholesky factorization
            A = U<sup>H</sup> *U or A = L*L<sup>H</sup> computed by ZPBTRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>H</sup> *U or A = L*L<sup>H</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TComplex" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskySolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite band matrix A using the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPBTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TReal" /> array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TReal" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>This method corresponds to the LAPACK routine <c>?PBTRS</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes an LU factorization of a complex m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes an LU factorization of a complex m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUEstimateCondition(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Int32},System.Single,System.Single@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a complex
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by ZGBTRF.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="anorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUEstimateCondition(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Int32},System.Single,System.Single@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a complex
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by ZGBTRF.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="anorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Int32},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations
               A * X = B,  A<sup>T</sup> * X = B,  or  A<sup>H</sup> * X = B
            with a general band matrix A using the LU factorization computed
            by ZGBTRF.</para>
      </summary>
      <param name="trans">
        <pre>
            Specifies the form of the system of equations.
            = 'N':  A * X = B     (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose)
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TComplex" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Int32},System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations
               A * X = B,  A<sup>T</sup> * X = B,  or  A<sup>H</sup> * X = B
            with a general band matrix A using the LU factorization computed
            by ZGBTRF.</para>
      </summary>
      <param name="trans">
        <pre>
            Specifies the form of the system of equations.
            = 'N':  A * X = B     (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose)
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TComplex" /> array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TComplex" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandTriangularSolve(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a triangular system of the form
               A * X = B  or  A<sup>T</sup> * X = B,
            where A is a triangular band matrix of order N, and B is an
            N-by NRHS matrix.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
      </param>
      <param name="trans">
        <pre>
            Specifies the form the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose = Transpose)
            </pre>
      </param>
      <param name="diag">
        <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is <typeparamref name="TReal" /> array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </pre>
      </param>
      <param name="ldab">
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TReal" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, the i-th diagonal element of A is zero,
                  indicating that the matrix is singular and the
                  solutions X have not been computed.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            A check is made to verify that A is nonsingular.
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>?TBTRS</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
            Factors a symmetric positive definite matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
            Factors a symmetric positive definite matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Single,System.Single@,System.Int32@)">
      <summary>
            Estimates the reciprocal of the condition number of a factored hermitian matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="aNorm">The norm of the matrix.</param>
      <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Single@,System.Int32@)">
      <summary>
            Estimates the reciprocal of the condition number of a factored hermitian matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="aNorm">The norm of the matrix.</param>
      <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyInvert(Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
            Computes the inverse of a factored hermitian matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyInvert(Numerics.NET.MatrixTriangle,System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
            Computes the inverse of a factored hermitian matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskySolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
            Solves a hermitian system of equations.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="nrhs">The number of right hand sides.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the components of the right-hand side(s).</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskySolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
            Solves a hermitian system of equations.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="nrhs">The number of right hand sides.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the components of the right-hand side(s).</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.EigenvalueDecompose(System.Char,System.Char,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes for an N-by-N complex non-symmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <pre>
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of are computed.
            </pre>
      </param>
      <param name="jobvr">
        <pre>
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A. N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="w">
        <pre>
            W is <typeparamref name="TComplex" /> array, dimension (N)
            W contains the computed eigenvalues.
            </pre>
      </param>
      <param name="vl">
        <pre>
            VL is <typeparamref name="TComplex" /> array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            u(j) = VL(:,j), the j-th column of VL.
            </pre>
      </param>
      <param name="ldvl">
        <pre>
            The leading dimension of the array VL.  LDVL &gt;= 1; if
            JOBVL = 'V', LDVL &gt;= N.
            </pre>
      </param>
      <param name="vr">
        <pre>
            VR is <typeparamref name="TComplex" /> array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            v(j) = VR(:,j), the j-th column of VR.
            </pre>
      </param>
      <param name="ldvr">
        <pre>
            The leading dimension of the array VR.  LDVR &gt;= 1; if
            JOBVR = 'V', LDVR &gt;= N.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements and i+1:N of W contain eigenvalues which have
                  converged.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**H * A = lambda(j) * u(j)**H
            where u(j)**H denotes the conjugate transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.EigenvalueDecompose(System.Char,System.Char,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Span{System.Single},System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes for an N-by-N real non-symmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <pre>
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.
            </pre>
      </param>
      <param name="jobvr">
        <pre>
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A. N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="wr">
        <pre>
            WR is <typeparamref name="TReal" /> array, dimension (N)
            </pre>
      </param>
      <param name="wi">
        <pre>
            WI is <typeparamref name="TReal" /> array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.
            </pre>
      </param>
      <param name="vl">
        <pre>
            VL is <typeparamref name="TReal" /> array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).
            </pre>
      </param>
      <param name="ldvl">
        <pre>
            The leading dimension of the array VL.  LDVL &gt;= 1; if
            JOBVL = 'V', LDVL &gt;= N.
            </pre>
      </param>
      <param name="vr">
        <pre>
            VR is <typeparamref name="TReal" /> array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).
            </pre>
      </param>
      <param name="ldvr">
        <pre>
            The leading dimension of the array VR.  LDVR &gt;= 1; if
            JOBVR = 'V', LDVR &gt;= N.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**T * A = lambda(j) * u(j)**T
            where u(j)**T denotes the transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>?GEEV</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.GeneralizedEigenvalueDecompose(System.Char,System.Char,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Span{Numerics.NET.Complex{System.Single}},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes for a pair of N-by-N complex nonsymmetric matrices
            (A,B), the generalized eigenvalues, and optionally, the left and/or
            right generalized eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <code>
            JOBVL is CHARACTER*1
            = 'N':  do not compute the left generalized eigenvectors;
            = 'V':  compute the left generalized eigenvectors.
            </code>
      </param>
      <param name="jobvr">
        <code>
            JOBVR is CHARACTER*1
            = 'N':  do not compute the right generalized eigenvectors;
            = 'V':  compute the right generalized eigenvectors.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A, B, VL, and VR.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the matrix A in the pair (A,B).
            On exit, A has been overwritten.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB, N)
            On entry, the matrix B in the pair (A,B).
            On exit, B has been overwritten.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="alpha">
        <code>
            ALPHA is COMPLEX*16 array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is COMPLEX*16 array, dimension (N)
            On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the
            generalized eigenvalues.
            Note: the quotients ALPHA(j)/BETA(j) may easily over- or
            underflow, and BETA(j) may even be zero.  Thus, the user
            should avoid naively computing the ratio alpha/beta.
            However, ALPHA will be always less than and usually
            comparable with norm(A) in magnitude, and BETA always less
            than and usually comparable with norm(B).
            </code>
      </param>
      <param name="vl">
        <code>
            VL is COMPLEX*16 array, dimension (LDVL,N)
            If JOBVL = 'V', the left generalized eigenvectors u(j) are
            stored one after another in the columns of VL, in the same
            order as their eigenvalues.
            Each eigenvector is scaled so the largest component has
            abs(real part) + abs(imag. part) = 1.
            Not referenced if JOBVL = 'N'.
            </code>
      </param>
      <param name="ldvl">
        <code>
            LDVL is INTEGER
            The leading dimension of the matrix VL. LDVL &gt;= 1, and
            if JOBVL = 'V', LDVL &gt;= N.
            </code>
      </param>
      <param name="vr">
        <code>
            VR is COMPLEX*16 array, dimension (LDVR,N)
            If JOBVR = 'V', the right generalized eigenvectors v(j) are
            stored one after another in the columns of VR, in the same
            order as their eigenvalues.
            Each eigenvector is scaled so the largest component has
            abs(real part) + abs(imag. part) = 1.
            Not referenced if JOBVR = 'N'.
            </code>
      </param>
      <param name="ldvr">
        <code>
            LDVR is INTEGER
            The leading dimension of the matrix VR. LDVR &gt;= 1, and
            if JOBVR = 'V', LDVR &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            =1,...,N:
                  The QZ iteration failed.  No eigenvectors have been
                  calculated, but ALPHA(j) and BETA(j) should be
                  correct for j=INFO+1,...,N.
            &gt; N:  =N+1: other then QZ iteration failed in DHGEQZ,
                  =N+2: error return from DTGEVC.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            A generalized eigenvalue for a pair of matrices (A,B) is a scalar
            lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
            singular. It is usually represented as the pair (alpha,beta), as
            there is a reasonable interpretation for beta=0, and even for both
            being zero.
            The right generalized eigenvector v(j) corresponding to the
            generalized eigenvalue lambda(j) of (A,B) satisfies
                         A * v(j) = lambda(j) * B * v(j).
            The left generalized eigenvector u(j) corresponding to the
            generalized eigenvalues lambda(j) of (A,B) satisfies
                         u(j)**H * A = lambda(j) * u(j)**H * B
            where u(j)**H is the conjugate-transpose of u(j).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  April 2012</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.GeneralizedEigenvalueDecompose(System.Char,System.Char,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Span{System.Single},System.Span{System.Single},System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes for a pair of N-by-N real nonsymmetric matrices (A,B)
            the generalized eigenvalues, and optionally, the left and/or right
            generalized eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <code>
            JOBVL is CHARACTER*1
            = 'N':  do not compute the left generalized eigenvectors;
            = 'V':  compute the left generalized eigenvectors.
            </code>
      </param>
      <param name="jobvr">
        <code>
            JOBVR is CHARACTER*1
            = 'N':  do not compute the right generalized eigenvectors;
            = 'V':  compute the right generalized eigenvectors.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A, B, VL, and VR.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the matrix A in the pair (A,B).
            On exit, A has been overwritten.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the matrix B in the pair (A,B).
            On exit, B has been overwritten.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="alphar">
        <code>
            ALPHAR is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="alphai">
        <code>
            ALPHAI is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
            be the generalized eigenvalues.  If ALPHAI(j) is zero, then
            the j-th eigenvalue is real; if positive, then the j-th and
            (j+1)-st eigenvalues are a complex conjugate pair, with
            ALPHAI(j+1) negative.
            Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
            may easily over- or underflow, and BETA(j) may even be zero.
            Thus, the user should avoid naively computing the ratio
            alpha/beta.  However, ALPHAR and ALPHAI will be always less
            than and usually comparable with norm(A) in magnitude, and
            BETA always less than and usually comparable with norm(B).
            </code>
      </param>
      <param name="vl">
        <code>
            VL is DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order as
            their eigenvalues. If the j-th eigenvalue is real, then
            u(j) = VL(:,j), the j-th column of VL. If the j-th and
            (j+1)-th eigenvalues form a complex conjugate pair, then
            u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
            Each eigenvector is scaled so the largest component has
            abs(real part)+abs(imag. part)=1.
            Not referenced if JOBVL = 'N'.
            </code>
      </param>
      <param name="ldvl">
        <code>
            LDVL is INTEGER
            The leading dimension of the matrix VL. LDVL &gt;= 1, and
            if JOBVL = 'V', LDVL &gt;= N.
            </code>
      </param>
      <param name="vr">
        <code>
            VR is DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order as
            their eigenvalues. If the j-th eigenvalue is real, then
            v(j) = VR(:,j), the j-th column of VR. If the j-th and
            (j+1)-th eigenvalues form a complex conjugate pair, then
            v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
            Each eigenvector is scaled so the largest component has
            abs(real part)+abs(imag. part)=1.
            Not referenced if JOBVR = 'N'.
            </code>
      </param>
      <param name="ldvr">
        <code>
            LDVR is INTEGER
            The leading dimension of the matrix VR. LDVR &gt;= 1, and
            if JOBVR = 'V', LDVR &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1,...,N:
                  The QZ iteration failed.  No eigenvectors have been
                  calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                  should be correct for j=INFO+1,...,N.
            &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.
                  =N+2: error return from DTGEVC.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            A generalized eigenvalue for a pair of matrices (A,B) is a scalar
            lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
            singular. It is usually represented as the pair (alpha,beta), as
            there is a reasonable interpretation for beta=0, and even for both
            being zero.
            The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
            of (A,B) satisfies
                             A * v(j) = lambda(j) * B * v(j).
            The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
            of (A,B) satisfies
                             u(j)**H * A  = lambda(j) * u(j)**H * B .
            where u(j)**H is the conjugate-transpose of u(j).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  April 2012</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.GeneralizedSchurDecompose(System.Char,System.Char,System.Char,System.Func{Numerics.NET.Complex{System.Single},Numerics.NET.Complex{System.Single},System.Boolean},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@,System.Span{Numerics.NET.Complex{System.Single}},System.Span{Numerics.NET.Complex{System.Single}},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
          <code>
            Computes for a pair of N-by-N complex nonsymmetric matrices
            (A,B), the generalized eigenvalues, the generalized complex Schur
            form (S, T), and optionally left and/or right Schur vectors (VSL
            and VSR).
            </code>
        </para>
      </summary>
      <param name="jobvsl">
        <code>
            JOBVSL is CHARACTER*1
            = 'N':  do not compute the left Schur vectors;
            = 'V':  compute the left Schur vectors.
            </code>
      </param>
      <param name="jobvsr">
        <code>
            JOBVSR is CHARACTER*1
            = 'N':  do not compute the right Schur vectors;
            = 'V':  compute the right Schur vectors.
            </code>
      </param>
      <param name="sort">
        <code>
            SORT is CHARACTER*1
            Specifies whether or not to order the eigenvalues on the
            diagonal of the generalized Schur form.
            = 'N':  Eigenvalues are not ordered;
            = 'S':  Eigenvalues are ordered (see SELCTG).
            </code>
      </param>
      <param name="selctg">
        <code>
            SELCTG is a LOGICAL FUNCTION of two COMPLEX*16 arguments
            SELCTG must be declared EXTERNAL in the calling subroutine.
            If SORT = 'N', SELCTG is not referenced.
            If SORT = 'S', SELCTG is used to select eigenvalues to sort
            to the top left of the Schur form.
            An eigenvalue ALPHA(j)/BETA(j) is selected if
            SELCTG(ALPHA(j),BETA(j)) is true.
            Note that a selected complex eigenvalue may no longer satisfy
            SELCTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since
            ordering may change the value of complex eigenvalues
            (especially if the eigenvalue is ill-conditioned), in this
            case INFO is set to N+2 (See INFO below).
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A, B, VSL, and VSR.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the first of the pair of matrices.
            On exit, A has been overwritten by its generalized Schur
            form S.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB, N)
            On entry, the second of the pair of matrices.
            On exit, B has been overwritten by its generalized Schur
            form T.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="sdim">
        <code>
            SDIM is INTEGER
            If SORT = 'N', SDIM = 0.
            If SORT = 'S', SDIM = number of eigenvalues (after sorting)
            for which SELCTG is true.
            </code>
      </param>
      <param name="alpha">
        <code>
            ALPHA is COMPLEX*16 array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is COMPLEX*16 array, dimension (N)
            On exit,  ALPHA(j)/BETA(j), j=1,...,N, will be the
            generalized eigenvalues.  ALPHA(j), j=1,...,N  and  BETA(j),
            j=1,...,N  are the diagonals of the complex Schur form (A,B)
            output by ZGGES. The  BETA(j) will be non-negative real.
            Note: the quotients ALPHA(j)/BETA(j) may easily over- or
            underflow, and BETA(j) may even be zero.  Thus, the user
            should avoid naively computing the ratio alpha/beta.
            However, ALPHA will be always less than and usually
            comparable with norm(A) in magnitude, and BETA always less
            than and usually comparable with norm(B).
            </code>
      </param>
      <param name="vsl">
        <code>
            VSL is COMPLEX*16 array, dimension (LDVSL,N)
            If JOBVSL = 'V', VSL will contain the left Schur vectors.
            Not referenced if JOBVSL = 'N'.
            </code>
      </param>
      <param name="ldvsl">
        <code>
            LDVSL is INTEGER
            The leading dimension of the matrix VSL. LDVSL &gt;= 1, and
            if JOBVSL = 'V', LDVSL &gt;= N.
            </code>
      </param>
      <param name="vsr">
        <code>
            VSR is COMPLEX*16 array, dimension (LDVSR,N)
            If JOBVSR = 'V', VSR will contain the right Schur vectors.
            Not referenced if JOBVSR = 'N'.
            </code>
      </param>
      <param name="ldvsr">
        <code>
            LDVSR is INTEGER
            The leading dimension of the matrix VSR. LDVSR &gt;= 1, and
            if JOBVSR = 'V', LDVSR &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            =1,...,N:
                  The QZ iteration failed.  (A,B) are not in Schur
                  form, but ALPHA(j) and BETA(j) should be correct for
                  j=INFO+1,...,N.
            &gt; N:  =N+1: other than QZ iteration failed in ZHGEQZ
                  =N+2: after reordering, roundoff changed values of
                        some complex eigenvalues so that leading
                        eigenvalues in the Generalized Schur form no
                        longer satisfy SELCTG=.TRUE.  This could also
                        be caused due to scaling.
                  =N+3: reordering failed in ZTGSEN.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            This gives the generalized Schur factorization
                    (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
            where (VSR)**H is the conjugate-transpose of VSR.
            Optionally, it also orders the eigenvalues so that a selected cluster
            of eigenvalues appears in the leading diagonal blocks of the upper
            triangular matrix S and the upper triangular matrix T. The leading
            columns of VSL and VSR then form an unitary basis for the
            corresponding left and right eigenspaces (deflating subspaces).
            (If only the generalized eigenvalues are needed, use the driver
            ZGGEV instead, which is faster.)
            A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
            or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
            usually represented as the pair (alpha,beta), as there is a
            reasonable interpretation for beta=0, and even for both being zero.
            A pair of matrices (S,T) is in generalized complex Schur form if S
            and T are upper triangular and, in addition, the diagonal elements
            of T are non-negative real numbers.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.GeneralizedSchurDecompose(System.Char,System.Char,System.Char,System.Func{System.Single,System.Single,System.Single,System.Boolean},System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Int32@,System.Span{System.Single},System.Span{System.Single},System.Span{System.Single},System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
          <code>
            Computes for a pair of N-by-N real nonsymmetric matrices (A,B),
            the generalized eigenvalues, the generalized real Schur form (S,T),
            optionally, the left and/or right matrices of Schur vectors (VSL and
            VSR).
            </code>
        </para>
      </summary>
      <param name="jobvsl">
        <code>
            JOBVSL is CHARACTER*1
            = 'N':  do not compute the left Schur vectors;
            = 'V':  compute the left Schur vectors.
            </code>
      </param>
      <param name="jobvsr">
        <code>
            JOBVSR is CHARACTER*1
            = 'N':  do not compute the right Schur vectors;
            = 'V':  compute the right Schur vectors.
            </code>
      </param>
      <param name="sort">
        <code>
            SORT is CHARACTER*1
            Specifies whether or not to order the eigenvalues on the
            diagonal of the generalized Schur form.
            = 'N':  Eigenvalues are not ordered;
            = 'S':  Eigenvalues are ordered (see SELCTG);
            </code>
      </param>
      <param name="selctg">
        <code>
            SELCTG is a LOGICAL FUNCTION of three DOUBLE PRECISION arguments
            SELCTG must be declared EXTERNAL in the calling subroutine.
            If SORT = 'N', SELCTG is not referenced.
            If SORT = 'S', SELCTG is used to select eigenvalues to sort
            to the top left of the Schur form.
            An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
            SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
            one of a complex conjugate pair of eigenvalues is selected,
            then both complex eigenvalues are selected.
            Note that in the ill-conditioned case, a selected complex
            eigenvalue may no longer satisfy SELCTG(ALPHAR(j),ALPHAI(j),
            BETA(j)) = .TRUE. after ordering. INFO is to be set to N+2
            in this case.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A, B, VSL, and VSR.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the first of the pair of matrices.
            On exit, A has been overwritten by its generalized Schur
            form S.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the second of the pair of matrices.
            On exit, B has been overwritten by its generalized Schur
            form T.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="sdim">
        <code>
            SDIM is INTEGER
            If SORT = 'N', SDIM = 0.
            If SORT = 'S', SDIM = number of eigenvalues (after sorting)
            for which SELCTG is true.  (Complex conjugate pairs for which
            SELCTG is true for either eigenvalue count as 2.)
            </code>
      </param>
      <param name="alphar">
        <code>
            ALPHAR is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="alphai">
        <code>
            ALPHAI is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
            be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
            and  BETA(j),j=1,...,N are the diagonals of the complex Schur
            form (S,T) that would result if the 2-by-2 diagonal blocks of
            the real Schur form of (A,B) were further reduced to
            triangular form using 2-by-2 complex unitary transformations.
            If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
            positive, then the j-th and (j+1)-st eigenvalues are a
            complex conjugate pair, with ALPHAI(j+1) negative.
            Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
            may easily over- or underflow, and BETA(j) may even be zero.
            Thus, the user should avoid naively computing the ratio.
            However, ALPHAR and ALPHAI will be always less than and
            usually comparable with norm(A) in magnitude, and BETA always
            less than and usually comparable with norm(B).
            </code>
      </param>
      <param name="vsl">
        <code>
            VSL is DOUBLE PRECISION array, dimension (LDVSL,N)
            If JOBVSL = 'V', VSL will contain the left Schur vectors.
            Not referenced if JOBVSL = 'N'.
            </code>
      </param>
      <param name="ldvsl">
        <code>
            LDVSL is INTEGER
            The leading dimension of the matrix VSL. LDVSL &gt;=1, and
            if JOBVSL = 'V', LDVSL &gt;= N.
            </code>
      </param>
      <param name="vsr">
        <code>
            VSR is DOUBLE PRECISION array, dimension (LDVSR,N)
            If JOBVSR = 'V', VSR will contain the right Schur vectors.
            Not referenced if JOBVSR = 'N'.
            </code>
      </param>
      <param name="ldvsr">
        <code>
            LDVSR is INTEGER
            The leading dimension of the matrix VSR. LDVSR &gt;= 1, and
            if JOBVSR = 'V', LDVSR &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1,...,N:
                  The QZ iteration failed.  (A,B) are not in Schur
                  form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
                  be correct for j=INFO+1,...,N.
            &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.
                  =N+2: after reordering, roundoff changed values of
                        some complex eigenvalues so that leading
                        eigenvalues in the Generalized Schur form no
                        longer satisfy SELCTG=.TRUE.  This could also
                        be caused due to scaling.
                  =N+3: reordering failed in DTGSEN.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            This gives the generalized Schur factorization
                     (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
            Optionally, it also orders the eigenvalues so that a selected cluster
            of eigenvalues appears in the leading diagonal blocks of the upper
            quasi-triangular matrix S and the upper triangular matrix T.The
            leading columns of VSL and VSR then form an orthonormal basis for the
            corresponding left and right eigenspaces (deflating subspaces).
            (If only the generalized eigenvalues are needed, use the driver
            DGGEV instead, which is faster.)
            A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
            or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
            usually represented as the pair (alpha,beta), as there is a
            reasonable interpretation for beta=0 or both being zero.
            A pair of matrices (S,T) is in generalized real Schur form if T is
            upper triangular with non-negative diagonal and S is block upper
            triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
            to real generalized eigenvalues, while 2-by-2 blocks of S will be
            "standardized" by making the corresponding elements of T have the
            form:
                    [  a  0  ]
                    [  0  b  ]
            and the pair of corresponding 2-by-2 blocks in S and T will have a
            complex conjugate pair of generalized eigenvalues.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.GeneralizedSingularValueDecompose(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Single},System.Span{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the generalized singular value decomposition (GSVD)
            of an M-by-N complex matrix A and P-by-N complex matrix B:
                  U**H*A*Q = D1*( 0 R ),    V**H*B*Q = D2*( 0 R )
            where U, V and Q are unitary matrices.</para>
      </summary>
      <param name="jobu">
        <code>
            JOBU is CHARACTER*1
            = 'U':  Unitary matrix U is computed;
            = 'N':  U is not computed.
            </code>
      </param>
      <param name="jobv">
        <code>
            JOBV is CHARACTER*1
            = 'V':  Unitary matrix V is computed;
            = 'N':  V is not computed.
            </code>
      </param>
      <param name="jobq">
        <code>
            JOBQ is CHARACTER*1
            = 'Q':  Unitary matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N &gt;= 0.
            </code>
      </param>
      <param name="p">
        <code>
            P is INTEGER
            The number of rows of the matrix B.  P &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            </code>
      </param>
      <param name="l">
        <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose.
            K + L = effective numerical rank of (A**H,B**H)**H.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular matrix R, or part of R.
            See Purpose for details.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains part of the triangular matrix R if
            M-K-L &lt; 0.  See Purpose for details.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB &gt;= max(1,P).
            </code>
      </param>
      <param name="alpha">
        <code>
            ALPHA is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L &gt;= 0,
              ALPHA(K+1:K+L) = C,
              BETA(K+1:K+L)  = S,
            or if M-K-L &lt; 0,
              ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
              BETA(K+1:M) =S, BETA(M+1:K+L) =1
            and
              ALPHA(K+L+1:N) = 0
              BETA(K+L+1:N)  = 0
            </code>
      </param>
      <param name="u">
        <code>
            U is COMPLEX*16 array, dimension (LDU,M)
            If JOBU = 'U', U contains the M-by-M unitary matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
      </param>
      <param name="ldu">
        <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU &gt;= max(1,M) if
            JOBU = 'U'; LDU &gt;= 1 otherwise.
            </code>
      </param>
      <param name="v">
        <code>
            V is COMPLEX*16 array, dimension (LDV,P)
            If JOBV = 'V', V contains the P-by-P unitary matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
      </param>
      <param name="ldv">
        <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV &gt;= max(1,P) if
            JOBV = 'V'; LDV &gt;= 1 otherwise.
            </code>
      </param>
      <param name="q">
        <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the N-by-N unitary matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
      </param>
      <param name="ldq">
        <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ &gt;= max(1,N) if
            JOBQ = 'Q'; LDQ &gt;= 1 otherwise.
            </code>
      </param>
      <param name="ipiv">
        <code>
            IPIV is INTEGER array, dimension (N)
            On exit, IPIV stores the sorting information. More
            precisely, the following loop will sort ALPHA
               for I = K+1, min(M,K+L)
                   swap ALPHA(I) and ALPHA(IPIV(I))
               endfor
            such that ALPHA(1) &gt;= ALPHA(2) &gt;= ... &gt;= ALPHA(N).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = 1, the Jacobi-type procedure failed to
                  converge.  For further details, see subroutine ZTGSJA.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            Let K+L = the effective numerical rank of the
            matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
            triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
            matrices and of the following structures, respectively:
            If M-K-L &gt;= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                              K  L
                   D2 =   L ( 0  S )
                        P-L ( 0  0 )
                            N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 )
                        L (  0    0   R22 )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &lt; 0,
                              K M-K K+L-M
                   D1 =   K ( I  0    0   )
                        M-K ( 0  C    0   )
                                K M-K K+L-M
                   D2 =   M-K ( 0  S    0  )
                        K+L-M ( 0  0    I  )
                          P-L ( 0  0    0  )
                               N-K-L  K   M-K  K+L-M
              ( 0 R ) =     K ( 0    R11  R12  R13  )
                          M-K ( 0     0   R22  R23  )
                        K+L-M ( 0     0    0   R33  )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(M) ),
              S = diag( BETA(K+1),  ... , BETA(M) ),
              C**2 + S**2 = I.
              (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
              ( 0  R22 R23 )
              in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The routine computes C, S, R, and optionally the unitary
            transformation matrices U, V and Q.
            In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
            A and B implicitly gives the SVD of A*inv(B):
                                 A*inv(B) = U*(D1*inv(D2))*V**H.
            If ( A**H,B**H)**H has orthonormal columns, then the GSVD of A and B is also
            equal to the CS decomposition of A and B. Furthermore, the GSVD can
            be used to derive the solution of the eigenvalue problem:
                                 A**H*A x = lambda* B**H*B x.
            In some literature, the GSVD of A and B is presented in the form
                             U**H*A*X = ( 0 D1 ),   V**H*B*X = ( 0 D2 )
            where U and V are orthogonal and X is nonsingular, and D1 and D2 are
            ``diagonal''.  The former GSVD form can be converted to the latter
            form by taking the nonsingular matrix X as
                                  X = Q*(  I   0    )
                                        (  0 inv(R) )
            </code>
        </para>
        <h4> Contributors:</h4>
        <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
        <h4> Further Details:</h4>
        <para>
             ZGGSVD3 replaces the deprecated subroutine ZGGSVD.
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  August 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.GeneralizedSingularValueDecompose(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Span{System.Single},System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the generalized singular value decomposition (GSVD)
            of an M-by-N complex matrix A and P-by-N complex matrix B:
                  U**H*A*Q = D1*( 0 R ),    V**H*B*Q = D2*( 0 R )
            where U, V and Q are unitary matrices.</para>
      </summary>
      <param name="jobu">
        <code>
            JOBU is CHARACTER*1
            = 'U':  Unitary matrix U is computed;
            = 'N':  U is not computed.
            </code>
      </param>
      <param name="jobv">
        <code>
            JOBV is CHARACTER*1
            = 'V':  Unitary matrix V is computed;
            = 'N':  V is not computed.
            </code>
      </param>
      <param name="jobq">
        <code>
            JOBQ is CHARACTER*1
            = 'Q':  Unitary matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N &gt;= 0.
            </code>
      </param>
      <param name="p">
        <code>
            P is INTEGER
            The number of rows of the matrix B.  P &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            </code>
      </param>
      <param name="l">
        <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose.
            K + L = effective numerical rank of (A**H,B**H)**H.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular matrix R, or part of R.
            See Purpose for details.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains part of the triangular matrix R if
            M-K-L &lt; 0.  See Purpose for details.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB &gt;= max(1,P).
            </code>
      </param>
      <param name="alpha">
        <code>
            ALPHA is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L &gt;= 0,
              ALPHA(K+1:K+L) = C,
              BETA(K+1:K+L)  = S,
            or if M-K-L &lt; 0,
              ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
              BETA(K+1:M) =S, BETA(M+1:K+L) =1
            and
              ALPHA(K+L+1:N) = 0
              BETA(K+L+1:N)  = 0
            </code>
      </param>
      <param name="u">
        <code>
            U is COMPLEX*16 array, dimension (LDU,M)
            If JOBU = 'U', U contains the M-by-M unitary matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
      </param>
      <param name="ldu">
        <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU &gt;= max(1,M) if
            JOBU = 'U'; LDU &gt;= 1 otherwise.
            </code>
      </param>
      <param name="v">
        <code>
            V is COMPLEX*16 array, dimension (LDV,P)
            If JOBV = 'V', V contains the P-by-P unitary matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
      </param>
      <param name="ldv">
        <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV &gt;= max(1,P) if
            JOBV = 'V'; LDV &gt;= 1 otherwise.
            </code>
      </param>
      <param name="q">
        <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the N-by-N unitary matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
      </param>
      <param name="ldq">
        <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ &gt;= max(1,N) if
            JOBQ = 'Q'; LDQ &gt;= 1 otherwise.
            </code>
      </param>
      <param name="ipiv">
        <code>
            IPIV is INTEGER array, dimension (N)
            On exit, IPIV stores the sorting information. More
            precisely, the following loop will sort ALPHA
               for I = K+1, min(M,K+L)
                   swap ALPHA(I) and ALPHA(IPIV(I))
               endfor
            such that ALPHA(1) &gt;= ALPHA(2) &gt;= ... &gt;= ALPHA(N).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = 1, the Jacobi-type procedure failed to
                  converge.  For further details, see subroutine ZTGSJA.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            Let K+L = the effective numerical rank of the
            matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
            triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
            matrices and of the following structures, respectively:
            If M-K-L &gt;= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                              K  L
                   D2 =   L ( 0  S )
                        P-L ( 0  0 )
                            N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 )
                        L (  0    0   R22 )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &lt; 0,
                              K M-K K+L-M
                   D1 =   K ( I  0    0   )
                        M-K ( 0  C    0   )
                                K M-K K+L-M
                   D2 =   M-K ( 0  S    0  )
                        K+L-M ( 0  0    I  )
                          P-L ( 0  0    0  )
                               N-K-L  K   M-K  K+L-M
              ( 0 R ) =     K ( 0    R11  R12  R13  )
                          M-K ( 0     0   R22  R23  )
                        K+L-M ( 0     0    0   R33  )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(M) ),
              S = diag( BETA(K+1),  ... , BETA(M) ),
              C**2 + S**2 = I.
              (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
              ( 0  R22 R23 )
              in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The routine computes C, S, R, and optionally the unitary
            transformation matrices U, V and Q.
            In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
            A and B implicitly gives the SVD of A*inv(B):
                                 A*inv(B) = U*(D1*inv(D2))*V**H.
            If ( A**H,B**H)**H has orthonormal columns, then the GSVD of A and B is also
            equal to the CS decomposition of A and B. Furthermore, the GSVD can
            be used to derive the solution of the eigenvalue problem:
                                 A**H*A x = lambda* B**H*B x.
            In some literature, the GSVD of A and B is presented in the form
                             U**H*A*X = ( 0 D1 ),   V**H*B*X = ( 0 D2 )
            where U and V are orthogonal and X is nonsingular, and D1 and D2 are
            ``diagonal''.  The former GSVD form can be converted to the latter
            form by taking the nonsingular matrix X as
                                  X = Q*(  I   0    )
                                        (  0 inv(R) )
            </code>
        </para>
        <h4> Contributors:</h4>
        <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
        <h4> Further Details:</h4>
        <para>
             ZGGSVD3 replaces the deprecated subroutine ZGGSVD.
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  August 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the factorization of a complex Hermitian matrix A
            using the Bunch-Kaufman diagonal pivoting method.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The form of the
            factorization is
               A = U*D*U<sup>H</sup>  or  A = L*D*L<sup>H</sup>
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is Hermitian and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            If UPLO = 'U', then A = U*D*U<sup>H</sup>, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L<sup>H</sup>, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </pre>
        </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianEigenvalueDecompose(System.Char,Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Single},System.Int32@)">
      <summary>
        <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            complex Hermitian matrix A.</para>
      </summary>
      <param name="jobz">
        <pre>
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </pre>
      </param>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="w">
        <pre>
            W is <typeparamref name="TReal" /> array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the sub-matrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
             Modified description of INFO. Sven, 16 Feb 05.
            </para>
        <h4> Contributors:</h4>
        <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{System.Int32},System.Single,System.Single@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a complex
            Hermitian matrix A using the factorization A = U*D*U<sup>H</sup> or
            A = L*D*L<sup>H</sup> computed by ZHETRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
      </param>
      <param name="anorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            The 1-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
        </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianGeneralizedEigenvalueDecompose(System.Int32,System.Char,Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Single},System.Int32@)">
      <summary>
        <para>
            Computes all the eigenvalues, and optionally, the eigenvectors
            of a complex generalized Hermitian-definite eigenproblem, of the form
            A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.</para>
      </summary>
      <param name="itype">
        <code>
            ITYPE is INTEGER
            Specifies the problem type to be solved:
            = 1:  A*x = (lambda)*B*x
            = 2:  A*B*x = (lambda)*x
            = 3:  B*A*x = (lambda)*x
            </code>
      </param>
      <param name="jobz">
        <code>
            JOBZ is CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </code>
      </param>
      <param name="uplo">
        <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangles of A and B are stored;
            = 'L':  Lower triangles of A and B are stored.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A and B.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            matrix Z of eigenvectors.  The eigenvectors are normalized
            as follows:
            if ITYPE = 1 or 2, Z**H*B*Z = I;
            if ITYPE = 3, Z**H*inv(B)*Z = I.
            If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
            or the lower triangle (if UPLO='L') of A, including the
            diagonal, is destroyed.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB, N)
            On entry, the Hermitian matrix B.  If UPLO = 'U', the
            leading N-by-N upper triangular part of B contains the
            upper triangular part of the matrix B.  If UPLO = 'L',
            the leading N-by-N lower triangular part of B contains
            the lower triangular part of the matrix B.
            On exit, if INFO &lt;= N, the part of B containing the matrix is
            overwritten by the triangular factor U or L from the Cholesky
            factorization B = U**H*U or B = L*L**H.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="w">
        <code>
            W is DOUBLE PRECISION array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  ZPOTRF or ZHEEVD returned an error code:
               &lt;= N:  if INFO = i and JOBZ = 'N', then the algorithm
                      failed to converge; i off-diagonal elements of an
                      intermediate tridiagonal form did not converge to
                      zero;
                      if INFO = i and JOBZ = 'V', then the algorithm
                      failed to compute an eigenvalue while working on
                      the submatrix lying in rows and columns INFO/(N+1)
                      through mod(INFO,N+1);
               &gt; N:   if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading
                      minor of order i of B is not positive definite.
                      The factorization of B could not be completed and
                      no eigenvalues or eigenvectors were computed.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            Here A and
            B are assumed to be Hermitian and B is also positive definite.
            If eigenvectors are desired, it uses a divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
        </para>
        <h4> Further Details:</h4>
        <para>
          <code>
            Modified so that no backsubstitution is performed if ZHEEVD fails to
            converge (NEIG in old code could be greater than N causing out of
            bounds reference to A - reported by Ralf Meyer).  Also corrected the
            description of INFO and the test on ITYPE. Sven, 16 Feb 05.
            </code>
        </para>
        <h4> Contributors:</h4>
        <para>
                Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianInvert(Numerics.NET.MatrixTriangle,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the inverse of a complex Hermitian indefinite matrix
            A using the factorization A = U*D*U<sup>H</sup> or A = L*D*L<sup>H</sup> computed by
            ZHETRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by ZHETRF.
            On exit, if INFO = 0, the (Hermitian) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            &gt; 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </pre>
      </param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianSolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{System.Int32},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a complex
            Hermitian matrix A using the factorization A = U*D*U<sup>H</sup> or
            A = L*D*L<sup>H</sup> computed by ZHETRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TComplex" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LQDecompose(System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32@)">
      <summary>
        <para>
            Computes an LQ factorization of a complex M-by-N matrix A:
            A = L * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &lt;= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k)**H . . . H(2)**H H(1)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
            A(i,i+1:n), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LQDecompose(System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32@)">
      <summary>
        <para>
            Computes an LQ factorization of a complex M-by-N matrix A:
            A = L * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &lt;= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k)**H . . . H(2)**H H(1)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
            A(i,i+1:n), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LQOrthogonalMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGELQF in the first k rows of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(2) H(1)
            as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LQUnitaryMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k)**H .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGELQF in the first k rows of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGELQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(2)**H H(1)**H
            as returned by ZGELQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUDecompose(System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>ZGETRF computes an LU decomposition of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
        <para>
            The decomposition has the form</para>
        <para>
          <center>A = P * L * U</center>.</para>
        <para>where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m &gt; n), and U is upper
            triangular (upper trapezoidal if m &lt; n).
            </para>
        <para>
            This is the right-looking Level 3 BLAS version of the algorithm.
            </para>
      </summary>
      <param name="m">An integer specifying the number of rows
            of the matrix <paramref name="a" />. Must be greater than
            or equal to zero.</param>
      <param name="n">An integer specifying the number of
            columns of the matrix <paramref name="a" />. Must be
            greater than or equal to zero.
            </param>
      <param name="a">complex array specifying the
            <paramref name="m" />-by-<paramref name="n" /> matrix
            to be factored. On exit, the factors L and U from the
            decomposition A = P*L*U; the unit diagonal elements of
            L are not stored.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="ipiv">Integer array of length
            min(<paramref name="m" />,<paramref name="n" />) that
            will hold the pivot indexes. Row <i>i</i> of the
            matrix was interchanged with row
            <paramref name="ipiv" />[<i>i</i>].</param>
      <param name="info">Reference to an integer containing a
            result code. Zero indicates success. Greater than zero
            indicates U(i,i) is exactly zero. The decomposition
            has been completed, but the factor U is exactly
            singular, and division by zero will occur if it is used
            to solve a system of equations.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUDecompose(System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>ZGETRF computes an LU decomposition of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
        <para>
            The decomposition has the form</para>
        <para>
          <center>A = P * L * U</center>.</para>
        <para>where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m &gt; n), and U is upper
            triangular (upper trapezoidal if m &lt; n).
            </para>
        <para>
            This is the right-looking Level 3 BLAS version of the algorithm.
            </para>
      </summary>
      <param name="m">An integer specifying the number of rows
            of the matrix <paramref name="a" />. Must be greater than
            or equal to zero.</param>
      <param name="n">An integer specifying the number of
            columns of the matrix <paramref name="a" />. Must be
            greater than or equal to zero.
            </param>
      <param name="a">complex array specifying the
            <paramref name="m" />-by-<paramref name="n" /> matrix
            to be factored. On exit, the factors L and U from the
            decomposition A = P*L*U; the unit diagonal elements of
            L are not stored.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="ipiv">Integer array of length
            min(<paramref name="m" />,<paramref name="n" />) that
            will hold the pivot indexes. Row <i>i</i> of the
            matrix was interchanged with row
            <paramref name="ipiv" />[<i>i</i>].</param>
      <param name="info">Reference to an integer containing a
            result code. Zero indicates success. Greater than zero
            indicates U(i,i) is exactly zero. The decomposition
            has been completed, but the factor U is exactly
            singular, and division by zero will occur if it is used
            to solve a system of equations.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUEstimateCondition(Numerics.NET.MatrixNorm,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Single,System.Single@,System.Int32@)">
      <summary>
             ZGECON estimates the reciprocal of the condition number of a general
             real matrix A, inthis. either the 1-norm or the infinity-norm, using
             the LU decomposition computed by ZGETRF.
            
             An estimate is obtained for norm(inv(A)), and the reciprocal of the
             condition number is computed as
                RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            
             Arguments
             =========
            
             NORM    (input) CHARACTER*1
             Specifies whether the 1-norm condition number or the
             infinity-norm condition number is required:
                = '1' or 'O':  1-norm;
                = 'I':         Infinity-norm.
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             A       (input) DOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             ANORM   (input) DOUBLE PRECISION
             If NORM = '1' or 'O', the 1-norm of the original matrix A.
             If NORM = 'I', the infinity-norm of the original matrix A.
            
             RCOND   (output) DOUBLE PRECISION
             The reciprocal of the condition number of the matrix A,
             computed as RCOND = 1/(norm(A) * norm(inv(A))).
            
             WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
            
             IWORK   (workspace) INTEGER array, dimension (N)
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
            
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUEstimateCondition(Numerics.NET.MatrixNorm,System.Int32,System.Span{System.Single},System.Int32,System.Single,System.Single@,System.Int32@)">
      <summary>
             ZGECON estimates the reciprocal of the condition number of a general
             real matrix A, inthis. either the 1-norm or the infinity-norm, using
             the LU decomposition computed by ZGETRF.
            
             An estimate is obtained for norm(inv(A)), and the reciprocal of the
             condition number is computed as
                RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            
             Arguments
             =========
            
             NORM    (input) CHARACTER*1
             Specifies whether the 1-norm condition number or the
             infinity-norm condition number is required:
                = '1' or 'O':  1-norm;
                = 'I':         Infinity-norm.
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             A       (input) DOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             ANORM   (input) DOUBLE PRECISION
             If NORM = '1' or 'O', the 1-norm of the original matrix A.
             If NORM = 'I', the infinity-norm of the original matrix A.
            
             RCOND   (output) DOUBLE PRECISION
             The reciprocal of the condition number of the matrix A,
             computed as RCOND = 1/(norm(A) * norm(inv(A))).
            
             WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
            
             IWORK   (workspace) INTEGER array, dimension (N)
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
            
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUInvert(System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
             ZGETRI computes the inverse of a matrix using the LU decomposition
             computed by ZGETRF.
            
             This method inverts U and then computes inv(A) by solving the system
             inv(A)*L = inv(U) for inv(A).
            
             Arguments
             =========
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the factors L and U from the decomposition
             A = P*L*U as computed by ZGETRF.
             On exit, if INFO = 0, the inverse of the original matrix A.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO =0, then WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK &gt;= Max(1,N).
             For optimal performance LWORK &gt;= N*NB, where NB is
             the optimal blocksize returned by ILAENV.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
             &gt; 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
             singular and its inverse could not be computed.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUInvert(System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
             ZGETRI computes the inverse of a matrix using the LU decomposition
             computed by ZGETRF.
            
             This method inverts U and then computes inv(A) by solving the system
             inv(A)*L = inv(U) for inv(A).
            
             Arguments
             =========
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the factors L and U from the decomposition
             A = P*L*U as computed by ZGETRF.
             On exit, if INFO = 0, the inverse of the original matrix A.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO =0, then WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK &gt;= Max(1,N).
             For optimal performance LWORK &gt;= N*NB, where NB is
             the optimal blocksize returned by ILAENV.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
             &gt; 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
             singular and its inverse could not be computed.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Int32},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
             ZGETRS solves a system of linear equations
                A * X = B  or  A' * X = B
             with a general N-by-N matrix A using the LU decomposition computed
             by ZGETRF.
            
             Arguments
             =========
            
             TRANS   (input) CHARACTER*1
             Specifies the form of the system of equations:
                = 'N':  A * X = B  (No transpose)
                = TransposeOperation.Transpose:  A'* X = B  (Transpose)
                = 'C':  A'* X = B  (Conjugate transpose = Transpose)
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             NRHS    (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS &gt;= 0.
            
             A       (input) DOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the right hand side matrix B.
             On exit, the solution matrix X.
            
             LDB     (input) INTEGER
             The leading dimension of the array B.  LDB &gt;= Max(1,N).
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
             =====================================================================
            
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Int32},System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
             ZGETRS solves a system of linear equations
                A * X = B  or  A' * X = B
             with a general N-by-N matrix A using the LU decomposition computed
             by ZGETRF.
            
             Arguments
             =========
            
             TRANS   (input) CHARACTER*1
             Specifies the form of the system of equations:
                = 'N':  A * X = B  (No transpose)
                = TransposeOperation.Transpose:  A'* X = B  (Transpose)
                = 'C':  A'* X = B  (Conjugate transpose = Transpose)
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             NRHS    (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS &gt;= 0.
            
             A       (input) DOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the right hand side matrix B.
             On exit, the solution matrix X.
            
             LDB     (input) INTEGER
             The leading dimension of the array B.  LDB &gt;= Max(1,N).
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
             =====================================================================
            
            </summary>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.Name">
      <summary>
            Gets the name of the implementation.
            </summary>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.Platform">
      <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.QLDecompose(System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32@)">
      <summary>
        <para>
            Computes a QL factorization of a complex M-by-N matrix A:
            A = Q * L.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &gt;= n, the lower triangle of the subarray
            A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
            if m &lt;= n, the elements on and below the (n-m)-th
            superdiagonal contain the M-by-N lower trapezoidal matrix L;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of elementary reflectors
            (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k) . . . H(2) H(1), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
            A(1:m-k+i-1,n-k+i), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.QLDecompose(System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32@)">
      <summary>
        <para>
            Computes a QL factorization of a complex M-by-N matrix A:
            A = Q * L.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &gt;= n, the lower triangle of the subarray
            A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
            if m &lt;= n, the elements on and below the (n-m)-th
            superdiagonal contain the M-by-N lower trapezoidal matrix L;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of elementary reflectors
            (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k) . . . H(2) H(1), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
            A(1:m-k+i-1,n-k+i), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.QLOrthogonalMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQLF in the last k columns of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQLF.
            </code>
      </param>
      <param name="c">
        <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(2) H(1)
            as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.QLUnitaryMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Transpose, apply Q**H.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQLF in the last k columns of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQLF.
            </code>
      </param>
      <param name="c">
        <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(2) H(1)
            as returned by ZGEQLF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.QRDecompose(System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32@)">
      <summary>
             ZGEQRF computes a QR decomposition of a real M-by-N matrix A:
             A = Q * R.
            
             Arguments
             =========
            
             M       (input) INTEGER
             The number of rows of the matrix A.  M &gt;= 0.
            
             N       (input) INTEGER
             The number of columns of the matrix A.  N &gt;= 0.
            
             A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the elements on and above the diagonal of the array
             contain the min(M,N)-by-N upper trapezoidal matrix R (R is
             upper triangular if m &gt;= n); the elements below the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of min(m,n) elementary reflectors (see Further
             Zetails).
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= max(1,M).
            
             TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Zetails).
            
             WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK &gt;= max(1,N).
             For optimum performance LWORK &gt;= N*NB, where NB is
             the optimal blocksize.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
             Further Zetails
             ===============
            
             The matrix Q is represented as a product of elementary reflectors
            
                Q = H(1) H(2) . . . H(k), where k = min(m,n).
            
             Each H(i) has the form
            
                H(i) = I - tau * v * v'
            
             where tau is a real scalar, and v is a real vector with
             v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit inthis. A(i+1:m,i),
             and tau inthis. TAU(i).
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.QRDecompose(System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Int32},System.Span{System.Single},System.Int32@)">
      <summary>
        <para>
            Computes a QR factorization with column pivoting of a
            matrix A:  A*P = Q*R  using Level 3 BLAS.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A. M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper trapezoidal matrix R; the elements below
            the diagonal, together with the array TAU, represent the
            orthogonal matrix Q as a product of min(M,N) elementary
            reflectors.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A. LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="jpvt">
        <pre>
            Dimension (N)
            On entry, if JPVT(J).ne.0, the J-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(J)=0,
            the J-th column of A is a free column.
            On exit, if JPVT(J)=K, then the J-th column of A*P was the
            the K-th column of A.
            </pre>
      </param>
      <param name="tau">
        <pre>
            TAU is <typeparamref name="TReal" /> array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0: successful exit.
            &lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </pre>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <pre>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real/complex scalar, and v is a real/complex vector
            with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
            A(i+1:m,i), and tau in TAU(i).
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
        <para>This method corresponds to the LAPACK routine <c>DGEQP3</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.QRDecompose(System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32@)">
      <summary>
             ZGEQRF computes a QR decomposition of a real M-by-N matrix A:
             A = Q * R.
            
             Arguments
             =========
            
             M       (input) INTEGER
             The number of rows of the matrix A.  M &gt;= 0.
            
             N       (input) INTEGER
             The number of columns of the matrix A.  N &gt;= 0.
            
             A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the elements on and above the diagonal of the array
             contain the min(M,N)-by-N upper trapezoidal matrix R (R is
             upper triangular if m &gt;= n); the elements below the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of min(m,n) elementary reflectors (see Further
             Zetails).
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= max(1,M).
            
             TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Zetails).
            
             WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK &gt;= max(1,N).
             For optimum performance LWORK &gt;= N*NB, where NB is
             the optimal blocksize.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
             Further Zetails
             ===============
            
             The matrix Q is represented as a product of elementary reflectors
            
                Q = H(1) H(2) . . . H(k), where k = min(m,n).
            
             Each H(i) has the form
            
                H(i) = I - tau * v * v'
            
             where tau is a real scalar, and v is a real vector with
             v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit inthis. A(i+1:m,i),
             and tau inthis. TAU(i).
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.QROrthogonalMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q<sup>T</sup> * C       C * Q<sup>T</sup>
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
      </summary>
      <param name="side">
        <pre>
            = 'L': apply Q or Q<sup>T</sup> from the Left;
            = 'R': apply Q or Q<sup>T</sup> from the Right.
            </pre>
      </param>
      <param name="trans">
        <pre>
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q<sup>T</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the matrix C. M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix C. N &gt;= 0.
            </pre>
      </param>
      <param name="k">
        <pre>
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="tau">
        <pre>
            TAU is <typeparamref name="TReal" /> array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is <typeparamref name="TReal" /> array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q<sup>T</sup>*C or C*Q<sup>T</sup> or C*Q.
            </pre>
      </param>
      <param name="ldc">
        <pre>
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            . . H(k)
            as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>?ORMQR</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.QRUnitaryMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q<sup>H</sup> * C       C * Q<sup>H</sup>
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
      </summary>
      <param name="side">
        <pre>
            = 'L': apply Q or Q<sup>H</sup> from the Left;
            = 'R': apply Q or Q<sup>H</sup> from the Right.
            </pre>
      </param>
      <param name="trans">
        <pre>
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q<sup>H</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the matrix C. M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix C. N &gt;= 0.
            </pre>
      </param>
      <param name="k">
        <pre>
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQRF in the first k columns of its array argument A.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="tau">
        <pre>
            TAU is <typeparamref name="TComplex" /> array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQRF.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is <typeparamref name="TComplex" /> array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q<sup>H</sup>*C or C*Q<sup>H</sup> or C*Q.
            </pre>
      </param>
      <param name="ldc">
        <pre>
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            . . H(k)
            as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </pre>
        </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.RQDecompose(System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32@)">
      <summary>
        <para>
            Computes an RQ factorization of a complex M-by-N matrix A:
            A = R * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &lt;= n, the upper triangle of the subarray
            A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
            if m &gt;= n, the elements on and above the (m-n)-th subdiagonal
            contain the M-by-N upper trapezoidal matrix R;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of min(m,n) elementary
            reflectors (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1)**H H(2)**H . . . H(k)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
            exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.RQDecompose(System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32@)">
      <summary>
        <para>
            Computes an RQ factorization of a complex M-by-N matrix A:
            A = R * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &lt;= n, the upper triangle of the subarray
            A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
            if m &gt;= n, the elements on and above the (m-n)-th subdiagonal
            contain the M-by-N upper trapezoidal matrix R;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of min(m,n) elementary
            reflectors (see Further Details).
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
          <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1)**H H(2)**H . . . H(k)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
            exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.RQOrthogonalMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGERQF in the last k rows of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGERQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(k)
            as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.RQUnitaryMultiply(Numerics.NET.MatrixOperationSide,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1)**H H(2)**H .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Transpose, apply Q**H.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGERQF in the last k rows of its array argument A.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGERQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
      </param>
      <param name="ldc">
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
      <remarks>
        <para>
          <code>
            . . H(k)**H
            as returned by ZGERQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SchurDecompose(System.Char,System.Char,System.Func{Numerics.NET.Complex{System.Single},System.Boolean},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@,System.Span{Numerics.NET.Complex{System.Single}},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
          <code>
            Computes for an N-by-N complex nonsymmetric matrix A, the
            eigenvalues, the Schur form T, and, optionally, the matrix of Schur
            vectors Z.
            </code>
        </para>
      </summary>
      <param name="jobvs">
        <code>
            JOBVS is CHARACTER*1
            = 'N': Schur vectors are not computed;
            = 'V': Schur vectors are computed.
            </code>
      </param>
      <param name="sort">
        <code>
            SORT is CHARACTER*1
            Specifies whether or not to order the eigenvalues on the
            diagonal of the Schur form.
            = 'N': Eigenvalues are not ordered:
            = 'S': Eigenvalues are ordered (see SELECT).
            </code>
      </param>
      <param name="select">
        <code>
            SELECT is a LOGICAL FUNCTION of one COMPLEX*16 argument
            SELECT must be declared EXTERNAL in the calling subroutine.
            If SORT = 'S', SELECT is used to select eigenvalues to order
            to the top left of the Schur form.
            IF SORT = 'N', SELECT is not referenced.
            The eigenvalue W(j) is selected if SELECT(W(j)) is true.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrix A. N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten by its Schur form T.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="sdim">
        <code>
            SDIM is INTEGER
            If SORT = 'N', SDIM = 0.
            If SORT = 'S', SDIM = number of eigenvalues for which
                           SELECT is true.
            </code>
      </param>
      <param name="w">
        <code>
            W is COMPLEX*16 array, dimension (N)
            W contains the computed eigenvalues, in the same order that
            they appear on the diagonal of the output Schur form T.
            </code>
      </param>
      <param name="vs">
        <code>
            VS is COMPLEX*16 array, dimension (LDVS,N)
            If JOBVS = 'V', VS contains the unitary matrix Z of Schur
            vectors.
            If JOBVS = 'N', VS is not referenced.
            </code>
      </param>
      <param name="ldvs">
        <code>
            LDVS is INTEGER
            The leading dimension of the array VS.  LDVS &gt;= 1; if
            JOBVS = 'V', LDVS &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value.
            &gt; 0: if INFO = i, and i is
                 &lt;= N:  the QR algorithm failed to compute all the
                        eigenvalues; elements 1:ILO-1 and i+1:N of W
                        contain those eigenvalues which have converged;
                        if JOBVS = 'V', VS contains the matrix which
                        reduces A to its partially converged Schur form.
                 = N+1: the eigenvalues could not be reordered because
                        some eigenvalues were too close to separate (the
                        problem is very ill-conditioned);
                 = N+2: after reordering, roundoff changed values of
                        some complex eigenvalues so that leading
                        eigenvalues in the Schur form no longer satisfy
                        SELECT = .TRUE..  This could also be caused by
                        underflow due to scaling.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            This gives the Schur factorization A = Z*T*(Z**H).
            Optionally, it also orders the eigenvalues on the diagonal of the
            Schur form so that selected eigenvalues are at the top left.
            The leading columns of Z then form an orthonormal basis for the
            invariant subspace corresponding to the selected eigenvalues.
            A complex matrix is in Schur form if it is upper triangular.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SchurDecompose(System.Char,System.Char,System.Func{System.Single,System.Single,System.Boolean},System.Int32,System.Span{System.Single},System.Int32,System.Int32@,System.Span{System.Single},System.Span{System.Single},System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
          <code>
            Computes for an N-by-N real nonsymmetric matrix A, the
            eigenvalues, the real Schur form T, and, optionally, the matrix of
            Schur vectors Z.
            </code>
        </para>
      </summary>
      <param name="jobvs">
        <code>
            JOBVS is CHARACTER*1
            = 'N': Schur vectors are not computed;
            = 'V': Schur vectors are computed.
            </code>
      </param>
      <param name="sort">
        <code>
            SORT is CHARACTER*1
            Specifies whether or not to order the eigenvalues on the
            diagonal of the Schur form.
            = 'N': Eigenvalues are not ordered;
            = 'S': Eigenvalues are ordered (see SELECT).
            </code>
      </param>
      <param name="select">
        <code>
            SELECT is a LOGICAL FUNCTION of two DOUBLE PRECISION arguments
            SELECT must be declared EXTERNAL in the calling subroutine.
            If SORT = 'S', SELECT is used to select eigenvalues to sort
            to the top left of the Schur form.
            If SORT = 'N', SELECT is not referenced.
            An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
            SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex
            conjugate pair of eigenvalues is selected, then both complex
            eigenvalues are selected.
            Note that a selected complex eigenvalue may no longer
            satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
            ordering may change the value of complex eigenvalues
            (especially if the eigenvalue is ill-conditioned); in this
            case INFO is set to N+2 (see INFO below).
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrix A. N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten by its real Schur form T.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="sdim">
        <code>
            SDIM is INTEGER
            If SORT = 'N', SDIM = 0.
            If SORT = 'S', SDIM = number of eigenvalues (after sorting)
                           for which SELECT is true. (Complex conjugate
                           pairs for which SELECT is true for either
                           eigenvalue count as 2.)
            </code>
      </param>
      <param name="wr">
        <code>
            WR is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="wi">
        <code>
            WI is DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues in the same order
            that they appear on the diagonal of the output Schur form T.
            Complex conjugate pairs of eigenvalues will appear
            consecutively with the eigenvalue having the positive
            imaginary part first.
            </code>
      </param>
      <param name="vs">
        <code>
            VS is DOUBLE PRECISION array, dimension (LDVS,N)
            If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
            vectors.
            If JOBVS = 'N', VS is not referenced.
            </code>
      </param>
      <param name="ldvs">
        <code>
            LDVS is INTEGER
            The leading dimension of the array VS.  LDVS &gt;= 1; if
            JOBVS = 'V', LDVS &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value.
            &gt; 0: if INFO = i, and i is
               &lt;= N: the QR algorithm failed to compute all the
                     eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
                     contain those eigenvalues which have converged; if
                     JOBVS = 'V', VS contains the matrix which reduces A
                     to its partially converged Schur form.
               = N+1: the eigenvalues could not be reordered because some
                     eigenvalues were too close to separate (the problem
                     is very ill-conditioned);
               = N+2: after reordering, roundoff changed values of some
                     complex eigenvalues so that leading eigenvalues in
                     the Schur form no longer satisfy SELECT=.TRUE.  This
                     could also be caused by underflow due to scaling.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            This gives the Schur factorization A = Z*T*(Z**T).
            Optionally, it also orders the eigenvalues on the diagonal of the
            real Schur form so that selected eigenvalues are at the top left.
            The leading columns of Z then form an orthonormal basis for the
            invariant subspace corresponding to the selected eigenvalues.
            A matrix is in real Schur form if it is upper quasi-triangular with
            1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
            form
                    [  a  b  ]
                    [  c  a  ]
            where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SingularValueDecompose(System.Char,System.Int32,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors, by using divide-and-conquer method.</para>
      </summary>
      <param name="jobz">
        <pre>
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V<sup>H</sup> are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V<sup>H</sup> are returned in the arrays U
                    and VT;
            = 'O':  If M &gt;= N, the first N columns of U are overwritten
                    in the array A and all rows of V<sup>H</sup> are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V<sup>H</sup> are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V<sup>H</sup> are computed.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the input matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the input matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M &gt;= N;
                            A is overwritten with the first M rows
                            of V<sup>H</sup> (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="s">
        <pre>
            S is <typeparamref name="TReal" /> array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) &gt;= S(i+1).
            </pre>
      </param>
      <param name="u">
        <pre>
            U is <typeparamref name="TComplex" /> array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
            unitary matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.
            </pre>
      </param>
      <param name="ldu">
        <pre>
            The leading dimension of the array U.  LDU &gt;= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.
            </pre>
      </param>
      <param name="vt">
        <pre>
            VT is <typeparamref name="TComplex" /> array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the
            N-by-N unitary matrix V<sup>H</sup>;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V<sup>H</sup> (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
            </pre>
      </param>
      <param name="ldvt">
        <pre>
            The leading dimension of the array VT.  LDVT &gt;= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N;
            if JOBZ = 'S', LDVT &gt;= min(M,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  The updating process of DBDSDC did not converge.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The SVD is written
                 A = U * SIGMA * conjugate-transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V<sup>H</sup>, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SingularValueDecompose(System.Char,System.Int32,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors, by using divide-and-conquer method.</para>
      </summary>
      <param name="jobz">
        <pre>
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V<sup>H</sup> are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V<sup>H</sup> are returned in the arrays U
                    and VT;
            = 'O':  If M &gt;= N, the first N columns of U are overwritten
                    in the array A and all rows of V<sup>H</sup> are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V<sup>H</sup> are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V<sup>H</sup> are computed.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the input matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the input matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TComplex" /> array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M &gt;= N;
                            A is overwritten with the first M rows
                            of V<sup>H</sup> (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="s">
        <pre>
            S is <typeparamref name="TReal" /> array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) &gt;= S(i+1).
            </pre>
      </param>
      <param name="u">
        <pre>
            U is <typeparamref name="TComplex" /> array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
            unitary matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.
            </pre>
      </param>
      <param name="ldu">
        <pre>
            The leading dimension of the array U.  LDU &gt;= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.
            </pre>
      </param>
      <param name="vt">
        <pre>
            VT is <typeparamref name="TComplex" /> array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the
            N-by-N unitary matrix V<sup>H</sup>;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V<sup>H</sup> (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
            </pre>
      </param>
      <param name="ldvt">
        <pre>
            The leading dimension of the array VT.  LDVT &gt;= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N;
            if JOBZ = 'S', LDVT &gt;= min(M,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  The updating process of DBDSDC did not converge.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The SVD is written
                 A = U * SIGMA * conjugate-transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V<sup>H</sup>, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricDecompose(Numerics.NET.MatrixTriangle,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the factorization of a real symmetric matrix A using
            the Bunch-Kaufman diagonal pivoting method.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            The form of the
            factorization is
               A = U*D*U<sup>T</sup>  or  A = L*D*L<sup>T</sup>
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is symmetric and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            If UPLO = 'U', then A = U*D*U<sup>T</sup>, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L<sup>T</sup>, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>?SYTRF</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricEigenvalueDecompose(System.Char,Numerics.NET.MatrixTriangle,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32@)">
      <summary>
        <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            real symmetric matrix A.</para>
      </summary>
      <param name="jobz">
        <pre>
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </pre>
      </param>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="w">
        <pre>
            W is <typeparamref name="TReal" /> array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the sub-matrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            Because of large use of BLAS of level 3, DSYEVD needs N**2 more
            workspace than DSYEVX.
            </pre>
        </para>
        <h4> Contributors:</h4>
        <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee \n
             Modified description of INFO. Sven, 16 Feb 05. \n
            </para>
        <para>This method corresponds to the LAPACK routine <c>DSYEVD</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricEstimateCondition(Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Int32},System.Single,System.Single@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric matrix A using the factorization
            A = U*D*U<sup>T</sup> or A = L*D*L<sup>T</sup> computed by DSYTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
      </param>
      <param name="anorm">
        <pre>
            ANORM is <typeparamref name="TReal" />
            The 1-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            RCOND is <typeparamref name="TReal" />
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
        </para>
        <para>This method corresponds to the LAPACK routine <c>?SYCON</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricGeneralizedEigenvalueDecompose(System.Int32,System.Char,Numerics.NET.MatrixTriangle,System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32@)">
      <summary>
        <para>
            Computes all the eigenvalues, and optionally, the eigenvectors
            of a real generalized symmetric-definite eigenproblem, of the form
            A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.</para>
      </summary>
      <param name="itype">
        <code>
            ITYPE is INTEGER
            Specifies the problem type to be solved:
            = 1:  A*x = (lambda)*B*x
            = 2:  A*B*x = (lambda)*x
            = 3:  B*A*x = (lambda)*x
            </code>
      </param>
      <param name="jobz">
        <code>
            JOBZ is CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </code>
      </param>
      <param name="uplo">
        <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangles of A and B are stored;
            = 'L':  Lower triangles of A and B are stored.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A and B.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            matrix Z of eigenvectors.  The eigenvectors are normalized
            as follows:
            if ITYPE = 1 or 2, Z**T*B*Z = I;
            if ITYPE = 3, Z**T*inv(B)*Z = I.
            If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
            or the lower triangle (if UPLO='L') of A, including the
            diagonal, is destroyed.
            </code>
      </param>
      <param name="lda">
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the symmetric matrix B.  If UPLO = 'U', the
            leading N-by-N upper triangular part of B contains the
            upper triangular part of the matrix B.  If UPLO = 'L',
            the leading N-by-N lower triangular part of B contains
            the lower triangular part of the matrix B.
            On exit, if INFO &lt;= N, the part of B containing the matrix is
            overwritten by the triangular factor U or L from the Cholesky
            factorization B = U**T*U or B = L*L**T.
            </code>
      </param>
      <param name="ldb">
        <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="w">
        <code>
            W is DOUBLE PRECISION array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  DPOTRF or DSYEVD returned an error code:
               &lt;= N:  if INFO = i and JOBZ = 'N', then the algorithm
                      failed to converge; i off-diagonal elements of an
                      intermediate tridiagonal form did not converge to
                      zero;
                      if INFO = i and JOBZ = 'V', then the algorithm
                      failed to compute an eigenvalue while working on
                      the submatrix lying in rows and columns INFO/(N+1)
                      through mod(INFO,N+1);
               &gt; N:   if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading
                      minor of order i of B is not positive definite.
                      The factorization of B could not be completed and
                      no eigenvalues or eigenvectors were computed.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            Here A and
            B are assumed to be symmetric and B is also positive definite.
            If eigenvectors are desired, it uses a divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
        </para>
        <h4> Further Details:</h4>
        <para>
          <code>
            Modified so that no backsubstitution is performed if DSYEVD fails to
            converge (NEIG in old code could be greater than N causing out of
            bounds reference to A - reported by Ralf Meyer).  Also corrected the
            description of INFO and the test on ITYPE. Sven, 16 Feb 05.
            </code>
        </para>
        <h4> Contributors:</h4>
        <para>
                Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
            </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2015</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricInvert(Numerics.NET.MatrixTriangle,System.Int32,System.Span{System.Single},System.Int32,System.ReadOnlySpan{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the inverse of a real symmetric indefinite matrix
            A using the factorization A = U*D*U<sup>T</sup> or A = L*D*L<sup>T</sup> computed by
            DSYTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by DSYTRF.
            On exit, if INFO = 0, the (symmetric) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            &gt; 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </pre>
      </param>
      <remarks>
        <para>This method corresponds to the LAPACK routine <c>?SYTRI</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricSolve(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Int32},System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a real
            symmetric matrix A using the factorization A = U*D*U<sup>T</sup> or
            A = L*D*L<sup>T</sup> computed by DSYTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is <typeparamref name="TReal" /> array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </pre>
      </param>
      <param name="lda">
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is <typeparamref name="TReal" /> array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
      </param>
      <remarks>
        <para>This method corresponds to the LAPACK routine <c>?SYTRS</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricTridiagonalEigenvalueDecompose(System.Char,System.Int32,System.Span{System.Single},System.Span{System.Single},System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
        <para>
          <code>
            Computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the implicit QL or QR method.
            </code>
        </para>
      </summary>
      <param name="compz">
        <code>
            COMPZ is CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'V':  Compute eigenvalues and eigenvectors of the original
                    symmetric matrix.  On entry, Z must contain the
                    orthogonal matrix used to reduce the original matrix
                    to tridiagonal form.
            = 'I':  Compute eigenvalues and eigenvectors of the
                    tridiagonal matrix.  Z is initialized to the identity
                    matrix.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrix.  N &gt;= 0.
            </code>
      </param>
      <param name="d">
        <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
      </param>
      <param name="e">
        <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.
            </code>
      </param>
      <param name="z">
        <code>
            Z is DOUBLE PRECISION array, dimension (LDZ, N)
            On entry, if  COMPZ = 'V', then Z contains the orthogonal
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original symmetric matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If COMPZ = 'N', then Z is not referenced.
            </code>
      </param>
      <param name="ldz">
        <code>
            LDZ is INTEGER
            The leading dimension of the array Z.  LDZ &gt;= 1, and if
            eigenvectors are desired, then  LDZ &gt;= max(1,N).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  the algorithm has failed to find all the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero; on exit, D
                  and E contain the elements of a symmetric tridiagonal
                  matrix which is orthogonally similar to the original
                  matrix.
            </code>
      </param>
      <remarks>
        <para>
          <code>
            The eigenvectors of a full or band symmetric matrix can also be found
            if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
            tridiagonal form.
            </code>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularEstimateCondition(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Single@,System.Int32@)">
      <summary>
            Approximates the reciprocal of the condition number of a complex triangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> value that specifies which norm to use in the expression for the condition number.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularEstimateCondition(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Single@,System.Int32@)">
      <summary>
            Approximates the reciprocal of the condition number of a complex triangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> value that specifies which norm to use in the expression for the condition number.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularInvert(Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
            Computes the inverse of a complex triangular matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularInvert(Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
            Computes the inverse of a complex triangular matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularSolve(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Int32@)">
      <summary>
            Solves a complex triangular system of equations.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="trans">A <see cref="T:Numerics.NET.TransposeOperation" /> value that indicates if the matrix should be transposed or not.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="nrhs">The number of right hand sides.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the components of the right-hand side(s).</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularSolve(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Int32@)">
      <summary>
            Solves a complex triangular system of equations.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="trans">A <see cref="T:Numerics.NET.TransposeOperation" /> value that indicates if the matrix should be transposed or not.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="nrhs">The number of right hand sides.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the components of the right-hand side(s).</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="T:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle">
      <summary>
            Contains the default implementation for the 
            BLAS for single precision real numbers.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.#ctor">
      <summary>
            Constructs a new managed linear algebra implementation 
            for single precision real and complex vectors and matrices.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.AbsoluteMaxIndex(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Finds the index of element having max.</para>
      </summary>
      <param name="n">The number of elements in the vector <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in the storage array.</param>
      <remarks>
        <para>
          <pre>
            absolute value.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 1/15/85.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.AbsoluteMaxIndex(System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
        <para>
            Finds the index of element having max.</para>
      </summary>
      <param name="n">The number of elements in the vector <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in the storage array.</param>
      <remarks>
        <para>
          <pre>
            absolute value.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 1/15/85.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.ApplyModifiedGivensRotation(System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Single[])">
      <summary>
        <para>
            THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX
               (DX<sup>T</sup>) , WHERE **T INDICATES TRANSPOSE.</para>
      </summary>
      <param name="n">
        <pre>
            number of elements in input vector(s)
            </pre>
      </param>
      <param name="x">
        <pre>
            Dimension N
            T precision vector with N elements
            </pre>
      </param>
      <param name="incx">
        <pre>
            storage spacing between elements of DX
            </pre>
      </param>
      <param name="y">
        <pre>
            Dimension N
            T precision vector with N elements
            </pre>
      </param>
      <param name="incy">
        <pre>
            storage spacing between elements of DY
            </pre>
      </param>
      <param name="dparam">
        <pre>
            Dimension 5
            AM(1)=DFLAG
            RAM(2)=DH11
            ARAM(3)=DH21
            PARAM(4)=DH12
            DPARAM(5)=DH22
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            THE ELEMENTS OF DX ARE IN
               (DY<sup>T</sup>)
               DX(LX+I*INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX  &gt;=  0, ELSE
               LX = (-INCX)*N, AND SIMILARLY FOR SY USING LY AND INCY.
               WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.
               DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0
                 (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0)
               H=(          )    (          )    (          )    (          )
                 (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0).
               SEE DROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandHermitianMultiplyAndAddInPlace(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x, incx and y are n element vectors and
            A is an n by n hermitian band matrix, with k super-diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the band matrix A is being supplied as
             follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    being supplied.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    being supplied.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry, K specifies the number of super-diagonals of the
             matrix A. K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the hermitian matrix, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer the upper
             triangular part of a hermitian band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the hermitian matrix, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer the lower
             triangular part of a hermitian band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandMatrixNorm(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the norm of a general band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="kl">The number of sub-diagonals of the matrix.</param>
      <param name="ku">The number of super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGB</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandMatrixNorm(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
            Computes the norm of a general band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="kl">The number of sub-diagonals of the matrix.</param>
      <param name="ku">The number of super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGB</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandMultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,   or
               y := alpha*A<sup>H</sup>*x + beta*y,
            where alpha and beta are scalars, x, incx and y are vectors and A is an
            m by n band matrix, with kl sub-diagonals and ku super-diagonals.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>H</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="kl">
        <pre>
             On entry, KL specifies the number of sub-diagonals of the
             matrix A. KL must satisfy  0 .le. KL.
            </pre>
      </param>
      <param name="ku">
        <pre>
             On entry, KU specifies the number of super-diagonals of the
             matrix A. KU must satisfy  0 .le. KU.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry, the leading ( kl + ku + 1 ) by n part of the
             array A must contain the matrix of coefficients, supplied
             column by column, with the leading diagonal of the matrix in
             row ( ku + 1 ) of the array, the first super-diagonal
             starting at position 2 in row ku, the first sub-diagonal
             starting at position 1 in row ( ku + 2 ), and so on.
             Elements in the array A that do not correspond to elements
             in the band matrix (such as the top left ku by ku triangle)
             are not referenced.
             The following program segment will transfer a band matrix
             from conventional full matrix storage to band storage:
                   DO 20, J = 1, N
                      K = KU + 1 - J
                      DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
                         A( K + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( kl + ku + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandMultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n band matrix, with kl sub-diagonals and ku super-diagonals.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>T</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="kl">
        <pre>
             On entry, KL specifies the number of sub-diagonals of the
             matrix A. KL must satisfy  0 .le. KL.
            </pre>
      </param>
      <param name="ku">
        <pre>
             On entry, KU specifies the number of super-diagonals of the
             matrix A. KU must satisfy  0 .le. KU.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading ( kl + ku + 1 ) by n part of the
             array A must contain the matrix of coefficients, supplied
             column by column, with the leading diagonal of the matrix in
             row ( ku + 1 ) of the array, the first super-diagonal
             starting at position 2 in row ku, the first sub-diagonal
             starting at position 1 in row ( ku + 2 ), and so on.
             Elements in the array A that do not correspond to elements
             in the band matrix (such as the top left ku by ku triangle)
             are not referenced.
             The following program segment will transfer a band matrix
             from conventional full matrix storage to band storage:
                   DO 20, J = 1, N
                      K = KU + 1 - J
                      DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
                         A( K + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( kl + ku + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandSymmetricMultiplyAndAddInPlace(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric band matrix, with k super-diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the band matrix A is being supplied as
             follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    being supplied.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    being supplied.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry, K specifies the number of super-diagonals of the
             matrix A. K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the symmetric matrix, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer the upper
             triangular part of a symmetric band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the symmetric matrix, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer the lower
             triangular part of a symmetric band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandTriangularMultiplyInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular band matrix, with ( k + 1 ) diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandTriangularMultiplyInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular band matrix, with ( k + 1 ) diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandTriangularSolveInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular band matrix, with ( k + 1 )
            diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandTriangularSolveInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular band matrix, with ( k + 1 )
            diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.ComplexOneNorm(Numerics.NET.Complex{System.Single})">
      <summary>
        <para>
            Computes the sum of the absolute values of a complex number
            </para>
      </summary>
      <remarks>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.ConjugateDotProduct(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Forms the dot product of a vector.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.ConjugateRankUpdate(System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs the rank 1 operation
               A := alpha*x*y**H + A,
            where alpha is a scalar, x, incx is an m element vector, y, incy is an n element
            vector and A is an m by n matrix.</para>
      </summary>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Copy(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Copies the specified elements of a complex matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies which part of the matrix should be copied.</param>
      <param name="m">The number of rows of the matrices.</param>
      <param name="n">The number of columns of the matrices.</param>
      <param name="a">A complex array that contains the data for the source matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the data for the destination matrix.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <remarks>This method corresponds to the LAPACK routine <c>?LACPY</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Copy(Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Copies the specified elements of a complex matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies which part of the matrix should be copied.</param>
      <param name="m">The number of rows of the matrices.</param>
      <param name="n">The number of columns of the matrices.</param>
      <param name="a">A complex array that contains the data for the source matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <param name="b">A complex array that contains the data for the destination matrix.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <remarks>This method corresponds to the LAPACK routine <c>?LACPY</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Copy(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Copies a vector, x, incx, to a vector, y, incy.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the elements of <paramref name="x" />.</param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, linpack, 4/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Copy(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Copies a vector, x, incx, to a vector, y, incy.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the elements of <paramref name="x" />.</param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, linpack, 4/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.CreateGivensRotation(Numerics.NET.Complex{System.Single}@,Numerics.NET.Complex{System.Single},System.Single@,Numerics.NET.Complex{System.Single}@)">
      <summary>
        <para>
            Determines a complex Givens rotation.</para>
      </summary>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.CreateGivensRotation(System.Single@,System.Single@,System.Single@,System.Single@)">
      <summary>
        <para>
            Construct givens plane rotation.</para>
      </summary>
      <param name="a">The first element of the input vector.
            On exit, this value is overwritten with the rotated
            element <i>r</i>.</param>
      <param name="b">The second element of the input vector.
            On exit, this value is overwritten with the
            reconstruction value <i>z</i>.</param>
      <param name="c">On exit, this value is overwritten with
            the first rotation element, the cosine of the rotation
            angle.</param>
      <param name="s">On exit, this value is overwritten with
            the second rotation element, the sine of the rotation
            angle.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, linpack, 3/11/78.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.CreateModifiedGivensRotation(System.Single@,System.Single@,System.Single@,System.Single,System.Single[])">
      <summary>
        <para>
            THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS
               THE SECOND COMPONENT OF THE 2-VECTOR  (DSQRT(DD1)*DX1,DSQRT(DD2)*&gt;    DY2)**T.</para>
      </summary>
      <param name="dd1">
        <pre></pre>
      </param>
      <param name="dd2">
        <pre></pre>
      </param>
      <param name="dx1">
        <pre></pre>
      </param>
      <param name="dy1">
        <pre></pre>
      </param>
      <param name="dparam">
        <pre>
            Dimension 5
            AM(1)=DFLAG
            RAM(2)=DH11
            ARAM(3)=DH21
            PARAM(4)=DH12
            DPARAM(5)=DH22
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
               WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.
               DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0
                 (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0)
               H=(          )    (          )    (          )    (          )
                 (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0).
               LOCATIONS 2-4 OF DPARAM CONTAIN DH11, DH21, DH12, AND DH22
               RESPECTIVELY. (VALUES OF 1.D0, -1.D0, OR 0.D0 IMPLIED BY THE
               VALUE OF DPARAM(1) ARE NOT STORED IN DPARAM.)
               THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE
               INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE
               OF DD1 AND DD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.DotProduct(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Forms the dot product of two vectors.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.DotProduct(System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
        <para>
            Forms the dot product of two vectors.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.FullMatrixNorm(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the norm of a general rectangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="m">The number of rows of the matrix.</param>
      <param name="n">The number of columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGE</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.FullMatrixNorm(Numerics.NET.MatrixNorm,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
            Computes the norm of a general rectangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="m">The number of rows of the matrix.</param>
      <param name="n">The number of columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGE</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianBandMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the norm of a symmetric band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="k">The number of sub- and super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to 
            the LAPACK routine <c>?LANHB</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the norm of a Hermitian matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANHE</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianMultiplyAndAddInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where alpha and beta are scalars, A is an hermitian matrix and  B and
            C are m by n matrices.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE  specifies whether  the  hermitian matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  hermitian  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    hermitian matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    hermitian matrix is to be referenced.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is n  otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  hermitian matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  hermitian matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  hermitian
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  hermitian matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  hermitian matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  hermitian
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Note that the imaginary parts  of the diagonal elements need
             not be set, they are assumed to be zero.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianMultiplyAndAddInPlace(Numerics.NET.MatrixTriangle,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x, incx and y are n element vectors and
            A is an n by n hermitian matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced.
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Single,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the hermitian rank 2k operations
               C := alpha*A*B<sup>H</sup> + conjg( alpha )*B*A<sup>H</sup> + beta*C,
            or
               C := alpha*A<sup>H</sup>*B + conjg( alpha )*B<sup>H</sup>*A + beta*C,
            where  alpha and beta  are scalars with  beta  real,  C is an  n by n
            hermitian matrix and  A and B  are  n by k matrices in the first case
            and  k by n  matrices in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'    C := alpha*A*B<sup>H</sup>          +
                                           conjg( alpha )*B*A<sup>H</sup> +
                                           beta*C.
                TRANS = 'C' or 'c'    C := alpha*A<sup>H</sup>*B          +
                                           conjg( alpha )*B<sup>H</sup>*A +
                                           beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is complex .
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
             Unchanged on exit.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION .
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.
               Ed Anderson, Cray Research Inc.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Single,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Single,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the hermitian rank k operations
               C := alpha*A*A<sup>H</sup> + beta*C,
            or
               C := alpha*A<sup>H</sup>*A + beta*C,
            where  alpha and beta  are  real scalars,  C is an  n by n  hermitian
            matrix and  A  is an  n by k  matrix in the  first case and a  k by n
            matrix in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>H</sup> + beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>H</sup>*A + beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION .
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.
               Ed Anderson, Cray Research Inc.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianRankUpdate(Numerics.NET.MatrixTriangle,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs the hermitian rank 2 operation
               A := alpha*x*y**H + conjg( alpha )*y*x**H + A,
            where alpha is a scalar, x, incx and y are n element vectors and A is an n
            by n hermitian matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianRankUpdate(Numerics.NET.MatrixTriangle,System.Int32,System.Single,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs the hermitian rank 1 operation
               A := alpha*x*x**H + A,
            where alpha is a real scalar, x, incx is an n element vector and A is an
            n by n hermitian matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*op( A )*op( B ) + beta*C,
            where  op( X ) is one of
               op( X ) = X   or   op( X ) = X<sup>T</sup>   or   op( X ) = X<sup>H</sup>,
            alpha and beta are scalars, and A, B and C are matrices, with op( A )
            an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</para>
      </summary>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n',  op( A ) = A.
                TRANSA = 'T' or 't',  op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c',  op( A ) = A<sup>H</sup>.
            </pre>
      </param>
      <param name="transb">
        <pre>
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:
                TRANSB = 'N' or 'n',  op( B ) = B.
                TRANSB = 'T' or 't',  op( B ) = B<sup>T</sup>.
                TRANSB = 'C' or 'c',  op( B ) = B<sup>H</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="transB">Specifies the operation to be
            performed on the matrix <paramref name="b" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*op( A )*op( B ) + beta*C,
            where  op( X ) is one of
               op( X ) = X   or   op( X ) = X<sup>T</sup>,
            alpha and beta are scalars, and A, B and C are matrices, with op( A )
            an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</para>
      </summary>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n',  op( A ) = A.
                TRANSA = 'T' or 't',  op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c',  op( A ) = A<sup>T</sup>.
            </pre>
      </param>
      <param name="transb">
        <pre>
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:
                TRANSB = 'N' or 'n',  op( B ) = B.
                TRANSB = 'T' or 't',  op( B ) = B<sup>T</sup>.
                TRANSB = 'C' or 'c',  op( B ) = B<sup>T</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="transB">Specifies the operation to be
            performed on the matrix <paramref name="b" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,   or
               y := alpha*A<sup>H</sup>*x + beta*y,
            where alpha and beta are scalars, x, incx and y are vectors and A is an
            m by n matrix.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>H</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n matrix.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>T</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Constant times a vector plus a vector.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.</param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Constant times a vector plus a vector.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.</param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre>
            uses unrolled loops for increments equal to one.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, linpack, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyInPlace(System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Scales a vector by a constant.</para>
      </summary>
      <param name="n">The number of elements in the vector
            <paramref name="x" />.</param>
      <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            The elements of <paramref name="x" /> are overwritten with
            the result.</param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyInPlace(System.Int32,System.Single,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Scales a vector by a constant.</para>
      </summary>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyInPlace(System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Scales a vector by a constant.</para>
      </summary>
      <param name="n">The number of elements in the vector
            <paramref name="x" />.</param>
      <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            The elements of <paramref name="x" /> are overwritten with
            the result.</param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Name">
      <summary>
            Gets the name of the implementation.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.OneNorm(System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
        <para>
            Takes the sum of the absolute values.</para>
      </summary>
      <param name="n">The number of elements in the vector <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, linpack, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Platform">
      <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.RankUpdate(System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs the rank 1 operation
               A := alpha*x*y**T + A,
            where alpha is a scalar, x, incx is an m element vector, y, incy is an n element
            vector and A is an m by n matrix.</para>
      </summary>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.RankUpdate(System.Int32,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs the rank 1 operation
               A := alpha*x*y**T + A,
            where alpha is a scalar, x is an m element vector, y is an n element
            vector and A is an m by n matrix.</para>
      </summary>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.RealOneNorm(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Takes the sum of the absolute values.</para>
      </summary>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Rotate(System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Single,System.Single)">
      <summary>
        <para>
            A plane rotation, where the cos and sin (c and s) are real
            and the vectors cx and cy are complex.</para>
      </summary>
      <param name="n">
        <pre>
             On entry, N specifies the order of the vectors cx and cy.
             N must be at least zero.
            </pre>
      </param>
      <param name="cx">
        <pre>
            CX is complex array, dimension at least
             ( 1 + ( N - 1 )*abs( INCX ) ).
             Before entry, the incremented array CX must contain the n
             element vector cx. On exit, CX is overwritten by the updated
             vector cx.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             CX. INCX must not be zero.
            </pre>
      </param>
      <param name="cy">
        <pre>
            CY is complex array, dimension at least
             ( 1 + ( N - 1 )*abs( INCY ) ).
             Before entry, the incremented array CY must contain the n
             element vector cy. On exit, CY is overwritten by the updated
             vector cy.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             CY. INCY must not be zero.
            </pre>
      </param>
      <param name="c">
        <pre>
             On entry, C specifies the cosine, cos.
            </pre>
      </param>
      <param name="s">
        <pre>
             On entry, S specifies the sine, sin.
            </pre>
      </param>
      <remarks>
        <para>
          <pre>
            jack dongarra, linpack, 3/11/78.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Rotate(System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32,System.Single,System.Single)">
      <summary>
        <para>
            A plane rotation, where the cos and sin (c and s) are real
            and the vectors cx and cy are complex.</para>
      </summary>
      <param name="n">
        <pre>
             On entry, N specifies the order of the vectors cx and cy.
             N must be at least zero.
            </pre>
      </param>
      <param name="cx">
        <pre>
            CX is complex array, dimension at least
             ( 1 + ( N - 1 )*abs( INCX ) ).
             Before entry, the incremented array CX must contain the n
             element vector cx. On exit, CX is overwritten by the updated
             vector cx.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             CX. INCX must not be zero.
            </pre>
      </param>
      <param name="cy">
        <pre>
            CY is complex array, dimension at least
             ( 1 + ( N - 1 )*abs( INCY ) ).
             Before entry, the incremented array CY must contain the n
             element vector cy. On exit, CY is overwritten by the updated
             vector cy.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             CY. INCY must not be zero.
            </pre>
      </param>
      <param name="c">
        <pre>
             On entry, C specifies the cosine, cos.
            </pre>
      </param>
      <param name="s">
        <pre>
             On entry, S specifies the sine, sin.
            </pre>
      </param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <remarks>
        <para>
          <pre>
            jack dongarra, linpack, 3/11/78.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Swap(System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Interchanges two vectors.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Swap(System.Int32,System.Span{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Interchanges two vectors.</para>
      </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <param name="y">A span
            containing the elements of the vector <paramref name="y" />.
            </param>
      <param name="incy">The distance between elements in <paramref name="y" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricBandMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the norm of a symmetric band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="k">The number of sub- and super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>
        <para>This method corresponds to the LAPACK routine <c>?LANSB</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricBandMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
            Computes the norm of a symmetric band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="k">The number of sub- and super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>
        <para>This method corresponds to the LAPACK routine <c>?LANSB</c>.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the norm of a symmetric matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANSY</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
            Computes the norm of a symmetric matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANSY</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricMultiplyAndAddInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where  alpha and beta are scalars, A is a symmetric matrix and  B and
            C are m by n matrices.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE  specifies whether  the  symmetric matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  symmetric  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    symmetric matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    symmetric matrix is to be referenced.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is n  otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>                                                                                                                                                                  /// Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricMultiplyAndAddInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,System.Int32,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where alpha and beta are scalars,  A is a symmetric matrix and  B and
            C are  m by n matrices.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE  specifies whether  the  symmetric matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  symmetric  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    symmetric matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    symmetric matrix is to be referenced.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is  n otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricMultiplyAndAddInPlace(Numerics.NET.MatrixTriangle,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the symmetric rank k operations
               C := alpha*A*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
            and  A  is an  n by k  matrix in the first case and a  k by n  matrix
            in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>T</sup> + beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*A + beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="c" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the symmetric rank 2k operations
               C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
            and  A and B  are  n by k  matrices  in the  first  case  and  k by n
            matrices in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'    C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> +
                                           beta*C.
                TRANS = 'T' or 't'    C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                           beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is complex array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs one of the symmetric rank 2k operations
               C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
            and  A and B  are  n by k  matrices  in the  first  case  and  k by n
            matrices in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> +
                                          beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                          beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                          beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrices  A and B.  K must be at least  zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs one of the symmetric rank k operations
               C := alpha*A*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
            and  A  is an  n by k  matrix in the first case and a  k by n  matrix
            in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>T</sup> + beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*A + beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>T</sup>*A + beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrix  A.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="ldc">
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="c" /> are stored in the
            upper or lower triangular part.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs the symmetric rank 2 operation
               A := alpha*x*y**T + alpha*y*x**T + A,
            where alpha is a scalar, x and y are n element vectors and A is an n
            by n symmetric matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
      </param>
      <param name="incy">
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Numerics.NET.MatrixTriangle,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs the symmetric rank 1 operation
               A := alpha*x*x**T + A,
            where alpha is a real scalar, x is an n element vector and A is an
            n by n symmetric matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularBandMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the norm of a triangular band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="diag">Specifies whether or not
            the matrix is unit triangular.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="k">The number of sub- or super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGB</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularBandMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
            Computes the norm of a triangular band matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="diag">Specifies whether or not
            the matrix is unit triangular.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="k">The number of sub- or super-diagonals of the matrix.</param>
      <param name="ab">A span of <typeparamref name="T" /> that contains the elements 
            of the matrix in band storage format.</param>
      <param name="ldab">The leading dimension of the matrix <paramref name="ab" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANGB</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the norm of a triangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix is upper or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the diagonal
            elements are all equal to one.</param>
      <param name="m">The number of rows of the matrix.</param>
      <param name="n">The number of columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANTR</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMatrixNorm(Numerics.NET.MatrixNorm,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
            Computes the norm of a triangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Numerics.NET.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" /> value that specifies whether the
            matrix is upper or lower triangular.</param>
      <param name="diag">A <see cref="T:Numerics.NET.MatrixDiagonal" /> value that indicates whether the diagonal
            elements are all equal to one.</param>
      <param name="m">The number of rows of the matrix.</param>
      <param name="n">The number of columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="lda">The leading dimension of the matrix <paramref name="a" />.</param>
      <returns>The norm of the matrix.</returns>
      <remarks>This method corresponds to the LAPACK routine <c>?LANTR</c>.</remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMultiplyInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               B := alpha*op( A )*B,   or   B := alpha*B*op( A )
            where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>   or   op( A ) = A<sup>H</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
                SIDE = 'L' or 'l'   B := alpha*op( A )*B.
                SIDE = 'R' or 'r'   B := alpha*B*op( A ).
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>H</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is (input/output) complex array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMultiplyInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
            where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
                SIDE = 'L' or 'l'   B := alpha*op( A )*B.
                SIDE = 'R' or 'r'   B := alpha*B*op( A ).
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>T</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
            when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
            Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
            upper triangular part of the array  A must contain the upper
            triangular matrix  and the strictly lower triangular part of
            A is not referenced.
            Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
            lower triangular part of the array  A must contain the lower
            triangular matrix  and the strictly upper triangular part of
            A is not referenced.
            Note that when  DIAG = 'U' or 'u',  the diagonal elements of
            A  are not referenced either,  but are assumed to be  unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMultiplyInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMultiplyInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre></pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularSolveInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Solves one of the matrix equations
               op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
            where alpha is a scalar, X and B are m by n matrices, A is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>   or   op( A ) = A<sup>H</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:
                SIDE = 'L' or 'l'   op( A )*X = alpha*B.
                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>H</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, k ),
             where k is m when SIDE = 'L' or 'l'
               and k is n when SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre>
            The matrix X is overwritten on B.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularSolveInPlace(Numerics.NET.MatrixOperationSide,Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Solves one of the matrix equations
               op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
            where alpha is a scalar, X and B are m by n matrices, A is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:
                SIDE = 'L' or 'l'   op( A )*X = alpha*B.
                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>T</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, k ),
             where k is m when SIDE = 'L' or 'l'
               and k is n when SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.
            </pre>
      </param>
      <param name="ldb">
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a" /> are stored in the
            upper or lower triangular part.</param>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <remarks>
        <para>
          <pre>
            The matrix X is overwritten on B.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularSolveInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularSolveInPlace(Numerics.NET.MatrixTriangle,Numerics.NET.TransposeOperation,Numerics.NET.MatrixDiagonal,System.Int32,System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
      </param>
      <param name="lda">
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is complex array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
      </param>
      <param name="incx">
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
      <param name="transposeOperation">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="diagonal">Specifies whether or not
            the matrix is unit triangular.</param>
      <remarks>
        <para>
          <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
        </para>
        <h4> Further Details:</h4>
        <para>
          <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TwoNorm(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
        <para>
          <pre>
            Returns the euclidean norm of a vector via the function
            name, so that
               DZNRM2 := sqrt( x**H*x )
            </pre>
        </para>
      </summary>
      <remarks>
        <h4>Further Details:</h4>
        <para>
             -- This version written on 25-October-1982.</para>
        <para>
          <pre>
            Modified on 14-October-1993 to inline the call to ZLASSQ.
            Sven Hammarling, Nag Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TwoNorm(System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
        <para>
          <pre>
            Returns the euclidean norm of a vector via the function
            name, so that
               DZNRM2 := sqrt( x**H*x )
            </pre>
        </para>
      </summary>
      <param name="n">The number of elements in the vector <paramref name="x" />.</param>
      <param name="x">A span
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="incx">The distance between elements in <paramref name="x" />.</param>
      <remarks>
        <h4>Further Details:</h4>
        <para>
             -- This version written on 25-October-1982.</para>
        <para>
          <pre>
            Modified on 14-October-1993 to inline the call to ZLASSQ.
            Sven Hammarling, Nag Ltd.
            </pre>
        </para>
        <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
        <para>Date:  November 2011</para>
      </remarks>
    </member>
    <member name="T:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle">
      <summary>
            Contains the managed implementation of the sparse BLAS routines.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle" /> object.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Multiplies a dense vector by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="xStride">The distance between successive elements in <paramref name="x" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="y" />.
            </param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,Numerics.NET.Complex{System.Single},System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Multiplies a dense matrix by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="n">The number of columns in the matrix <paramref name="c" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="n" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="n" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="b">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="b" />.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="c" />.
            </param>
      <param name="c">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="c" />.
            The elements of <paramref name="c" /> are overwritten with
            the result.
            </param>
      <param name="ldc">The leading dimension of the matrix <paramref name="c" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Single,Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
            Multiplies a dense matrix by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="n">The number of columns in the matrix <paramref name="c" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="n" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="n" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="b">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="b" />.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="c" />.
            </param>
      <param name="c">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="c" />.
            The elements of <paramref name="c" /> are overwritten with
            the result.
            </param>
      <param name="ldc">The leading dimension of the matrix <paramref name="c" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Single,Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
            Multiplies a dense vector by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="xStride">The distance between successive elements in <paramref name="x" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="y" />.
            </param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.Name">
      <summary>
            Gets the name of the implementation.
            </summary>
    </member>
    <member name="P:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.Platform">
      <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.TriangularSolve(Numerics.NET.TransposeOperation,System.Int32,Numerics.NET.Complex{System.Single},Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Solves for a dense vector for a sparse matrix in compressed sparse column format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="xStride">The distance between successive elements in <paramref name="x" />.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.TriangularSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,Numerics.NET.Complex{System.Single},Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Solves for a dense matrix for a sparse matrix in compressed sparse column format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="n">The number of columns in the matrix <paramref name="b" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="b">A two-dimensional array
            containing the elements of the right-hand side.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="c">A two-dimensional array
            containing the elements of the solution.
            </param>
      <param name="ldc">The leading dimension of the matrix <paramref name="c" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.TriangularSolve(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Single,Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Solves for a dense vector for a sparse matrix in compressed sparse column format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="xStride">The distance between successive elements in <paramref name="x" />.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
      <param name="n">The number of columns in the matrix <paramref name="b" />.</param>
      <param name="b">A two-dimensional array
            containing the elements of the right-hand side.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="c">A two-dimensional array
            containing the elements of the solution.
            </param>
      <param name="ldc">The leading dimension of the matrix <paramref name="c" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.TriangularSolve(Numerics.NET.TransposeOperation,System.Int32,System.Single,Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Single},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Solves for a dense vector for a sparse matrix in compressed sparse column format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="xStride">The distance between successive elements in <paramref name="x" />.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
    </member>
    <member name="T:Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle">
      <summary>
            Summary description for SparseBlas.
            </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.DotProduct(System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.ReadOnlySpan{System.Int32},System.Int32,System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Returns the dot product of a sparse and a dense vector.
            </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="indx">Integer array of component indices.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.</param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
      <param name="m">The length of the vector <paramref name="y" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.DotProduct(System.Int32,System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Int32},System.Int32,System.ReadOnlySpan{System.Single},System.Int32)">
      <summary>
            Returns the dot product of a sparse and a dense vector.
            </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="indx">Integer array of component indices.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.</param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
      <param name="m">The length of the vector <paramref name="y" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Numerics.NET.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Single,Numerics.NET.MatrixStructure,Numerics.NET.MatrixTriangle,Numerics.NET.MatrixDiagonal,System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Single},System.Int32,System.Single,System.Span{System.Single},System.Int32)">
      <summary>
            Multiplies a dense matrix by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="n">The number of columns in the matrix <paramref name="c" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
      <param name="structure">A <see cref="T:Numerics.NET.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Numerics.NET.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Numerics.NET.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">A span that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="n" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="n" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="b">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="b" />.</param>
      <param name="ldb">The leading dimension of the matrix <paramref name="b" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="c" />.
            </param>
      <param name="c">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="c" />.
            The elements of <paramref name="c" /> are overwritten with
            the result.
            </param>
      <param name="ldc">The leading dimension of the matrix <paramref name="c" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.ScaleAndAddInPlace(System.Int32,Numerics.NET.Complex{System.Single},System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.ReadOnlySpan{System.Int32},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Evaluates a vector plus the product of a scalar and a sparse vector.
            </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x" />.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="indx">Integer array of component indices.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.</param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
      <param name="m">The length of the vector <paramref name="y" />.</param>
    </member>
    <member name="M:Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.ScaleAndAddInPlace(System.Int32,System.Single,System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Int32},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Evaluates a vector plus the product of a scalar and a sparse vector.
            </summary>
      <param name="n">The number of elements in the vectors
            <paramref name="x" /> and <paramref name="y" />.</param>
      <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x" />.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.
            </param>
      <param name="indx">Integer array of component indices.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.</param>
      <param name="yStride">The distance between successive elements in <paramref name="y" />.</param>
      <param name="m">The length of the vector <paramref name="y" />.</param>
    </member>
    <member name="T:Numerics.NET.Providers.ManagedCoreProviderOfSingle">
      <summary>
            Encapsulates the currently active BLAS implementation.
            </summary>
      <remarks>
        <para>
            The classes in the <see cref="N:Numerics.NET.LinearAlgebra" />
            namespace use the standard Basic Linear Algebra Subroutines
            (BLAS) whenever possible. The Extreme Optimization Mathematics Library
            for .NET provides two implementations. One is in 100% managed code.
            The other calls a native, highly optimized, processor-specific kernel.</para>
        <para>This class exposes properties that allow
            you to specify the BLAS objects that are to be used by
            the classes in this namespace.</para>
        <para>You can select the managed implementation by calling 
            the <see cref="M:Numerics.NET.CoreImplementations`1.UseManaged" /> method. 
            To select the native implementation, call the <see cref="M:Numerics.NET.CoreImplementations`1.UseNative" /> method.
            The native kernel is used by default. This is the fastest option,
            especially for larger matrices, but also has a larger memory footprint.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Providers.ManagedCoreProviderOfSingle.#ctor">
      <summary>
            Constructs a new <see cref="T:Numerics.NET.Providers.ManagedCoreProviderOfSingle" />.
            </summary>
    </member>
    <member name="P:Numerics.NET.Providers.ManagedCoreProviderOfSingle.ArrayFunctions">
      <summary>
            Gets or sets the current implementation of array functions
            for double-precision arguments.
            </summary>
      <value>A class that inherits from <see cref="T:Numerics.NET.Implementation.DecompositionOperations`2" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctions`1" />.
            </para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Providers.ManagedCoreProviderOfSingle.ComplexArrayFunctions">
      <summary>
            Gets or sets the current implementation of array functions
            for double-precision arguments.
            </summary>
      <value>A class that inherits from <see cref="T:Numerics.NET.Implementation.DecompositionOperations`2" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.LinearAlgebra.Implementation.ManagedArrayFunctions`1" />.
            </para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Providers.ManagedCoreProviderOfSingle.DecompositionOperations">
      <summary>
            Gets the LAPACK implementation
            for single precision arguments.
            </summary>
      <value>A class that inherits from <see cref="T:Numerics.NET.Implementation.DecompositionOperations`2" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.LinearAlgebra.Implementation.ManagedLapack" />.
            </para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Providers.ManagedCoreProviderOfSingle.Fft">
      <summary>
            Gets or sets the current FFT provider implementation
            for single precision arguments.
            </summary>
      <value>A class that inherits from <see cref="T:Numerics.NET.SignalProcessing.FftOperations`1" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.SignalProcessing.ManagedFftProvider" />.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Providers.ManagedCoreProviderOfSingle.GetAllImplementations``1">
      <summary>
            Enumerates all implementations of the specified type that are available from
            the provider.
            </summary>
      <typeparam name="T">The type of the implementation.</typeparam>
      <returns>A sequence of implementation objects.</returns>
    </member>
    <member name="P:Numerics.NET.Providers.ManagedCoreProviderOfSingle.HasSharedDegreeOfParallelism">
      <summary>
            Indicates whether the degree of parallelism is a property that is shared
            across instances.
            </summary>
    </member>
    <member name="P:Numerics.NET.Providers.ManagedCoreProviderOfSingle.LinearAlgebraOperations">
      <summary>
            Gets the implementation of the 
            BLAS for single precision arguments.
            </summary>
      <value>A class that inherits from <see cref="P:Numerics.NET.Providers.ManagedCoreProviderOfSingle.LinearAlgebraOperations" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.LinearAlgebra.Implementation.ManagedLinearAlgebraOperations" />.
            </para>
      </remarks>
    </member>
    <member name="P:Numerics.NET.Providers.ManagedCoreProviderOfSingle.SparseLinearAlgebra">
      <summary>
            Gets the implementation of the sparse
            BLAS for single precision arguments.
            </summary>
      <value>A class that inherits from <see cref="T:Numerics.NET.LinearAlgebra.Implementation.SparseLinearAlgebraOperations" />.</value>
      <remarks>
        <para>The default value of this property is
            an instance of <see cref="T:Numerics.NET.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperations" />.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.Providers.ManagedCoreProviderOfSingle.WithMaxDegreeOfParallelism(System.Int32)">
      <summary>
            Returns a provider with the specified maximum degree of parallelism.
            </summary>
      <param name="maxDegreeOfParallelism">The maximum degree of parallelism.</param>
      <returns>A <see cref="T:Numerics.NET.Providers.ManagedCoreProviderOfSingle" /> with the specified
            maximum degree of parallelism.</returns>
    </member>
    <member name="T:Numerics.NET.Providers.MklProviderOfSingle">
      <summary>
            Represents a core provider based on Intel®'s
            Math Kernel Library.
            </summary>
    </member>
    <member name="M:Numerics.NET.Providers.MklProviderOfSingle.#ctor">
      <summary>
            Constructs a new Intel® MKL based provider.
            </summary>
    </member>
    <member name="P:Numerics.NET.Providers.MklProviderOfSingle.ConditionalNumericalReproducibility">
      <summary>
            Gets or sets the degree of numerical reproducibility.
            </summary>
    </member>
    <member name="M:Numerics.NET.Providers.MklProviderOfSingle.LoadManaged(System.String)">
      <summary>
            Loads the pure managed Intel® MKL based provider
            from the specified path.
            </summary>
      <param name="libraryPath">(Optional.) The path where the
            native library is located.</param>
      <returns>A reference to the provider.</returns>
    </member>
    <member name="M:Numerics.NET.Providers.MklProviderOfSingle.LoadMixed(System.String,System.String)">
      <summary>
            Loads the mixed mode Intel® MKL based provider
            from the specified path.
            </summary>
      <param name="libraryPath">(Optional.) The path where the
            native library is located.</param>
      <param name="baseName">(Optional.) The name of the assembly to load.</param>
      <returns>A reference to the provider.</returns>
      <remarks>The mixed mode provider was written in C++/CLI 
            and is the preferred provider on Microsoft Windows platforms.</remarks>
    </member>
    <member name="P:Numerics.NET.Providers.MklProviderOfSingle.MklVersion">
      <summary>
            Gets a description of the Intel® Math Kernel Library version
            the provider is based on.
            </summary>
    </member>
    <member name="M:Numerics.NET.Providers.MklProviderOfSingle.ToString">
      <summary>Returns a string that represents the current object.</summary>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="M:Numerics.NET.Providers.MklProviderOfSingle.TryLoadManaged(Numerics.NET.Providers.MklProviderOfSingle@,System.String)">
      <summary>
            Attempts to load the pure managed Intel® MKL based provider
            from the specified path.
            </summary>
      <param name="libraryPath">(Optional.) The path where the
            native library is located.</param>
      <param name="provider">On return, the provider, if successful.</param>
      <returns>
        <see langword="true" /> if the provider was
            successfully created; otherwise <see langword="false" />.</returns>
    </member>
    <member name="T:Numerics.NET.SignalProcessing.ManagedFft2DOfSingle">
      <summary>
            Represents a managed two-dimensional FFT implementation.
            </summary>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFft2DOfSingle.BackwardTransform(System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the discrete Fourier transform of a complex signal.
            </summary>
      <param name="input">A complex number array containing the input signal.</param>
      <param name="output">A complex number array to hold the transformed signal.</param>
      <exception cref="T:System.InvalidOperationException">
            The <see cref="T:Numerics.NET.SignalProcessing.FftDomain" /> of the transform is not complex.
            <para>-or-</para><para>The input and output are the same, but the transform was not set up for in place calculation</para></exception>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFft2DOfSingle.BackwardTransform(System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the discrete Fourier transform of a real signal.
            </summary>
      <param name="input">A <see cref="T:System.Double" /> array containing the input signal.</param>
      <param name="output">A complex number array to hold the transformed signal.</param>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFft2DOfSingle.BackwardTransformInPlace(System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the inverse discrete Fourier transform of a complex signal in place.
            </summary>
      <param name="input">On input, a complex number array containing the input signal.
            On return, the inverse transform of the input.</param>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFft2DOfSingle.ForwardTransform(System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the discrete Fourier transform of a complex signal.
            </summary>
      <param name="input">A complex number array containing the input signal.</param>
      <param name="output">A complex number array to hold the transformed signal.</param>
      <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept complex input.
            <para>-or-</para><para><paramref name="input" /> and <paramref name="output" /> are the same, but the Fourier transform implementation is not configured
            to handle in-place transforms.</para></exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="input" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="output" /> is <see langword="null" />.</para></exception>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFft2DOfSingle.ForwardTransform(System.ReadOnlySpan{System.Single},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the discrete Fourier transform of a real signal.
            </summary>
      <param name="input">A <see cref="T:System.Double" /> array containing the input signal.</param>
      <param name="output">A complex number array to hold the transformed signal.</param>
      <remarks>
        <para>
            The output is stored in a compact format to take advantage of the symmetry properties of a real Fourier transform.
            Specifically, <paramref name="output" /> contains only the first <em>n</em>/2+1 terms of the transformed signal.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept real input.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="input" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="output" /> is <see langword="null" />.</para></exception>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFft2DOfSingle.ForwardTransformInPlace(System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the discrete Fourier transform of a complex signal in place.
            </summary>
      <param name="input">On input, a complex number array containing the input signal.
            On return, the forward transform of the input.</param>
      <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept complex input.
            <para>-or-</para><para>The Fourier transform implementation is not configured to handle in-place transforms.</para></exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="input" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="T:Numerics.NET.SignalProcessing.ManagedFftOfSingle">
      <summary>
            Represents a managed FFT implementation.
            </summary>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftOfSingle.#ctor(Numerics.NET.SignalProcessing.FftDomain,System.Int32)">
      <summary>
            Constructs a new managed FFT implementation.
            </summary>
      <param name="domain">An <see cref="T:Numerics.NET.SignalProcessing.FftDomain" /> value that specifies whether the forward transform
            is of a real or a complex signal.</param>
      <param name="length">The length of the transform.</param>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftOfSingle.BackwardTransform(System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the discrete Fourier transform of a complex signal.
            </summary>
      <param name="input">A complex number array containing the input signal.</param>
      <param name="output">A complex number array to hold the transformed signal.</param>
      <exception cref="T:System.InvalidOperationException">
            The <see cref="T:Numerics.NET.SignalProcessing.FftDomain" /> of the transform is not complex.
            <para>-or-</para><para>The input and output are the same, but the transform was not set up for in place calculation</para></exception>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftOfSingle.BackwardTransform(System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{System.Single},System.Int32)">
      <summary>
            Computes the discrete Fourier transform of a real signal.
            </summary>
      <param name="input">A <see cref="T:System.Double" /> array containing the input signal.</param>
      <param name="output">A complex number array to hold the transformed signal.</param>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftOfSingle.BackwardTransformInPlace(System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the inverse discrete Fourier transform of a complex signal in place.
            </summary>
      <param name="input">On input, a complex number array containing the input signal.
            On return, the inverse transform of the input.</param>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftOfSingle.ForwardTransform(System.ReadOnlySpan{Numerics.NET.Complex{System.Single}},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the discrete Fourier transform of a complex signal.
            </summary>
      <param name="input">A complex number array containing the input signal.</param>
      <param name="output">A complex number array to hold the transformed signal.</param>
      <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept complex input.
            <para>-or-</para><para><paramref name="input" /> and <paramref name="output" /> are the same, but the Fourier transform implementation is not configured
            to handle in-place transforms.</para></exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="input" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="output" /> is <see langword="null" />.</para></exception>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftOfSingle.ForwardTransform(System.ReadOnlySpan{System.Single},System.Int32,System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the discrete Fourier transform of a real signal.
            </summary>
      <param name="input">A <see cref="T:System.Double" /> array containing the input signal.</param>
      <param name="output">A complex number array to hold the transformed signal.</param>
      <remarks>
        <para>
            The output is stored in a compact format to take advantage of the symmetry properties of a real Fourier transform.
            Specifically, <paramref name="output" /> contains only the first <em>n</em>/2+1 terms of the transformed signal.
            Use the <see cref="T:Numerics.NET.SignalProcessing.ComplexConjugateSignalVector`1" /> class to obtain a complex vector that represents the
            complete signal.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept real input.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="input" /> is <see langword="null" />.
            <para>-or-</para><para><paramref name="output" /> is <see langword="null" />.</para></exception>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftOfSingle.ForwardTransformInPlace(System.Span{Numerics.NET.Complex{System.Single}},System.Int32)">
      <summary>
            Computes the discrete Fourier transform of a complex signal in place.
            </summary>
      <param name="input">On input, a complex number array containing the input signal.
            On return, the forward transform of the input.</param>
      <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept complex input.
            <para>-or-</para><para>The Fourier transform implementation is not configured to handle in-place transforms.</para></exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="input" /> is <see langword="null" />.
            </exception>
    </member>
    <member name="T:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle">
      <summary>
            Represents the provider of managed FFT implementations.
            </summary>
    </member>
    <member name="P:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.ComplexManagedThresholdLength">
      <summary>
            Gets or sets the threshold for switching between the managed and native FFT providers.
            </summary>
      <remarks>
        <para>
            Complex transforms of length less than or equal to <see cref="P:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.ComplexManagedThresholdLength" /> are always
            performed using the managed provider. Complex transforms of length greater than <see cref="P:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.ComplexManagedThresholdLength" />
            are performed using a native provider, if one is available.
            </para>
        <para>The default value for the threshold is 32.</para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.Create1DComplexFft(System.Int32)">
      <summary>
            Creates a Fast Fourier Transformer for one-dimensional complex data.
            </summary>
      <param name="length">The length of the data vectors.</param>
      <returns>An <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> object that can be used to compute an FFT of length equal to <paramref name="length" />.</returns>
      <remarks>
        <para>
          <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> objects may use unmanaged memory and other resources. You should always call the dispose
            method before the last reference to an <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> object is released.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.Create1DRealFft(System.Int32)">
      <summary>
            Creates a Fast Fourier Transformer for one-dimensional real data.
            </summary>
      <param name="length">The length of the data vectors.</param>
      <returns>An <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> object that can be used to compute an FFT of length equal to <paramref name="length" />.</returns>
      <remarks>
        <para>
          <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> objects may use unmanaged memory and other resources. You should always call the dispose
            method before the last reference to an <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> object is released.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.Create2DComplexFft(System.Int32,System.Int32)">
      <summary>
            Creates a Fast Fourier Transformer for two-dimensional complex data.
            </summary>
      <param name="rowCount">The number of rows.</param>
      <param name="columnCount">The number of columns.</param>
      <returns>An <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> object that can be used to compute an FFT of 
            dimensions equal to <paramref name="rowCount" /> by <paramref name="columnCount" />.</returns>
      <remarks>
        <para>
          <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> objects may use unmanaged memory and other resources. You should always call the dispose
            method before the last reference to an <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> object is released.
            </para>
      </remarks>
    </member>
    <member name="M:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.Create2DRealFft(System.Int32,System.Int32)">
      <summary>
            Creates a Fast Fourier Transformer for two-dimensional real data.
            </summary>
      <param name="rowCount">The number of rows.</param>
      <param name="columnCount">The number of columns.</param>
      <returns>An <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> object that can be used to compute an FFT of 
            dimensions equal to <paramref name="rowCount" /> by <paramref name="columnCount" />.</returns>
      <remarks>
        <para>
          <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> objects may use unmanaged memory and other resources. You should always call the dispose
            method before the last reference to an <see cref="T:Numerics.NET.SignalProcessing.Fft`1" /> object is released.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The total number of elements is greater than 2<sup>31</sup>-1.
            </exception>
    </member>
    <member name="P:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.Name">
      <summary>
            Gets the name of the implementation.
            </summary>
    </member>
    <member name="P:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.Platform">
      <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
    </member>
    <member name="P:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.RealManagedThresholdLength">
      <summary>
            Gets or sets the threshold for switching between the managed and native FFT providers.
            </summary>
      <remarks>
        <para>
            Real transforms of length less than or equal to <see cref="P:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.RealManagedThresholdLength" /> are always
            performed using the managed provider. Real transforms of length greater than <see cref="P:Numerics.NET.SignalProcessing.ManagedFftProviderOfSingle.RealManagedThresholdLength" />
            are performed using a native provider, if one is available.
            </para>
        <para>The default value for the threshold is 64.</para>
      </remarks>
    </member>
  </members>
</doc>